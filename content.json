{"meta":{"title":"Acan's blog","subtitle":null,"description":"iOS Developer","author":"Acan","url":"https://github.com/hzsss","root":"/"},"pages":[{"title":"","date":"2019-04-28T02:34:07.700Z","updated":"2019-04-28T02:34:07.696Z","comments":true,"path":"about/index.html","permalink":"https://github.com/hzsss/about/index.html","excerpt":"","text":"关于我iOS 程序猿一枚，来自人杰地灵的江西赣州 喜欢看电影，打篮球，喜欢说走就走的旅行 如果有什么意见或建议，欢迎和我联系交流 可以关注我的微博账号还有我的GitHub账号 也可以给我发邮件huangzishan07@163.com “诶小伙子你这什么车啊？” “AE86啊，怎样？” “AE86？飘一下啊？” “随便啊。”"},{"title":"","date":"2019-04-28T14:36:36.030Z","updated":"2019-04-28T14:36:36.011Z","comments":true,"path":"friends/index.html","permalink":"https://github.com/hzsss/friends/index.html","excerpt":"","text":"友情链接PEI丶BLOG makochi laizw Aeron_Xie LiJun’s Blog 郑宇琦（Yuu） bestswifter Bingo’s Blog Nine’s Blog 甜欣屋 蝉时雨 mine mine 宅谈"},{"title":"Tags","date":"2019-04-27T09:47:27.490Z","updated":"2018-12-17T09:59:04.688Z","comments":true,"path":"tags/index.html","permalink":"https://github.com/hzsss/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-04-27T09:17:05.650Z","updated":"2018-12-17T09:59:04.687Z","comments":true,"path":"categories/index.html","permalink":"https://github.com/hzsss/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"云南之旅","slug":"云南之旅","date":"2019-05-20T17:54:49.000Z","updated":"2019-05-20T18:47:34.929Z","comments":true,"path":"云南之旅/","link":"","permalink":"https://github.com/hzsss/云南之旅/","excerpt":"","text":"一直以来都想要在毕业之前来一场说走就走的旅行，不管是一个人也好还是和小伙伴们一起。自从工作实习以来，越来越觉得能够有一段属于自己的时间是多么的难得。而毕业前的假期可能是最好的机会了，如果这次不出去走走的话，等以后毕业正式工作了，就只能等到小长假在人山人海中挣扎了。学校通知外出实习的同学要在5月20号左右返校，于是我向公司请了从5月15号到6月底的假，中间有5天的时间出去玩。 至于为什么选择了云南，有的人可能因为那部《心花路放》而心生向往，有的人可能因为那首《去大理》而一路西行，而我的原因很简单，就是想看看大自然。本来决定去山东的，回学校顺路还能去找我哥玩，但是我实在觉得城市风光都大同小异，没有什么特别的地方。正巧那天在深圳的皇庭广场吃云南小面，面超好吃，墙上写着“世界很大，云南不远”。我一边吃面一边想着，那不如就去云南吧。 我大概是提前了半个多月开始做准备，5天的旅游时间其实并不算很长，但是我一个人去的话就还好，好看的地方多待一会儿，不好看的地方就直接走人。好不容易出来一次，所以尽可能在5天之内去更多的地方，即使是走马观花似的游玩。在网上看了下攻略，于是决定去昆明、大理和丽江这三个地方。然后再在这几个地方选择几个景点游玩。 昆明 大理 丽江 5.16 到达昆明 5.17 南屏步行街、滇池、翠湖、云南大学 5.18 环洱海 5.19 丽江古城、玉龙雪山 5.20 回昆明 时间还是比较紧的，基本上每个城市只待一天。不过对于我一个人来说差不多了。 昆明5月16号从深圳到达昆明，在机场附近住了一晚。第二天8点钟就坐地铁去","categories":[],"tags":[{"name":"生活","slug":"生活","permalink":"https://github.com/hzsss/tags/生活/"}]},{"title":"206. 反转链表[easy]","slug":"206-反转链表-easy","date":"2019-05-05T11:11:30.000Z","updated":"2019-05-06T13:13:40.551Z","comments":true,"path":"206-反转链表-easy/","link":"","permalink":"https://github.com/hzsss/206-反转链表-easy/","excerpt":"","text":"LeetCode 算法题停止更新，请移步至 GitHub。 题目地址206. 反转链表 题目描述反转一个单链表。 解题方法1.双指针法 使用两个指针分别表示当前节点的前一个节点和后一个节点。 12345678910111213141516171819202122232425/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if (head == NULL) return NULL; ListNode *left = NULL; ListNode *right = NULL; while (head != NULL) &#123; right = head -&gt; next; // 后一个节点 head -&gt; next = left; // 反转当前节点的 next left = head; // 后移一个节点 head = right; // 后移一个节点 &#125; return left; &#125;&#125;; 之前在循环中使用的是这段代码，这段代码是有问题的 right -&gt; next = head 这一句，把后面的链给断掉了 12345right = head -&gt; next;right -&gt; next = head;head -&gt; next = left;left = head;head = right; 执行用时 : 16 ms, 在Reverse Linked List的C++提交中击败了96.91% 的用户 内存消耗 : 9.3 MB, 在Reverse Linked List的C++提交中击败了8.23% 的用户 时间复杂度：O(n) 空间复杂度：O(1)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://github.com/hzsss/tags/LeetCode/"}]},{"title":"141.环形链表[easy]","slug":"141-环形链表-easy","date":"2019-05-05T11:10:39.000Z","updated":"2019-05-06T13:13:57.626Z","comments":true,"path":"141-环形链表-easy/","link":"","permalink":"https://github.com/hzsss/141-环形链表-easy/","excerpt":"","text":"LeetCode 算法题停止更新，请移步至 GitHub。 题目地址141. 环形链表 题目描述给定一个链表，判断链表中是否有环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 解题方法1.哈希表 使用哈希表来存储节点，key 为当前节点，value 为当前节点的下一节点，存储形式为 [node : node -&gt; next] 访问当前节点时，先在字典中取出当前节点对应的 value，也就是取出当前节点的下一节点，如果下一节点在字典中的 key 存在，则说明当前节点的下一节点为链表中的某一个节点，即链表有环。如果下一节点在 key 中不存在，则说明链表没有环。 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool hasCycle(ListNode *head) &#123; if (head == NULL || head -&gt; next == NULL) &#123; return false; &#125; unordered_map&lt;ListNode *, ListNode *&gt; map; while (head) &#123; // map 中存储的是 [head : head -&gt; next] map[head] = head -&gt; next; // map[head] 取出的是 head -&gt; next；如果 head -&gt; next 存在字典的 key 中，则说明有环。 if (map.find(map[head]) != map.end()) return true; head = head -&gt; next; &#125; return false; &#125;&#125;; 执行用时 : 32 ms, 在Linked List Cycle的C++提交中击败了23.23% 的用户 内存消耗 : 12.5 MB, 在Linked List Cycle的C++提交中击败了5.02% 的用户 时间复杂度：O(n) 空间复杂度：O(n) 2.双指针法通过使用具有 不同速度 的快、慢两个指针遍历链表，空间复杂度可以被降低至 O(1)O(1)。慢指针每次移动一步，而快指针每次移动两步。 如果列表中不存在环，最终快指针将会最先到达尾部，此时我们可以返回 false。 现在考虑一个环形链表，把慢指针和快指针想象成两个在环形赛道上跑步的运动员（分别称之为慢跑者与快跑者）。而快跑者最终一定会追上慢跑者。这是为什么呢？考虑下面这种情况（记作情况 A） - 假如快跑者只落后慢跑者一步，在下一次迭代中，它们就会分别跑了一步或两步并相遇。 其他情况又会怎样呢？例如，我们没有考虑快跑者在慢跑者之后两步或三步的情况。但其实不难想到，因为在下一次或者下下次迭代后，又会变成上面提到的情况 A。 1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool hasCycle(ListNode *head) &#123; if (head == NULL || head -&gt; next == NULL) &#123; return false; &#125; ListNode *slow = head; ListNode *fast = head -&gt; next; while (slow != fast) &#123; if (fast == NULL || fast -&gt; next == NULL) &#123; return false; &#125; slow = slow -&gt; next; fast = fast -&gt; next -&gt; next; &#125; return true; &#125;&#125;; 执行用时 : 24 ms, 在Linked List Cycle的C++提交中击败了50.14% 的用户 内存消耗 : 9.7 MB, 在Linked List Cycle的C++提交中击败了55.64% 的用户 时间复杂度：O(n) 空间复杂度：O(1)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://github.com/hzsss/tags/LeetCode/"}]},{"title":"83.删除顺序链表中的重复元素[easy]","slug":"83-删除顺序链表中的重复元素-easy","date":"2019-05-05T11:08:13.000Z","updated":"2019-05-06T13:14:09.922Z","comments":true,"path":"83-删除顺序链表中的重复元素-easy/","link":"","permalink":"https://github.com/hzsss/83-删除顺序链表中的重复元素-easy/","excerpt":"","text":"LeetCode 算法题停止更新，请移步至 GitHub。 题目地址206.删除排序链表中的重复元素 题目描述给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 解题方法1.直接法把当前的节点值和下一个节点值作比较，如果相等，则直接删除下一个节点的值，这里注意，删除下一个节点后，不能直接移动当前指针到新的下一个节点，因为新的下一节点也有可能和当前节点值相等，而是要继续比较一次。注意边界条件，避免出现空指针错误。 123456789101112131415161718192021222324/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if (head == NULL || head -&gt; next == NULL) return head; ListNode *node = head; while (node &amp;&amp; node -&gt; next) &#123; if (node -&gt; val == node -&gt; next -&gt; val) &#123; node -&gt; next = node -&gt; next -&gt; next; &#125; else &#123; node = node -&gt; next; &#125; &#125; return head; &#125;&#125;; 执行用时 : 20 ms, 在Remove Duplicates from Sorted List的C++提交中击败了95.99% 的用户 内存消耗 : 9.5 MB, 在Remove Duplicates from Sorted List的C++提交中击败了5.13% 的用户 时间复杂度：O(n) 空间复杂度：O(1) 2.哈希表 使用一个哈希表来存储节点的值和节点，存储格式为 [node -&gt; value : node] 遍历当前节点时，先到哈希表中找到是否有一样的值，如果有，则需要删除当前节点。注意，这里的先决条件是有序链表，因此哈希表中可以存储前一个节点的值。 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if (head == NULL || head -&gt; next == NULL) return head; unordered_map&lt;int, ListNode *&gt; map; ListNode *node = head; while (node) &#123; if (map.find(node -&gt; val) != map.end()) &#123; ListNode *tmp = map[node -&gt; val]; tmp -&gt; next = tmp -&gt; next -&gt; next; &#125; else &#123; map[node -&gt; val] = node; &#125; node = node -&gt; next; &#125; return head; &#125;&#125;; 执行用时 : 24 ms, 在Remove Duplicates from Sorted List的C++提交中击败了49.58% 的用户 内存消耗 : 10.2 MB, 在Remove Duplicates from Sorted List的C++提交中击败了5.13% 的用户 时间复杂度：O(n) 空间复杂度：O(n)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://github.com/hzsss/tags/LeetCode/"}]},{"title":"排序算法","slug":"排序算法","date":"2019-04-29T06:10:36.000Z","updated":"2019-04-29T07:55:29.029Z","comments":true,"path":"排序算法/","link":"","permalink":"https://github.com/hzsss/排序算法/","excerpt":"","text":"冒泡排序 4 5 3 6 2 1 4 5 3 6 2 1 4 5 3 6 2 1 4 3 5 6 2 1 4 3 5 6 2 1 4 3 5 2 6 1 4 3 5 2 1 6 一次冒泡操作，可以将最大的数浮到最后面。 循环 array.size() 次，即可完成排序。 当某次冒泡操作已经没有数据交换时，说明已经达到了完全有序，不用再执行后续的冒泡排序了。 12345678910111213141516void bubbleSort(vecotr&lt;int&gt; &amp;a, int n) &#123; // n 为数组长度 if (n &lt;= 1) return; for (int i = 0; i &lt; n; i++) &#123; // 这是需要进行冒泡操作的次数 bool flag = false; // 用来记录是否有数据交换 for (int j = 0; i &lt; n - 1 - i; j++) &#123; // 这是一次冒泡操作，n - 1 - i 是这次冒泡排序中最大的数能够浮动到的位置的前一位 a[j] = a[j] ^ a[j + 1]; a[j+1] = a[j] ^ a[j + 1]; a[j] = a[j] ^ a[j + 1]; flag = true; &#125; if (!flag) break; &#125;&#125; 冒泡排序是原地排序算法吗？ 是，空间复杂度为 O(1) 冒泡排序是稳定的排序算法吗？ 是，当两个相邻的元素大小相等的时候，不会进行交换，元素的排列顺序不变。 冒泡排序的时间复杂度是多少？ 最好情况：[1, 2, 3, 4, 5, 6]，1次冒泡，时间复杂度：O(n) 最坏情况：[6, 5, 4, 3, 2, 1]，6次冒泡，时间复杂度：O(n^2) 平均时间复杂度：O(n^2) 插入排序 4 5 3 6 2 1 4 5 3 6 2 1 4 5 3 6 2 1 3 4 5 6 2 1 3 4 5 6 2 1 2 3 4 5 6 1 1 2 3 4 5 6 1234567891011121314151617void insertionSort(vector&lt;int&gt; &amp;a, int n) &#123; if (n &lt;= 1) return; for (int i = 1; i &lt; n; i++) &#123; int value = a[i]; int j = i - 1; for (; j &gt;=0; j--) &#123; if (a[j] &gt; value) &#123; a[i + 1] = a[j]; &#125; else &#123; break; &#125; &#125; a[j + 1] = value; &#125;&#125; 插入排序是原地排序算法吗？ 是，空间复杂度为 O(1) 插入排序是稳定的排序算法吗？ 是。 冒泡排序的时间复杂度是多少？ 最好情况：[1, 2, 3, 4, 5, 6]，1次冒泡，时间复杂度：O(n) 最坏情况：[6, 5, 4, 3, 2, 1]，6次冒泡，时间复杂度：O(n^2) 平均时间复杂度：O(n^2)","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"https://github.com/hzsss/tags/技术/"}]},{"title":"344.反转字符串[easy]","slug":"344-反转字符串-easy","date":"2019-04-29T03:42:34.000Z","updated":"2019-05-06T09:04:04.705Z","comments":true,"path":"344-反转字符串-easy/","link":"","permalink":"https://github.com/hzsss/344-反转字符串-easy/","excerpt":"","text":"LeetCode 算法题停止更新，请移步至 GitHub。 题目描述编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。 示例12输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;] 12输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;] 解题方法1.双指针 设置头尾两个指针。 一次交换头尾指针指向的元素值。 结束条件，当头指针等于或者大于尾指针时，跳出循环。 1234567891011class Solution &#123;public: void reverseString(vector&lt;char&gt;&amp; s) &#123; if (s.size() &lt; 2) return; for (int i = 0; i &lt; s.size() / 2; i++) &#123; char tmp = s[i]; s[i] = s[s.size() - i - 1]; s[s.size() - i - 1] = tmp; &#125; &#125;&#125;; 123456789101112class Solution &#123;public: void reverseString(vector&lt;char&gt;&amp; s) &#123; if (s.size() &lt; 2) return; int left = 0, right = s.size() - 1; while (left &lt; right) &#123; char tmp = s[left]; s[left++] = s[right]; s[right--] = tmp; &#125; &#125;&#125;; 状态 执行用时 内存消耗 通过 8 ms 8.9 MB 时间复杂度：O(n) 空间复杂度：O(1)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://github.com/hzsss/tags/LeetCode/"}]},{"title":"155.最小栈[easy]","slug":"155-最小栈-easy","date":"2019-04-29T02:44:08.000Z","updated":"2019-05-06T09:03:58.894Z","comments":true,"path":"155-最小栈-easy/","link":"","permalink":"https://github.com/hzsss/155-最小栈-easy/","excerpt":"","text":"LeetCode 算法题停止更新，请移步至 GitHub。 题目描述设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) – 将元素 x 推入栈中。 pop() – 删除栈顶的元素。 top() – 获取栈顶元素。 getMin() – 检索栈中的最小元素。 示例12345678MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; 返回 -3.minStack.pop();minStack.top(); --&gt; 返回 0.minStack.getMin(); --&gt; 返回 -2. 解题方法1.使用一个栈 push(x)：a.push(x) pop()：a.pop() top()：return a.top() getMin()：设置一个 i 用于记录最小值，循环把栈中的元素弹栈然后加入到数组中，然后再循环把数组末尾的元素压入栈中，恢复栈原来的顺序。 此方法在测试用例数据比较小的时候通过，在数据量大的时候超出了时间限制。此方法适用于数据量比较小的情况。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class MinStack &#123;public: /** initialize your data structure here. */ MinStack() &#123; &#125; void push(int x) &#123; a.push(x); &#125; void pop() &#123; a.pop(); &#125; int top() &#123; return a.top(); &#125; int getMin() &#123; int i = a.top(); while(a.size() &gt; 0) &#123; int c = a.top(); if (c &lt; i) i = c; a.pop(); b.push_back(c); &#125; while(b.size() &gt; 0) &#123; a.push(b.back()); b.pop_back(); &#125; return i; &#125; stack&lt;int&gt; a; vector&lt;int&gt; b;&#125;;/** * Your MinStack object will be instantiated and called as such: * MinStack* obj = new MinStack(); * obj-&gt;push(x); * obj-&gt;pop(); * int param_3 = obj-&gt;top(); * int param_4 = obj-&gt;getMin(); */ 2.使用两个栈栈 data 用来存储所有元素，栈 minStack 用来存储每次压栈时的最小值。 push(x)：data.push(x)，如果 minStack 为空，则说明是第一次压栈，需要将 x 也压入 minStack 中。如果 minStack 不为空，则将 x 与 minStack 栈顶元素比较，如果 x 较小也将 x 压入 minStack 中。这样，最小元素始终为 minStack 的栈顶元素。 pop()：如果 data.top() == minStack.top()，则说明最小元素将要弹栈，此时最小元素需要更新，于是将 minStack 的栈顶元素弹栈。 top()：return data.top() getMin()：return minStack.top() 12345678910111213141516171819202122232425262728293031class MinStack &#123;public: stack&lt;int&gt; data; stack&lt;int&gt; minStack; /** initialize your data structure here. */ MinStack() &#123; &#125; void push(int x) &#123; data.push(x); if(minStack.empty() || x &lt;= minStack.top())&#123; minStack.push(x); &#125; &#125; void pop() &#123; if(data.top() == minStack.top())&#123; minStack.pop(); &#125; data.pop(); &#125; int top() &#123; return data.top(); &#125; int getMin() &#123; return minStack.top(); &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://github.com/hzsss/tags/LeetCode/"}]},{"title":"225.用队列实现栈[easy]","slug":"225-用队列实现栈-easy","date":"2019-04-29T01:17:59.000Z","updated":"2019-05-06T09:03:54.352Z","comments":true,"path":"225-用队列实现栈-easy/","link":"","permalink":"https://github.com/hzsss/225-用队列实现栈-easy/","excerpt":"","text":"LeetCode 算法题停止更新，请移步至 GitHub。 题目描述使用队列实现栈的下列操作： push(x) – 元素 x 入栈 pop() – 移除栈顶元素 top() – 获取栈顶元素 empty() – 返回栈是否为空 说明你只能使用队列的基本操作– 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。 你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。 你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。 解题方法1.使用一个 queue push(x)：a.push(x) pop()：栈是先进后出，而队列是先进先出。用队列来实现栈的 pop() 方法，思路就是循环 size()-1 次，将队列前面的元素取出并重新 push 进队列的尾部。比如开始的队列是 1,2,3,4,5，当进行 pop() 的时候，队列会变成 2,3,4,5,1，然后再将 1 pop 出来。 top()：这里和上面的 pop() 思路是一样的，注意，这里是读取操作，不应该对队列原来的顺序进行改变。也就是说，读取到队列头部的元素后，应该再将头部的元素压入到尾部中，以恢复原来的顺序。 empty()：a.empty() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class MyStack &#123;public: /** Initialize your data structure here. */ MyStack() &#123; &#125; /** Push element x onto stack. */ void push(int x) &#123; a.push(x); &#125; /** Removes the element on top of the stack and returns that element. */ int pop() &#123; int count = a.size(); while (count-- &gt; 1) &#123; a.push(a.front()); a.pop(); &#125; int b = a.front(); a.pop(); return b; &#125; /** Get the top element. */ int top() &#123; int count = a.size(); while (count-- &gt; 1) &#123; a.push(a.front()); a.pop(); &#125; int b = a.front(); a.push(b); a.pop(); return b; &#125; /** Returns whether the stack is empty. */ bool empty() &#123; return a.empty(); &#125; private: queue&lt;int&gt; a;&#125;;/** * Your MyStack object will be instantiated and called as such: * MyStack* obj = new MyStack(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;top(); * bool param_4 = obj-&gt;empty(); */ 状态 执行用时 内存消耗 通过 8 ms 8.9 MB","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://github.com/hzsss/tags/LeetCode/"}]},{"title":"232.用栈实现队列[easy]","slug":"232-用栈实现队列-easy","date":"2019-04-28T07:42:10.000Z","updated":"2019-05-06T09:03:49.705Z","comments":true,"path":"232-用栈实现队列-easy/","link":"","permalink":"https://github.com/hzsss/232-用栈实现队列-easy/","excerpt":"","text":"LeetCode 算法题停止更新，请移步至 GitHub。 题目描述使用栈实现队列的下列操作： push(x) – 将一个元素放入队列的尾部。 pop() – 从队列首部移除元素。 peek() – 返回队列首部的元素。 empty() – 返回队列是否为空。 示例1234567MyQueue queue = new MyQueue();queue.push(1);queue.push(2); queue.peek(); // 返回 1queue.pop(); // 返回 1queue.empty(); // 返回 false 说明你只能使用标准的栈操作 – 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。 解题方法1.使用 stack 队列，先进先出；栈，先进后出；用栈实现队列，需要将栈中的元素顺序颠倒一下，由此可以想出使用两个栈来完成。 push：直接使用栈 a 的 push 方法即可。 pop：需要将栈 a 中的栈顶元素出栈，放入栈 b 中，即完成了一次倒序。（注意这种情况，当 pop 了一次之后，又进行一次 push 操作，再进行 pop 操作，如果是直接将 a 中的栈顶元素压如 b 中，会导致最后 pop 的是上次 push 进来的值，导致顺序错乱。所以只有当 b 为空时，才能将 a 栈顶元素压入 b 中，保证顺序不错乱） peek：返回队列第一个元素，也就是返回 b 中的栈顶元素。注意，这里只是返回栈顶元素，而不是弹出栈顶元素，不需要进行 pop，否则后面进行判空时会出现问题。 empty：一开始的思路是将栈 a 中的所有元素压入栈 b 中进行判断，但是这样会改变数据的位置，不仅增加了多余的操作，还可能会对后面的操作产生影响。后面直接判断两个栈是否都为空就好了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class MyQueue &#123;public: /** Initialize your data structure here. */ MyQueue() &#123; &#125; /** Push element x to the back of queue. */ void push(int x) &#123; a.push(x); &#125; /** Removes the element from in front of queue and returns that element. */ int pop() &#123; if (b.empty()) &#123; while (!a.empty()) &#123; int tmp = a.top(); a.pop(); b.push(tmp); &#125; &#125; int tmp = b.top(); b.pop(); return tmp; &#125; /** Get the front element. */ int peek() &#123; if (b.empty()) &#123; while (!a.empty()) &#123; int tmp = a.top(); a.pop(); b.push(tmp); &#125; &#125; int tmp = b.top(); return tmp; &#125; /** Returns whether the queue is empty. */ bool empty() &#123; return a.empty() &amp;&amp; b.empty(); &#125; private: stack&lt;int&gt; a; stack&lt;int&gt; b;&#125;;/** * Your MyQueue object will be instantiated and called as such: * MyQueue* obj = new MyQueue(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;peek(); * bool param_4 = obj-&gt;empty(); */ 状态 执行用时 内存消耗 通过 8 ms 8.9 MB 2.使用 deque这是范例代码，用双向队列来实现队列，个人觉得有些不符合题目要求，欠妥。 deque 也是顺序容器的一种，同时也是一个可变长数组。要使用 deque，需要包含头文件 deque。所有适用于 vector 的操作都适用于 deque。 deque 和 vector 有很多类似的地方。在 deque 中，随机存取任何元素都能在常数时间内完成（但慢于vector）。它相比于 vector 的优点是，vector 在头部删除或添加元素的速度很慢，在尾部添加元素的性能较好，而 deque 在头尾增删元素都具有较好的性能（大多数情况下都能在常数时间内完成）。它有两种 vector 没有的成员函数： 12void push_front (const T &amp; val); //将 val 插入容器的头部void pop_front(); //删除容器头部的元素 12345678910111213141516171819202122232425262728293031323334class MyQueue &#123;private: deque&lt;int&gt; di;public: /** Initialize your data structure here. */ MyQueue() &#123; &#125; /** Push element x to the back of queue. */ void push(int x) &#123; di.push_back(x); &#125; /** Removes the element from in front of queue and returns that element. */ int pop() &#123; int num = peek(); di.pop_front(); return num; &#125; /** Get the front element. */ int peek() &#123; return di.front(); &#125; /** Returns whether the queue is empty. */ bool empty() &#123; return di.empty(); &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://github.com/hzsss/tags/LeetCode/"}]},{"title":"用C++写算法题需要掌握的一些知识","slug":"用C-写算法题需要掌握的一些知识","date":"2019-04-28T06:48:08.000Z","updated":"2019-05-06T09:03:41.015Z","comments":true,"path":"用C-写算法题需要掌握的一些知识/","link":"","permalink":"https://github.com/hzsss/用C-写算法题需要掌握的一些知识/","excerpt":"","text":"vector向量，相当于一个能够动态扩容的数组。 方法begin() 返回指向容器中第一个元素的迭代器 end() 返回指向容器中最后一个元素后面的位置的迭代器 rbegin() 返回指向容器中最后一个元素的反向迭代器 rend() 返回指向容器中第一个元素前面的反向迭代器 erase(…) 传入一个下标值，删除该下标对应的元素值，后面的元素会自动往前移动。 clear() 从容器中删除所有元素。 size() 返回容器的长度 max_size() 返回容器最大长度 push_back(…) 在容器末尾插入数据 pop_back() 删除容器最后一个元素 empty() 返回一个 bool 值，判断容器是否为空 at(…) 传入下标值，返回该下标位置保存的元素值 front() 返回容器中第一个元素的引用。 back() 返回容器中最后一个元素的引用。 iterator insert(iterator i, const T &amp; val) 将 val 插入迭代器 i 指向的位置，返回 i 算法find() 将迭代器输入到序列中的初始位置和最终位置。的范围内搜索就是[first,last)，它包含所有的元件第一和最后一个，包括由指向的元件第一但不被指向的元素最后。 1234567891011int a[10] = &#123;10,20,30,40&#125;;vector&lt;int&gt; v;v.push_back(1); v.push_back(2);v.push_back(3); v.push_back(4); //此后v里放着4个元素：1,2,3,4vector&lt;int&gt;::iterator p;p = find(v.begin(),v.end(),3); //在v中查找3if(p != v.end()) //若找不到,find返回 v.end()cout &lt;&lt; \"1) \" &lt;&lt; * p &lt;&lt; endl; //找到了// v.end() 是最后一个元素的后一个位置，而 find 函数第一个参数是 左闭右开 区间,[first, last) 则 find(v.begin(), v.end(), 3) 则表示在第一个位置到最后一个位置（包含最后一个元素）查找元素3。 sort() 该算法可以用来对区间 [first, last) 从小到大进行排序。下面两行程序就能对数组 a 排序：12int a[4] = &#123;3, 4, 2, 1&#125;;sort(a, a+4); iterator通过迭代器可以读取它指向的元素，*迭代器名就表示迭代器指向的元素。通过非常量迭代器还能修改其指向的元素。 迭代器都可以进行++操作。反向迭代器和正向迭代器的区别在于： 对正向迭代器进行++操作时，迭代器会指向容器中的后一个元素；而对反向迭代器进行++操作时，迭代器会指向容器中的前一个元素。 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; v; //v是存放int类型变量的可变长数组，开始时没有元素 for (int n = 0; n&lt;5; ++n) v.push_back(n); //push_back成员函数在vector容器尾部添加一个元素 vector&lt;int&gt;::iterator i; //定义正向迭代器 for (i = v.begin(); i != v.end(); ++i) &#123; //用迭代器遍历容器 cout &lt;&lt; *i &lt;&lt; \" \"; //*i 就是迭代器i指向的元素 *i *= 2; //每个元素变为原来的2倍 &#125; cout &lt;&lt; endl; //用反向迭代器遍历容器 for (vector&lt;int&gt;::reverse_iterator j = v.rbegin(); j != v.rend(); ++j) cout &lt;&lt; *j &lt;&lt; \" \"; return 0;&#125; 写++i、++j相比于写i++、j++，程序的执行速度更快。回顾++被重载成前置和后置运算符的例子如下:1234567891011CDemo CDemo::operator++ ()&#123; //前置++ ++n; return *this;&#125;CDemo CDemo::operator ++(int k)&#123; //后置++ CDemo tmp(*this); //记录修改前的对象 n++; return tmp; //返回修改前的对象&#125; stackvoid pop(); 弹出（即删除）栈顶元素 T &amp; top(); 返回栈顶元素的引用。通过此函数可以读取栈顶元素的值，也可以修改栈顶元素 void push (const T &amp; x); 将 x 压入栈顶 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;stack&gt; //使用stack需要包含此头文件using namespace std;int main()&#123; int n, k; stack &lt;int&gt; stk; cin &gt;&gt; n &gt;&gt; k; //将n转换为k进制数 if (n == 0) &#123; cout &lt;&lt; 0; return 0; &#125; while (n) &#123; stk.push(n%k); n /= k; &#125; while (!stk.empty()) &#123; cout &lt;&lt; stk.top(); stk.pop(); &#125; return 0;&#125; queue（队列）FIFO 队列，先进先出 empty size front back push_back pop_front push 插入数据 pop 弹出数据 unordered_map和 NSDictionary 类似 unordered_map&lt;int, int&gt; map; map[i] = 1; stringstring 123string s1;s1 = \"Hello\"; // s1 = \"Hello\"s2 = 'K'; // s2 = \"K” length 成员函数返回字符串的长度。size 成员函数可以实现同样的功能。 除了可以使用+和+=运算符对 string 对象执行字符串的连接操作外，string 类还有 append 成员函数，可以用来向字符串后面添加内容。append 成员函数返回对象自身的引用。例如： 12345string s1(\"123\"), s2(\"abc\");s1.append(s2); // s1 = \"123abc\"s1.append(s2, 1, 2); // s1 = \"123abcbc\"s1.append(3, 'K'); // s1 = \"123abcbcKKK\"s1.append(\"ABCDE\", 2, 3); // s1 = \"123abcbcKKKCDE\"，添加 \"ABCDE\" 的子串(2, 3) string对象的比较 除了可以用 &lt;、&lt;=、==、!=、&gt;=、&gt; 运算符比较 string 对象外，string 类还有 compare 成员函数，可用于比较字符串。compare 成员函数有以下返回值： 小于 0 表示当前的字符串小； 等于 0 表示两个字符串相等； 大于 0 表示另一个字符串小。 1234567string s1(\"hello\"), s2(\"hello, world\");int n = s1.compare(s2);n = s1.compare(1, 2, s2, 0, 3); //比较s1的子串 (1,2) 和s2的子串 (0,3)n = s1.compare(0, 2, s2); // 比较s1的子串 (0,2) 和 s2n = s1.compare(\"Hello\");n = s1.compare(1, 2, \"Hello\"); //比较 s1 的子串(1,2)和\"Hello”n = s1.compare(1, 2, \"Hello\", 1, 2); //比较 s1 的子串(1,2)和 \"Hello\" 的子串(1,2)","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"https://github.com/hzsss/tags/技术/"}]},{"title":"35.搜索插入位置[easy]","slug":"35-搜索插入位置-easy","date":"2019-04-28T02:52:07.000Z","updated":"2019-05-06T09:03:30.925Z","comments":true,"path":"35-搜索插入位置-easy/","link":"","permalink":"https://github.com/hzsss/35-搜索插入位置-easy/","excerpt":"","text":"LeetCode 算法题停止更新，请移步至 GitHub。 题目描述给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例12输入: [1,3,5,6], 5输出: 2 12输入: [1,3,5,6], 2输出: 1 12输入: [1,3,5,6], 7输出: 4 12输入: [1,3,5,6], 0输出: 0 解题方法1. target 在数组中存在的情况，for 循环对比元素相等返回下标即可。 target 不存在需要插入数组中的情况，由于数组是有序的，插入到第一个大于 target 的元素中即可。 target 不存在并且需要插入到数组尾部的情况，直接返回数组末尾+1的下标（数组原来的长度）即可。 1234567891011121314151617class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int n = nums.size(); if (n == 0) return 0; for (int i = 0; i &lt; n; i++) &#123; if (nums[i] == target) &#123; return i; // 有相等的值 &#125; else if (nums[i] &gt; target) &#123; return i; // 无相等的值并且 i &lt; n &#125; &#125; return n; // target 插入到数组末尾的情况 &#125;&#125;; 状态 执行用时 内存消耗 通过 16 ms 8.8 MB 时间复杂度：O(n) 空间复杂度：O(1)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://github.com/hzsss/tags/LeetCode/"}]},{"title":"27.移除元素[easy]","slug":"27-移除元素-easy","date":"2019-04-28T02:02:23.000Z","updated":"2019-05-06T09:03:23.344Z","comments":true,"path":"27-移除元素-easy/","link":"","permalink":"https://github.com/hzsss/27-移除元素-easy/","excerpt":"","text":"LeetCode 算法题停止更新，请移步至 GitHub。 题目描述给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例12345给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。 1234567给定 nums = [0,1,2,2,3,0,4,2], val = 2,函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 说明为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: 12345678// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len = removeElement(nums, val);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 解题方法1. 使用一遍 for 循环，遇到 nums[i] == val 时，使用 erase 函数删除该值。 此时元素后面的元素将一次往前移，所有的坐标都 -1，此时需要从 i 原来的位置继续循环，所以删除之后需要 i - 1，保证下一次循环还是从当前位置开始。 12345678910111213class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; if (nums.size() == 0) return 0; for (int i = 0; i &lt; nums.size(); i++) &#123; if (nums[i] == val) &#123; nums.erase(nums.begin() + i); i--; &#125; &#125; return nums.size(); &#125;&#125;; 状态 执行用时 内存消耗 通过 8 ms 8.7 MB 时间复杂度：O(n) 空间复杂度：O(1) 2.双指针法（替换元素值） 设置 i 为慢指针，j 为快指针，当 nums[j] != val 时，则说明 nums[j] 是需要保存的值，于是将该值赋值给 i 所在的位置进行保存。 在 [2, 2, 2, 2] val = 2，和 [2, 2, 2, 2] val = 3 时，这两种极端情况也需要包含到。 123456789101112131415class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; if (nums.size() == 0) return 0; int i = 0; for (int j = i; j &lt; nums.size(); j++) &#123; if (nums[j] != val) &#123; nums[i] = nums[j]; i++; &#125; &#125; return i; &#125;&#125;; 状态 执行用时 内存消耗 通过 12 ms 8.6 MB 时间复杂度：O(n) 空间复杂度：O(1) 3.双指针法（删除元素值）这是官方题解，和解法一思路类似。 现在考虑数组包含很少的要删除的元素的情况。例如，num=[1，2，3，5，4]，Val=4num=[1，2，3，5，4]，Val=4。之前的算法会对前四个元素做不必要的复制操作。另一个例子是 num=[4，1，2，3，5]，Val=4num=[4，1，2，3，5]，Val=4。似乎没有必要将 [1，2，3，5][1，2，3，5] 这几个元素左移一步，因为问题描述中提到元素的顺序可以更改。 当我们遇到 nums[i] = valnums[i]=val 时，我们可以将当前元素与最后一个元素进行交换，并释放最后一个元素。这实际上使数组的大小减少了 1。 请注意，被交换的最后一个元素可能是您想要移除的值。但是不要担心，在下一次迭代中，我们仍然会检查这个元素。 1234567891011121314151617181920class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; if (nums.size() == 0) return 0; int i = 0; int n = nums.size(); while (i &lt; n) &#123; if (nums[i] == val) &#123; nums[i] = nums[n - 1]; n--; // 这种情况下，i 并没有加 1，在下次迭代中还会检查当前位置的值是否等于 val &#125; else &#123; i++; &#125; &#125; return n; &#125;&#125;; 状态 执行用时 内存消耗 通过 8 ms 8.5 MB 时间复杂度：O(n) 空间复杂度：O(1)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://github.com/hzsss/tags/LeetCode/"}]},{"title":"509.斐波那契数列[easy]","slug":"509-斐波那契数列-easy","date":"2019-04-27T14:43:03.000Z","updated":"2019-05-06T09:03:16.920Z","comments":true,"path":"509-斐波那契数列-easy/","link":"","permalink":"https://github.com/hzsss/509-斐波那契数列-easy/","excerpt":"","text":"LeetCode 算法题停止更新，请移步至 GitHub。 题目描述斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： 12F(0) = 0, F(1) = 1F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1. 给定 N，计算 F(N)。 示例123输入：2输出：1解释：F(2) = F(1) + F(0) = 1 + 0 = 1. 123输入：3输出：2解释：F(3) = F(2) + F(1) = 1 + 1 = 2. 123输入：4输出：3解释：F(4) = F(3) + F(2) = 2 + 1 = 3. 解题方法1.递归法 第 N 项等于第 N - 1 项与 N - 2 项之和，由此很容易得出可以使用递归来解决。 找出边界条件，F(1) = 1，F(0) = 0; 123456789class Solution &#123;public: int fib(int N) &#123; if (N == 1) return 1; if (N == 0) return 0; return fib(N - 1) + fib(N - 2); &#125;&#125;; 状态 执行用时 内存消耗 通过 28 ms 8.3 MB 空间复杂度：O(n) 2.递归会出现重复计算的问题，这里可以利用前面计算的结果，提高计算效率。 1234567891011class Solution &#123;public: int fib(int N) &#123; int a = 0, b = 1; while (N-- &gt; 0) &#123; b += a; a = b - a; &#125; return a; &#125;&#125;; 状态 执行用时 内存消耗 通过 8 ms 8.2 MB 时间复杂度：O(n) 空间复杂度：O(1)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://github.com/hzsss/tags/LeetCode/"}]},{"title":"26.删除排序数组中的重复项[easy]","slug":"26-删除排序数组中的重复项-easy","date":"2019-04-27T07:37:06.000Z","updated":"2019-05-06T09:03:08.463Z","comments":true,"path":"26-删除排序数组中的重复项-easy/","link":"","permalink":"https://github.com/hzsss/26-删除排序数组中的重复项-easy/","excerpt":"","text":"LeetCode 算法题停止更新，请移步至 GitHub。 题目描述给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例12345给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 12345给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 说明：为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: 12345678// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 解题方法1.哈希表这个方法不符合原地修改数组的要求 将数组中的值和下标存入哈希表。 如果哈希表中存在与相同的值，则删除当前位置的值，并前移。 前移之后，当前位置的值为原来下一个位置的值，为了下一次循环从当前位置开始，需要进行 i - 1。 返回删除重复值之后的数组长度。由于函数的参数为引用值，在函数中删除数组中的值，可以直接影响外部调用者的值。 1234567891011121314class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; unordered_map&lt;int, int&gt; myMap; for (int i=0; i&lt;nums.size(); ++i) &#123; if (myMap.find(nums[i]) != myMap.end()) &#123; nums.erase(nums.begin()+i); i = i - 1; // 这里数组的长度变化了，当前位置的值变成了下一个位置的值，下次循环还是应该从这个位置开始，为了防止 ++i，所以这里先 -1 &#125; myMap[nums[i]] = i; &#125; return nums.size(); &#125;&#125;; 状态 执行用时 消耗内存 通过 280 ms 11.7 MB 时间复杂度：O(n) 空间复杂度：O(n) 2.双指针 设置两个指针，i 为慢指针，j 为快指针。 nums[i] == nums[j] 时，则 j 继续往后走，直到找到 nums[i] != nums[j]。 当 nums[i] != nums[j] 时，则说明 j 之前的元素都是相等的，于是将 j 指向元素的值赋给 i 的下一个位置。直到 j 到达数组末尾。 此时 i 指向的是不重复元素的最后一个下标，返回其长度：i + 1。 123456789101112131415class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 0) return 0; int i = 0; for (int j = i; j &lt; nums.size(); j++) &#123; if (nums[j] != nums[i]) &#123; i++; nums[i] = nums[j]; &#125; &#125; return i + 1; &#125;&#125;; 状态 执行用时 消耗内存 通过 32 ms 10 MB 时间复杂度：O(n) 空间复杂度：O(1)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://github.com/hzsss/tags/LeetCode/"}]},{"title":"1.两数之和[easy]","slug":"1-两数之和","date":"2019-04-27T07:09:13.000Z","updated":"2019-05-06T09:03:00.984Z","comments":true,"path":"1-两数之和/","link":"","permalink":"https://github.com/hzsss/1-两数之和/","excerpt":"","text":"LeetCode 算法题停止更新，请移步至 GitHub。 题目描述给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 解题方法1.暴力法两次遍历，查找 nums[i] + nums[j] == target 的值并放入数组返回。 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; for (int i=0; i&lt;nums.size(); i++) &#123; for (int j=i+1; j&lt;nums.size(); j++) &#123; if (nums[i] + nums[j] == target) &#123; vector&lt;int&gt;a; a.push_back(i); a.push_back(j); return a; &#125; &#125; &#125; throw \"error\"; &#125;&#125;; 状态 执行用时 内存消耗 通过 224 ms 9.3 MB 时间复杂度：O(n^2) 空间复杂度：O(1) 2.哈希表使用一遍循环，在循环的过程中，把数组中的符合条件的 complement 与哈希表中的 Key 相比较，如果存在，则取出哈希表中对应的 Value 和当前的下标放入 vector 中。 然后把数组中的值作为 Key，下标作为 Value 存入哈希表中。 1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, int&gt; map; vector&lt;int&gt; a; for (int i = 0; i &lt; nums.size(); ++i) &#123; int complement = target - nums[i]; if (map.find(complement) != map.end()) &#123; a.push_back(map[complement]); a.push_back(i); return a; &#125; map[nums[i]] = i; &#125; return a; &#125;&#125;; 状态 执行用时 内存消耗 通过 16 ms 10.1 MB 时间复杂度：O(n) 空间复杂度：O(n)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://github.com/hzsss/tags/LeetCode/"}]},{"title":"给博客添加一只萌萌的血小板","slug":"给博客添加一只萌萌的血小板","date":"2019-04-20T10:03:50.000Z","updated":"2019-04-27T08:51:08.935Z","comments":true,"path":"给博客添加一只萌萌的血小板/","link":"","permalink":"https://github.com/hzsss/给博客添加一只萌萌的血小板/","excerpt":"","text":"在搭建博客之初就有了解过 live2d，也跟着教程尝试给博客添加过 live2d 看板娘，但是使用的是预设的那几个模板，总觉得吧太大众化了，我能用别人也能用，那还不如不用，于是就把之前的看板娘给撤了。 我一般浏览博客的时候，都喜欢点他们的友链，然后看看其他大佬的博客。今天点了一个前端大佬的博客（猫与向日葵），emmm…日系卖萌可爱风格，大佬都喜欢这样的么。 打开主页，虽然这种风格不属于我的菜，因为我一般还是比较正经滴，嘿嘿。正要关掉网页，wait，右下角是啥…一只超级萌的血小板！ 糟了，是心动的感觉！太可爱了，比那些大众化的模板好看多了，博主使用的是 Typecho 搭建的博客，所以基于 Hexo 搭建的博客上不会有太多人用这个模型。于是乎，我下定决心要把这只血小板抠出来放到我的博客上。 下载模型文件博主在他的博客上已经有了相关的教程 – 给博客添加能动的看板娘(Live2D)，但不是基于 Hexo 平台的，要想把模型放到我的博客，对于我这种前端小白来说还是需要折腾一下的。 感谢博主给出了下载模型的链接，首先点击链接，下载血小板的模型文件。 解压后，可以看到它的文件结构是这样婶的：其中 model.json 包含了模型的一些基本信息，model.moc 包含了图层、参数、坐标系和组件等信息，texture_00.png 是血小板的图像文件，motions 文件夹中的 .mtn 是模型一些动作文件。 目前还不能确定这个模型的通用性，于是我按照之前在 Hexo 博客添加看板娘的教程安装了一个适用于 Hexo 博客的看板娘，是这样婶的： 这个好像叫 shizuku，其实也还好啦，但是已经被滥用了，看到好多博客都用了这个，当然还有一些其他的模型可以参考这篇博客，给出了一些常见的模型预览图。不嫌大众化或者不想折腾的同学可以在那里挑一个自己喜欢的模型装到自己的博客上。 修改模型文件安装完 shizuku 后，打开我本地的 Hexo 博客文件，打开博客根目录 -&gt; node_modules -&gt; live2d-widget-model-shizuku，这个就是刚才下载的适用于 Hexo 博客的 shizuku 模型了，来分析一下它的文件结构：除了本身的文件层级有些区别之外，还多了一个 package.json，暂且不知道这是干嘛的，从文件名推测应该是一个文件包描述文件。多了个 shizuku.physics.json，推测应该是模型的物理信息。其他的文件基本上和血小板模型是一致的，嘿嘿，有戏。可以看出这里的 assets 文件夹就是模型文件了。 我的思路是使用安装 shizuku 的方式，去安装血小板模型，首先能想到的就是先把血小板的文件结构梳理成和 shizuku 的一样。梳理之后的结构如下： 安装模型在 Hexo 博客添加看板娘的教程中，除了可以使用预设的几个模型之外，还给了两种方式去加载自定义的模型，一种是保存到本地，使用本地的模型。另一种是将模型发布到 npm，然后再和使用预设模型一样来安装模型。 加载本地模型，可能和使用 npm 安装模型有一些区别，我尝试后是失败的。于是我决定尝试第二种方法。 新建一个目录, 用你的 Node 环境执行 npm init, 推荐使用 live2d-widget-model-xxx 的包名。 在刚刚创建的目录下创建 assets 子目录, 把模型放进去。 使用 npm publish 来发布。 然后使用 npm install –save live2d-widget-model-xxx 来安装。 通过向 model.use 键入包名 (live2d-widget-model-xxx) 来使用。 执行完 npm init 命令后，需要填写一些关于模型的一些信息，然后文件夹中出现了 package.json 文件，可以看到文件中包含了我们刚才填写的信息： 1234567891011121314&#123; &quot;name&quot;: &quot;live2d-widget-model-platelet&quot;, &quot;version&quot;: &quot;1.1.0&quot;, &quot;description&quot;: &quot;live2d-widget-model-platelet&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;keywords&quot;: [ &quot;live2d-widget-model-platelet&quot; ], &quot;author&quot;: &quot;huangzishan&quot;, &quot;license&quot;: &quot;ISC&quot;&#125; package.json 文件里记录了项目的描述信息，比如项目作者、项目描述、项目依赖哪些包、插件配置信息等等。至此我们的血小板模型已经可以确定是通用的了。 然后我就兴致冲冲地输入 hexo clean 清除缓存，hexo g 生成静态页面，然后 hexo d 发布到仓库中，然后清除浏览器的缓存，输入我的博客网址，所有动作一气呵成。然而结果却是，嗯？我的血小板呢??? 可谓是一顿操作猛如虎，定睛一看原地杵。我哭了，你呢？ 调整细节作为卷福和柯南的粉丝，我怎么可能就此放弃，于是我回想所有可能漏掉的细节，等等，有一个 json 文件被我漏了，没错，就是 platelet.model.json 文件。看一下它里面是什么内容： 12345678910111213141516171819202122&#123; &quot;type&quot;: &quot;Live2D Model Setting&quot;, &quot;name&quot;: &quot;model&quot;, &quot;model&quot;: &quot;model.moc&quot;, &quot;textures&quot;: [ &quot;model.2048/texture_00.png&quot; ], &quot;motions&quot;:&#123; &quot;idle&quot;:[ &#123;&quot;file&quot;:&quot;motions/Idle.mtn&quot;&#125; ], &quot;sleepy&quot;:[ &#123;&quot;file&quot;:&quot;motions/Nemui.mtn&quot;&#125; ], &quot;flick_head&quot;:[ &#123;&quot;file&quot;:&quot;motions/Anone_Synced.mtn&quot;&#125; ], &quot;tap_body&quot;:[ &#123;&quot;file&quot;:&quot;motions/Dance.mtn&quot;&#125; ] &#125;&#125; 可以看到，这里是模型的描述文件，包括模型的模块名称和一些动作组件的相对路径等，但里面的信息还是梳理之前的。哼，我冷笑一声，熟悉的BGM响起，此刻我自己眼中的我是这样的： 然鹅现实中的我却是这样的： 卷福说过，当你排除了所有不可能性，剩下的无论多不可能，都是真相。 嘿嘿，真相只有一个，于是我把 platelet.model.json 文件的内容修改了一下： 12345678910111213141516171819202122&#123; &quot;type&quot;: &quot;Live2D Model Setting&quot;, &quot;name&quot;: &quot;live2d-widget-model-platelet&quot;, &quot;model&quot;: &quot;moc/platelet.moc&quot;, &quot;textures&quot;: [ &quot;moc/platelet.2048/texture_00.png&quot; ], &quot;motions&quot;:&#123; &quot;idle&quot;:[ &#123;&quot;file&quot;:&quot;mtn/Idle.mtn&quot;&#125; ], &quot;sleepy&quot;:[ &#123;&quot;file&quot;:&quot;mtn/Nemui.mtn&quot;&#125; ], &quot;flick_head&quot;:[ &#123;&quot;file&quot;:&quot;mtn/Anone_Synced.mtn&quot;&#125; ], &quot;tap_body&quot;:[ &#123;&quot;file&quot;:&quot;mtn/Dance.mtn&quot;&#125; ] &#125;&#125; emmm…这就对了嘛，于是我又一顿操作猛如虎，清空浏览器缓存，再次输入我的博客地址。接下来就是见证奇迹的时刻！ 当当当当！ 右下角看到了吗？萌萌的血小板，我又哭了！ 多说一句，真羡慕那些会画画的人啊，羡慕，真的羡慕！ 折腾了一晚上，终于弄好了。不说了，学口语去了，为了我的200块钱啊！","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"https://github.com/hzsss/tags/技术/"}]},{"title":"Final Cut Pro 入门教程","slug":"Final-Cut-Pro-入门教程","date":"2019-04-06T07:04:50.000Z","updated":"2019-04-06T07:12:08.403Z","comments":true,"path":"Final-Cut-Pro-入门教程/","link":"","permalink":"https://github.com/hzsss/Final-Cut-Pro-入门教程/","excerpt":"","text":"Final Cut Pro 是苹果推出的一款在 Mac OS 上的剪辑软件，Apple Store 售价 ￥1998。话不多说，接下来我就和大家讲解一下如何使用 Final Cut Pro 进行剪辑。 界面首先，Final Cut Pro 的界面是长这样的🔽： 各个工作区界限分明，下面介绍一下各个工作区的作用： 资源区可以在资源区浏览、管理和导入各种素材。 添加各种音效。 以及添加字幕和转场动画。 检视区检视区可以预览和播放资源区或者时间线上的各种素材。还可以对视频进行裁剪、变换等。对视频进行调色。调整视频播放速度。 检查器这里可以查看素材的一些基本信息，调整素材的一些参数和属性。 比如防抖动、调色以及降噪等。 时间线在时间线上可以对视频进行剪辑。 效果区在效果区中可以对画面添加各种效果。 使用 Final Cut Pro 进行剪辑Step 1：新建项目在资源区点击右键，新建一个项目。 根据需要更改视频参数。 在事件中点击右键，导入媒体。在弹出的界面中选择需要导入的资源媒体。注意右边的这个视频选项，有拷贝到资源库，和让文件留在原位。这里建议选择到资源库，这样会拷贝一份视频，编辑后对原视频没有影响。而让文件留在原位，就相当于是一个引用，编辑后会直接修改原视频。 也可以直接在访达中直接拖入素材到资源库。 Step 2：剪辑视频先把资源库中的视频拖到时间线上，这样就创立了一个时间线。 使用切割工具对视频进行切割。 然后用选择工具对切割好的素材进行处理，比如删除片段，调整视频顺序等。 有些片段可能需要进行处理，比如让视频静音等，这里就可以进行音频分离。也可以加入音频，在资源区选择对应的音频素材，拖入到时间线即可。 有些片段需要加入一定的特效，Final Cut Pro 已经有预置好的特效，可以满足我们大多数的需要。选择对应的片段，然后直接将特效拖上去，就可以为视频加入特效了。 至此呢，视频的大致逻辑就已经捋好了，现在需要对视频的一些细节进行处理。 Step 3：细节调整我们利用检视器和检查器，可以对视频进行相应的处理。比如剪裁、变换视频画面，对画面进行调色，以及对音频进行处理等。属性和参数很多，这里就不详说了，可以根据实际需要进行相应的设置。 我一般会做的就是对画面进行调整，防抖动和降噪用的比较多。 Step 4：加入字幕和转场动画在资源区，可以选择对应的转场动画，转场动画本质上也是视频素材，直接拖到时间线上，然后再检查器中对其进行调整和设置即可。 选择字幕样式，Final Cut Pro 也给我们提供了很多字幕样式。选择需要的样式，拖到对应的时间线上，调整长度，然后对其进行编辑即可，这是一个很繁琐的工作。不知道有没有语音识别、自动加字幕的功能。我这里是一句一句打上去的，十分钟的视频花了大概五六个小时加字幕。 总结总体上来说呢，用 Final Cut Pro 进行一些基本的视频剪辑还是很方便的，本篇文章主要介绍了一下 Final Cut Pro 的功能和简单使用。想要学习视频剪辑的同学，还是需要多练，多折腾。踩的坑多了，自然也就熟练了。","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"https://github.com/hzsss/tags/技术/"}]},{"title":"iOS 12.3 beta 版体验测试","slug":"iOS-12-3-beta-版体验测试","date":"2019-04-03T01:02:17.000Z","updated":"2019-04-27T08:51:20.129Z","comments":true,"path":"iOS-12-3-beta-版体验测试/","link":"","permalink":"https://github.com/hzsss/iOS-12-3-beta-版体验测试/","excerpt":"","text":"测试机型 iPhone 8，联通卡12.3 beta 版下载方法在 iPhone 中用 Safari 下载 iOS 12.3 beta 描述文件 设置 -&gt; 安装证书 -&gt; 重启手机 设置 -&gt; 通用 -&gt; 软件升级 钱包新增近期交易记录12.2 12.3 beta 网速同一地点，相同时段测试 12.2 12.3 beta 受时段的影响，可能会有些差距，但实际体验没有出现网络变得特别好或者特别差的情况，和 12.2 没有明显差别。 跑分12.2 12.3 beta Cosmos 帧率12.2 12.3 beta 均保持在 60fps 左右，实际体验两个版本都没有明显掉帧的情况发生。 耗电量外放音量均为3格 30分钟王者荣耀 30分钟绝地求生 30分钟视频播放 12.2 12.3 beta 在这次续航测试中，12.3 beta 版略有提升，但不排除受游戏环境的影响，仅供参考。 发热玩游戏均有发热，二者都没有出现异常高温的情况。 游戏12.2 12.3 beta 最高画质，没有明显卡顿或掉帧，帧率基本保持在 60fps。 总结这次 12.3 beta 版在测试中和 12.2 没有较大的差别，系统有一定的优化，本次测试使用的是 iPhone 8，实际情况根据机型不同会有所区别。仅供参考，还请各位以实际情况考虑是否升级。","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"https://github.com/hzsss/tags/技术/"}]},{"title":"制作 iOS framework 静态库的一些总结","slug":"制作-iOS-framework-静态库的一些总结","date":"2019-03-26T05:47:05.000Z","updated":"2019-03-26T10:03:02.060Z","comments":true,"path":"制作-iOS-framework-静态库的一些总结/","link":"","permalink":"https://github.com/hzsss/制作-iOS-framework-静态库的一些总结/","excerpt":"","text":"制作步骤这部分资料很多，这里就不再赘述。 参考资料： Xcode10制作 framework详细步骤及坑说明 iOS 制作 framework iOS静态库 【.a 和framework】【超详细】 要点 如果需要调用 framework 中的分类（category）方法，需要在使用静态库的工程中配置 other linker flags 为 -Objc 默认 framework 是动态库，制作静态库需要设置 Mach-O Type 为 Static Library 想要在 framework 进行断点调试，可以在 framework 工程中创建一个新的 Target -&gt; Single View 需要选择正确的指令集，真机 arm64，模拟器 x86_64 每一个需要暴露的 class 都需要在 Target Membership 中设置为 Public 工程中要使用 framework 中的资源，需要在工程中的 Build Phases -&gt; Copy Bundle Resources 中添加 framework 12345678910111213- (UIImage *)downloadImage &#123; NSBundle *bundle = [NSBundle bundleWithPath:[[NSBundle mainBundle] pathForResource:@\"DownloadAndPrint\" ofType:@\"framework\"]]; NSString* imagesPath = [bundle.resourcePath stringByAppendingPathComponent:@\"images\"]; NSLog(@\"imagesPath:\\%@\", imagesPath); NSBundle* imageBundle = [NSBundle bundleWithPath:imagesPath]; return [UIImage imageNamed:@\"test\" inBundle:imageBundle compatibleWithTraitCollection:nil]; &#125; iOS framework 合并和拆分多种架构参考资料： iOS静态库支持架构查看、分离、合并 合并生成模拟器和真机通用的framework 合并： Target -&gt; Build Settings -&gt; Build Active Architecture Only（是否只编译当前架构） -&gt; Debug 改为 NO（改为 NO，模拟器可以直接合成两种架构）1➜ ~ lipo -create /Users/acan/Library/Developer/Xcode/DerivedData/AFNTestFrameworking-dbzgzczpzorkzxakdyptgdkckcee/Build/Products/Debug-iphonesimulator/AFNTestFrameworking.framework/AFNTestFrameworking /Users/acan/Library/Developer/Xcode/DerivedData/AFNTestFrameworking-dbzgzczpzorkzxakdyptgdkckcee/Build/Products/Debug-iphoneos/AFNTestFrameworking.framework/AFNTestFrameworking -output /Users/acan/Library/Developer/Xcode/DerivedData/AFNTestFrameworking-dbzgzczpzorkzxakdyptgdkckcee/Build/Products/Debug-iphonesimulator/AFNTestFrameworking.framework/AFNAllFramework 查看：123➜ ~ lipo -info /Users/acan/Library/Developer/Xcode/DerivedData/AFNTestFrameworking-dbzgzczpzorkzxakdyptgdkckcee/Build/Products/Debug-iphonesimulator/AFNTestFrameworking.framework/AFNAllFramework Architectures in the fat file: /Users/acan/Library/Developer/Xcode/DerivedData/AFNTestFrameworking-dbzgzczpzorkzxakdyptgdkckcee/Build/Products/Debug-iphonesimulator/AFNTestFrameworking.framework/AFNAllFramework are: i386 armv7 x86_64 arm64 拆分：1➜ ~ lipo /Users/acan/Library/Developer/Xcode/DerivedData/AFNTestFrameworking-dbzgzczpzorkzxakdyptgdkckcee/Build/Products/Debug-iphonesimulator/AFNTestFrameworking.framework/AFNTestFrameworking -thin x86_64 -output /Users/acan/Library/Developer/Xcode/DerivedData/AFNTestFrameworking-dbzgzczpzorkzxakdyptgdkckcee/Build/Products/Debug-iphonesimulator/AFNTestFrameworking.framework/AFNSingleFrameworking 查看1Non-fat file: /Users/acan/Library/Developer/Xcode/DerivedData/AFNTestFrameworking-dbzgzczpzorkzxakdyptgdkckcee/Build/Products/Debug-iphonesimulator/AFNTestFrameworking.framework/AFNSingleFrameworking is architecture: x86_64 查看 framework 中包含的文件使用 ar -t 命令，如：1234567➜ ~ ar -t /Users/acan/Library/Developer/Xcode/DerivedData/AFNTestFrameworking-dbzgzczpzorkzxakdyptgdkckcee/Build/Products/Debug-iphoneos/AFNTestFrameworking.framework/AFNTestFrameworking __.SYMDEF SORTED AFNTestManager.o AFNTestFrameworking_vers.o 12345678910111213141516171819202122232425262728293031323334353637383940414243~ ar -t /Users/acan/Library/Developer/Xcode/DerivedData/DownloadAndPrint-esbkggakvotbghavvyrahlbwezwq/Build/Products/Debug-iphonesimulator/DownloadAndPrint.framework/DownloadAndPrint __.SYMDEF KUIProgressView+AFNetworking-a1a40cc17fc24f3f1ceddd74a693da30783bb34d0b01752ff79431573398a33e.o KUIRefreshControl+AFNetworking-a1a40cc17fc24f3f1ceddd74a693da30f1f87774da2328e9287dd2097ab84517.o KAFNetworkActivityIndicatorManager-a1a40cc17fc24f3f1ceddd74a693da30f6671dc689dbfeba653612a231d647e7.o KUIImageView+AFNetworking-a1a40cc17fc24f3f1ceddd74a693da30d53daed08856f37e76e6d82b576e6c02.o KUIButton+AFNetworking-a1a40cc17fc24f3f1ceddd74a693da309068630115bb1ea9a64e2af147e2d7cc.o KUIActivityIndicatorView+AFNetworking-a1a40cc17fc24f3f1ceddd74a693da30367e3613ffc21cd2355caeca550a3ec7.o KUIWebView+AFNetworking-a1a40cc17fc24f3f1ceddd74a693da308d779735f99bde934e571a128acba67d.o KAFAutoPurgingImageCache-a1a40cc17fc24f3f1ceddd74a693da309beb5c005faa1444982c7565da4f9d8f.o KAFImageDownloader-a1a40cc17fc24f3f1ceddd74a693da306a9a96f20bb980ab71772976283c0ecd.o KAFURLResponseSerialization-a1a40cc17fc24f3f1ceddd74a693da30f0f5d2b89304980be949d764a3365c6d.o KAFHTTPSessionManager-a1a40cc17fc24f3f1ceddd74a693da30c4b25aedaa55956bff8fcbbbeb00c3d3.o KAFURLSessionManager-a1a40cc17fc24f3f1ceddd74a693da306e27ec6df912b8bec430b6a53d149649.o KAFURLRequestSerialization-a1a40cc17fc24f3f1ceddd74a693da30005e720b8baa25b301ab087d70369baf.o KAFNetworkReachabilityManager-a1a40cc17fc24f3f1ceddd74a693da306313f935294440fda518e03d49d37daa.o KAFSecurityPolicy-a1a40cc17fc24f3f1ceddd74a693da3015da43421ec97c77d75192b90a53efa1.o Print.o DownloadImage.o FrameworkManager.o Print+test.o DownloadAndPrint_vers.o 报错及解决办法 找不到头文件 创建了一个名为 AFNTestFrameworking 的静态 framework，里面包含一个 AFNTestManager 的类： 在 AFNTestFramework.h 类中，引入需要暴露出来的类： 编译的时候没有问题，但是将这个 framework 导入到测试项目时，报错： 解决办法： 动态链接找不到对应的库 1234567dyld: Library not loaded: @rpath/AFNetworking.framework/AFNetworking Referenced from: /Users/acan/Library/Developer/CoreSimulator/Devices/8B9DBFCA-F796-4142-ABC1-203A91E58762/data/Containers/Bundle/Application/D9084DBC-C80C-4774-BAA0-D71FA86991DD/TestFramework.app/TestFramework Reason: image not found Message from debugger: Terminated due to signal 6 解决办法： 符号表冲突的问题 场景描述：我制作了一个 .framework 静态库，静态库引用了 AFNetworking，在我的 Demo 工程中也引用了 AFNetworking，报了以下错误： 123ld: 165 duplicate symbols for architecture x86_64 clang: error: linker command failed with exit code 1 (use -v to see invocation) 解决办法： 把 framework 中用到的第三方库的类更改名字 Step 1：修改类名 Step 2：根据报错提示，全局搜索，手动修改冲突的类名 123uplicate symbol _OBJC_CLASS_$__AFURLSessionTaskSwizzling in: /Users/acan/Library/Developer/Xcode/DerivedData/DownloadAndPrint-esbkggakvotbghavvyrahlbwezwq/Build/Intermediates.noindex/DownloadAndPrint.build/Debug-iphonesimulator/DownloadAndPrintDemo.build/Objects-normal/x86_64/AFURLSessionManager.o 如： 过程比较繁琐，但是有效。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://github.com/hzsss/tags/iOS/"}]},{"title":"HomePod 测评","slug":"HomePod-测评","date":"2019-03-25T09:38:43.000Z","updated":"2019-04-27T08:51:33.560Z","comments":true,"path":"HomePod-测评/","link":"","permalink":"https://github.com/hzsss/HomePod-测评/","excerpt":"","text":"嗨喽，各位观众朋友们大家好，欢迎收看本期视频。今天给大家带来的是 HomePod 的测评。 去年苹果正式发行了旗下首款智能音箱 – HomePod，时隔一年后，今年的1月18日，终于在中国市场发售。我们呢也拿到了一台，就是我手上的这一台。接下来我会和大家分享一下这一段时间的使用感受和我的一些想法。 桌上的这一台呢就是 HomePod，之前已经使用过一段时间了，所以现在算是一个伪开箱。可以看到包装还是很符合苹果一直以来的风格，大面积的白色再加上产品的外观图就构成了它的包装。 好，让我们打开包装，给大家看一下里面的内容吧。打开包装，第一眼就能看到 HomePod。然后我们先把 HomePod 拿出来，下面是使用说明书和保修卡。大致就是这些内容了。我们先把包装盒放在一边。 在我刚开始拿到 HomePod 的时候，光看包装盒的话，你会觉得，相比于体积小巧的天猫精灵和小爱同学，确实大了不少。但是向现在看到实物时，你会发现，事实上实物要小巧很多，实际的高度只有17厘米，和 iPhone 8 plus 差不多。体积小巧，但是重量却一点都不轻，足足有5斤重，一只手甚至托不住，很有分量。 外观方面依旧维持苹果一贯简洁而又保守的风格，HomePod 提供了深空灰和白色两种配色，我们手里的这台是白色的 HomePod，可以看到它的周围被一圈网眼织物材料包裹，全身上下没有任何实体按键，只有上面的一块纯白色的玻璃触控面板。非常地简洁。甚至连苹果的 logo，这次呢都放在了音箱的底部。可以说外观方面，确实没有什么特色，但是我并不会觉得它很无聊，而正是这种精心设计的简洁，让它能够和各种家具更好地融合在一起，不会喧宾夺主，而是静静地躺在那里，等待你去唤醒它。 接下来让我们来实际操作一下，如何连接、设置并使用这台 HomePod，首先我先打开 WiFi，现在已经查找到这台了 HomePod，好了现在我只需要按照提示进行设置就好了。设置房间，获取权限，以及提示你订阅 Apple music。设置还是比较简单和人性化的，一分钟基本上就能搞定。 和目前市面上众多智能音箱主打语音交互和智能操作不同，HomePod 作为一款主打音质的智能音箱，最让我印象深刻的是它的低音，每一个鼓点，都直击人心，让我不自觉地想要跟随节奏摇摆。而之所以能达到这种效果，根据官方的说法，是因为它将低音单元设置在了顶部朝上的位置，让低音更加雄厚而不沉闷。再利用电机主动驱动振膜震动，振幅高达20毫米，即使是在音量小时，也能够提供震撼的低音。 HomePod 把高音单元放在了底部，通过特殊的折叠号角排列方式，先将音乐传向中心，再以360度的形式从底部扩出。可以消除平面反射声，让声音更加立体，从而营造出全环绕式的空间感。 再加上内置的六个环形排列的麦克风，HomePod 能够精确地捕捉房间内的各种声音。再利用 A8 处理器，也就是 iPhone6 上的那颗处理器，对其进行分析，根据所在的位置和房间的布局自动地调整音效。让人声乐器声这些直达声传送到房间的中央，而将环境声分散至房间周围并反弹回来。从而营造出清晰而又雄厚的环绕声。你会认为声音是从四周发出来的，而不会觉得声音是从一个点上发出来的。 说了这么多，还是给大家实际感受一下 HomePod 的音效。 可以说，HomePod 作为一款智能音箱，在音质方面虽算不上顶级，但也处在优秀的位置，对于像我们这种普通用户来说，确实没有什么可以挑剔了。但是，由于 HomePod 使用的是无线网络，而不是蓝牙进行连接，导致它的延迟非常地严重，基本上有个1秒钟甚至2秒的延迟。虽然现在有些视频软件会主动延迟画面，来尽可能地保持声画同步。但是作为一款价格不菲的音箱，确实可以算是一个非常大的缺点了，声画不同步，强迫症不能忍啊。 对于一款智能音箱来说，语音交互自然是少不了，而对于苹果来说，自然就是 Siri。和手机呼出 Siri 不同，手机一般是离嘴巴更近，受到周围噪声的影响也更小。那对于一款音箱来说，它的挑战自然就大了不少，比如说用户离音箱很远，或者环境很嘈杂，又或者说，HomePod 自己在播放音乐。在这些情况下想要辨别 “Hey Siri” 指令，其实不是一件容易的事情。那苹果在这个问题上是使用了深度学习，甚至专门发表了一篇文章去说明它的原理。大致就是使用事先训练好的深度学习模型，去消除回声和背景噪声。再利用无监督的在线学习，去分离同时声源，消除干扰语音。从而正确的识别用户的指令。下面我示范一下在 HomePod 播放音乐的时候唤醒 Siri。 Hey Siri，可以看到，成功率还是很高的。 在语音识别这方面，苹果确实做得非常好，但是识别之后呢？被大家吐槽了好几年的人工智障 “Siri”，在这个音箱上也并没有特别大的升级进化，能做的基本还是那几样，打电话查天气播放音乐添加备忘录。那么问题来了，在 iPhone，Apple Watch 上都有 Siri，甚至他们有更加丰富的操作方式，为什么，还要一台 HomePod 呢？又或者说，为什么一款智能音箱，要叫做 HomePod 呢？ 这就涉及到苹果对 HomePod 的产品定位的问题，它的确是一款智能音箱，更确切地说，它是一个家庭控制中心。如果你有支持 HomeKit 的配件，那么你可以使用家庭 App 来控制它们，比如控制灯的开关，通过 3D Touch，可以进行更详细的设置，比如调整灯的亮度、色温。甚至可以通过组合操作来实现不同场景的自动化。比如你设置一个“我出门了”的场景，那么便可以自动地关闭灯光，锁好房门，关闭空调等。那说到出门，出于对隐私的保护，苹果并不像米家的产品一样可以通过手机直接远程控制家里的智能配件。而必须通过 HomePod 或者 iPad 来间接地远程控制家庭配件。这也就是为什么叫做 HomePod，为什么需要一台 HomePod，因为，它就是家庭的中枢。 我这里呢并没有支持 HomeKit 的配件，所以无法给大家展示。对于 HomePod 来讲，如果没有智能配件，那么它基本上就是一个音箱+Siri，而高昂的售价，甚至可以把它列入不值得购买的名单。我这几天的使用感受呢，也基本上是把它当成一个音箱来使用，可玩性并不高。但是，我不想就这么否认它。 对于一个产品，我始终是怀着敬畏的态度去看待它，它可以有不足，它可以有些妥协，它甚至可以不值得购买，但每一件产品，都是一家公司自己思考的产物，当想到这一点时，就很难不去发觉它更深层次的东西。 交互比不上小爱，音质和传统音箱又有差距，再加上高昂的售价，HomePod 可以说是处在一个非常尴尬的位置，但这只是苹果在智能家庭上走出的一小步，我们可以通过它，去看到苹果的野心和布局。强大的生态，在机器学习上的推广和深耕，强劲的硬件，都足以让它在未来变得更加智能和完善。而随着 HomeKit 对第三方厂家的授权，让更多的商家可以生产出支持 HomeKit 的配件，HomeKit 屏蔽了硬件的物理细节，大大降低了开发门槛。而 HomeKit 协议要求的各种配件需要实现的功能（当然，有些功能是可选的），也在一定程度上给第三方厂家提供参考。让第三方厂家生产出功能完备，质量符合苹果要求的产品。相信在不久的将来，会有越来越多的支持 HomeKit 的智能配件涌入中国市场，而配件的价格，也会慢慢地降下来，走入更多人的家庭。 而到那个时候，HomePod 才能真正发挥其家庭中枢的作用，连接各种家庭配件，给用户提供无缝的操控体验。苹果在智能家庭上的布局，才算初步完成。 好了，以上就是本期视频的全部内容，欢迎大家收看，谢谢大家~","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"https://github.com/hzsss/tags/技术/"}]},{"title":"2018年度总结","slug":"2018年度总结","date":"2018-12-31T15:57:41.000Z","updated":"2018-12-31T16:54:45.798Z","comments":true,"path":"2018年度总结/","link":"","permalink":"https://github.com/hzsss/2018年度总结/","excerpt":"","text":"现在是2018年12月31日，晚上21点39分。 本没有想过要写年度总结，因为这一年发生的值得写下来的事情不是特别多，所以一直拖到了现在，但是又的确想借这个机会把自己这一年，尤其是这一段时间的一些经历和没有营养的心里想法写下来，供自己以后回顾或者警醒。 应用上架当时老师给了我一个项目，让我帮她写一个 App 并且上架。在当时对我来说还是挺有挑战性的。不过我想着一方面可以不用自己花99美元购买开发者账号，另一方面又能够熟悉一遍上架流程，而且还能积累项目经验，于是就答应了。在准备期末考试和课设的空隙，把 App 写完了，好在 App 本身并不复杂。放寒假的时候，老师还很好心地把她的苹果电脑让我带回家，虽然被拒了3次，过年前一天苹果的技术支持还在和我打电话交流，不过修改了一些细节之后，最终还是顺利上架了。详细的就不展开讲了，可以看我的这两篇文章：《iOS应用上架遇到的一些坑》，《App Store被拒的一次经历（附解决方案）》，也可以在 App Store 下载。 面试其实我面的公司不是很多，真正面试的时间也就只有一周。但准备的时间其实花了蛮久的。在去北京之前大概半个多月之前，就已经在拉勾网，实习僧，还有 boss 直聘上投了简历。然后也和室友一起在自如上面看好了几处房子。从准备上来说还算充分，包括提前打印纸质简历（在学校打印1毛钱一张，在北京1块钱一张），合理预约时间，平均每天上午下午各一个面试，还需要和看房的时间错开。 到了北京，先是住的宾馆，因为我们第二天都有面试，所以把看房的时间约到了几天后。其实最理想的方案就是能够找个地方短租，或者住亲戚家（都没有），然后确定工作之后再决定长期住的地方。但我们并没有找到合适的短租，也不可能一直住宾馆，因为不确定自己到底什么时候能够找到工作，所以提前租房也实属无奈之举。也为我后来的离开埋下了伏笔。 面试前面约了几家都是小公司，比我想象中还要顺利，基本上都是简单地聊了半个小时左右就急切地想要确定合同了。在当时不清楚市场情况和自身水平是否匹配的情况下，的确会担心过了这个村就没这个店，于是就草草地就答应了。但我当时还是比较理智的，于是想先把后面几家约的都先面完再做决定。 先是去了映客面试，差点被百度地图坑死了，给我导航的还是映客以前的地址，害得我夏天中午在马路上一顿狂奔。到了公司，真好看，发自内心的感叹，这年头做短视频做直播真的赚钱。面试官很nice，一个很和蔼的微胖大叔。但是当时自己的计算机基础和算法方面的确偏弱（现在也是），面试过程很尴尬，一面的时候，一个 iOS 的问题都没问，自己也答得马马虎虎，送我出来的时候，我就知道自己没戏了。 其实那天下午我是约了另一家比较小的公司的面试的，但是映客的 HR 小姐姐突然打电话给我，说他们的实习生离职了，当天就需要选一个新的实习生，如果我面试顺利的话可以直接发 Offer 了，我当时犹豫了一会儿，把小公司的面试给取消了（虽然这么做不太好，sorry，我不得已而为之）。怎么说呢，当时我在地铁上，感觉这对我来说是一个极佳的机会，但是后来还是因为自己水平不够高而错过了，确实很可惜的。 后来，就是豆瓣了，我记得那天是周五下午，我先去附近吃了个饭，然后在门外等着。HR 小姐姐带我去会议室，然后给了我一套笔试题，一个小时后完成。接着我后来的导师——浩哥来面试我，答了也差不多一个小时左右，自我感觉答得都挺好的。然后是当时的组长——黄哥，问了我一些计算机基础和网络的问题，其实大多数时间还是他自己在说。最后是 HR 小姐姐，问了我一些其他方面的问题。这次面试算是目前经历过的最长的面试吧，也是我自己感觉最有把握的一次面试。只记得那天面试完在下雨，然后天晴了我去地铁站，进站之前还看到了彩虹。于是发了条朋友圈“希望彩虹能带给我好运”。后来，就顺利拿到豆瓣的 Offer，人生第一份实习，很感谢豆瓣能给我机会。 点击这里查看我的简历 其实面试，不仅是公司选择我们，还是我们选择公司的一个过程。期间我也去过一家很坑的公司，做借贷 App 的，整个公司氛围给人的感觉就不太对劲，面试完立马让你做决定，还来了个肥头大耳凶神恶煞的胖子坐在我对面，就像是电视里催债的人一样。在我面前给我画饼，说现在接不到什么业务，在做马甲包和微信小程序，说我要是来先做微信小程序，等以后可能过几个月接到 iOS 的项目再让我做，工资现在少一点，以后会给你逐渐加的。几句话用了N个不确定用语，而且对于公司来说，要立马接手项目或者改变盈利模式是不可能的，资本的世界是残酷的，所以，这不就是在我面前画大饼么。他要是以后真能够对员工那么好，那为什么不现在就给出足够留住员工的条件呢？ 我主要从这几个方面，去看自己是否适合一家公司。一个是公司的业务，团队的工作氛围，还有给我的工作任务是否和我的专业方向相符，最后一个也是最基本的，就是公司能开给我的条件。 工作入职豆瓣后，部门的大牛们对我都很热情，他们也真正有想培养我的意向，入职后不就便给我安排了一些需求。刚开始是修修 bug，然后是调整一些简单的控件，再是给我一些比较大一点的需求，然后给我介绍设计师，产品经理，还有后台的工程师。先是边做项目边了解真正的工作流程，在群里我都不敢吭声，基本上是有其他部门和我联调我才简单交流一下，生怕自己说错话影响进度。后来熟悉了各个部门的合作开发流程后，自己也能够比较熟练地和前端后端进行合作了。刚开始基本上天天抱着笔记本往导师那跑，到后来导师都不监督我的需求了，放手让我一个人做。 这半年来我是真真切切地感受到自己的成长，从一个学生小白，到一个能够做商用 App 需求的实习生。学会了 git 和 Swift，让自己的代码更加简洁规范，能够考虑多种情况和复用性。还有很多 iOS 开发相关的知识，真的是在学校可能一年都学不到的。 在工作上的成长让我欣喜，部门的哥哥姐姐们对我的培养和帮助也让我感觉很暖心。但是到后来，我渐渐意识到自己的内心逐渐麻木了。可能主要还是由于自己住得真的是太远了，到了冬天这种劣势就被放大了。每天7点钟起床，7点半出发，在寒风中等公交车，然后在地铁里站一个多小时到公司，整个路程加起来1小时40分钟左右。不仅每天早起没有精神，需求多的时候每天都要加班，但又不能加得太晚，因为会没有地铁。基本上每天下午19点半或者20点以后离开公司，吃个饭然后到家差不多都21点或者22点了，洗个澡什么的又23点了，然后睡觉，第二天7点又要早起，如此循环往复。 面试的时候，我就意识到，自己的计算机基础并不扎实，（不是计算机专业，但这不是借口），所以一直想着抽空补一补这方面的知识，因为大公司一定会问到这些，而且工作上如果想要成长，如果基础知识不扎实，一定会成为瓶颈。但是，工作以后再加上住得很远，每天累还不说，就没有自己的时间。而且换房子，对于拿实习生工资的我来说，基本上不太可能，也不想再向家里要钱了。 这种状态持续了很久，终于逐渐萌生出辞职的想法，一方面在路上的时间实在是太长了，上下班路上又冷又饿简直怀疑人生，根本没有自己的生活，每天的精神状态也很差，甚至有一段时间对工作也产生了抵触心理，每天上地铁心里就难受得不行，而且每天在路上的4个小时，根本就是没有意义的浪费生命，一副很努力的样子，但是这种努力还不如住得近一点，多睡一点，精神饱满去上班，虽然当时不可能。另一方面自己也想试一试春招，但是照目前这种工作节奏来说，没有时间让我再去准备了。还有其他各种原因吧，权衡了很久，最后还是向公司提出了离职。12月25日，正好是圣诞节，一群人热热闹闹在举办活动，而我一个人在办离职申请，不过还是很感谢豆瓣。 新年期许离职之前做好了回家的学习计划，不敢说春招就一定会怎么样。总之先按计划来吧，有一个大体的路线和目标，至少不会走偏。2018过得其实挺不如意的，但发生了很多事也让我从各方面成长了非常多。2019年，我希望不要再浑浑噩噩吧，脑子清醒一点冷静一点。找一份满意的工作。多学几项技能，毕竟技多不压身。顺利毕业，然后希望能够帮爸妈减轻生活的压力，带爸妈多出来看一看外面的世界吧。","categories":[],"tags":[]},{"title":"操作系统学习笔记","slug":"操作系统学习笔记","date":"2018-09-25T10:25:43.000Z","updated":"2018-12-19T07:15:10.224Z","comments":true,"path":"操作系统学习笔记/","link":"","permalink":"https://github.com/hzsss/操作系统学习笔记/","excerpt":"","text":"第一章 操作系统引论1.1 操作系统的目标和作用1.1.1 操作系统的目标 有效性 操作系统的有效性可包含如下两方面的含意： (1) 提高系统资源利用率。配置了 OS 之后，可使 CPU 和 I/O 设备由于能保持忙碌状态而得到有效的利用，且可使内存和外存中存放的数据因有序而节省了存储空间。 (2) 提高系统的吞吐量。操作系统还可以通过合理地组织计算机的工作流程，而进一步改善资源的利用率，加速程序的运行，缩短程序的运行周期，从而提高系统的吞吐量。 方便性 配置 OS 后可使计算机系统更容易使用。 可扩充性 OS 必须具有很好的可扩充性，方能适应计算机硬件、体系结构以及应用发展的要求。 开放性 为使来自不同厂家的计算机和设备能通过网络加以集成化，并能正确、有效地协同工作，实现应用的可移植性和互操作性，要求操作系统必须提供统一的开放环境，进而要求 OS 具有开放性。 开放性是指系统能遵循世界标准规范，特别是遵循开放系统互连(OSI)国际标准。凡遵循国际标准所开发的硬件和软件，均能彼此兼容，可方便地实现互连。 1.1.2 操作系统的作用 OS 作为用户与计算机硬件系统之间的接口 OS 作为用户与计算机硬件系统之间接口的含义是：OS 处于用户与计算机硬件系统之间，用户通过 OS 来使用计算机系统。或者说，用户在 OS 帮助下，能够方便、快捷、安全、可靠地操纵计算机硬件和运行自己的程序。 用户可通过以下三种方式使用计算机： (1) 命令方式。这是指由 OS 提供了一组联机命令接口，以允许用户通过键盘输入有关命令来取得操作系统的服务，并控制用户程序的运行。 (2) 系统调用方式。OS 提供了一组系统调用，用户可在自己的应用程序中通过相应的系统调用，来实现与操作系统的通信，并取得它的服务。 (3) 图形、窗口方式。这是当前使用最为方便、最为广泛的接口，它允许用户通过屏幕上的窗口和图标来实现与操作系统的通信，并取得它的服务。 OS 作为计算机系统资源的管理者 在一个计算机系统中，通常都含有各种各样的硬件和软件资源。归纳起来可将资源分为四类：处理器、存储器、I/O 设备以及信息(数据和程序)。 (1) 处理机管理，用于分配和控制处理机； (2) 存储器管理，主要负责内存的分配与回收； (3) I/O 设备管理，负责 I/O 设备的分配与操纵； (4) 文件管理，负责文件的存取、共享和保护。 OS 实现了对计算机资源的抽象 OS 是铺设在计算机硬件上的多层系统软件，它们不仅增强了系统的功能，而且还隐藏了对硬件操作的细节，由它们实现了对计算机硬件操作的多个层次的抽象。 1.2 操作系统的发展过程1.2.1 无操作系统的计算机系统1.2.2 单道批处理系统 单道批处理系统的处理过程 其自动处理过程是：首先，由监督程序将磁带上的第一个作业装入内存，并把运行控制权交给该作业。当该作业处理完成时，又把控制权交还给监督程序，再由监督程序把磁带(盘)上的第二个作业调入内存。计算机系统就这样自动地一个作业一个作业地进行处理，直至磁带(盘)上的所有作业全部完成，这样便形成了早期的批处理系统。由于系统对作业的处理都是成批地进行的，且在内存中始终只保持一道作业，故称此系统为单道批处理系统(Simple Batch Processing System)。 单道批处理系统的特征 (1) 自动性。在顺利情况下，在磁带上的一批作业能自动地逐个地依次运行，而无需人工预。 (2) 顺序性。磁带上的各道作业是顺序地进入内存，各道作业的完成顺序与它们进入内存的顺序，在正常情况下应完全相同，亦即先调入内存的作业先完成。 (3) 单道性。内存中仅有一道程序运行，即监督程序每次从磁带上只调入一道程序进入内存运行，当该程序完成或发生异常情况时，才换入其后继程序进入内存运行。 1.2.3 多道批处理系统 多道批处理系统的基本概念 在引入多道程序设计技术后，由于同时在内存中装有若干道程序，并使它们交替地运行，这样，当正在运行的程序因 I/O 而暂停执行时，系统可调度另一道程序运行，从而保持了 CPU 处于忙碌状态。 宏观上并行：同时进入系统的多道程序都处于运行过程中，即它们先后开始了各自的运行，但都未运行完毕。 微观上串行：内存中的多道程序轮流占有 CPU，交替执行。 多道批处理系统的优点 (1) 提高 CPU 的利用率。 (2) 可提高内存和 I/O 设备利用率。许在内存中装入多道程序，并允许它们并发执行，则无疑会大大提高内存和 I/O 设备的利用率。 (3) 增加系统吞吐量。在保持 CPU、I/O 设备不断忙碌的同时，也必然会大幅度地提高系统的吞吐量，从而降低作业加工所需的费用。 多道批处理系统的优点 (1) 平均周转时间长。在批处理系统中，由于作业要排队，依次进行处理，因而作业的周转时间较长，通常需几个小时，甚至几天 (2) 无交互能力。用户一旦把作业提交给系统后，直至作业完成，用户都不能与自己的作业进行交互，这对修改和调试程序是极不方便的。 1.2.4 分时系统 分时系统的概念 在操作系统中釆用分时技术就形成了分时系统。所谓分时技术就是把处理器的运行时间分成很短的时间片，按时间片轮流把处理器分配给各联机作业使用。若某个作业在分配给它的时间片内不能完成其计算，则该作业暂时停止运行，把处理器让给其他作业使用，等待下一轮再继续运行。由于计算机速度很快，作业运行轮转得很快，给每个用户的感觉好像是自己独占一台计算机。 分时系统的特征 (1) 多路性。允许在一台主机上同时联接多台联机终端，系统按分时原则为每个用户服务。宏观上，是多个用户同时工作，共享系统资源；而微观上，则是每个用户作业轮流运行一个时间片。多路性即同时性，它提高了资源利用率，降低了使用费用，从而促进了计算机更广泛的应用。 (2) 独立性。每个用户各占一个终端，彼此独立操作，互不干扰。因此，用户所感觉到的，就像是他一人独占主机。 (3) 及时性。用户的请求能在很短的时间内获得响应。此时间间隔是以人们所能接受的等待时间来确定的，通常仅为 1～3 秒钟。 (4) 交互性。用户可通过终端与系统进行广泛的人机对话。其广泛性表现在：用户可以请求系统提供多方面的服务，如文件编辑、数据处理和资源共享等。 1.2.5 实时系统所谓“实时”，是表示“及时”，而实时系统(Real Time System)是指系统能及时(或即时)响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。 1.2.6 微机操作系统的发展配置在微型机上的操作系统称为微机操作系统。 单用户单任务操作系统 单用户单任务操作系统的含义是，只允许一个用户上机，且只允许用户程序作为一个任务运行。最有代表性的单用户单任务微机操作系统是 CP/M 和 MS-DOS。 单用户多任务操作系统 单用户多任务操作系统的含义是，只允许一个用户上机，但允许用户把程序分为若干个任务，使它们并发执行，从而有效地改善了系统的性能。目前在 32 位微机上配置的操作系统基本上都是单用户多任务操作系统，其中最有代表性的是由微软公司推出的 Windows。 多用户多任务操作系统 多用户多任务操作系统的含义是，允许多个用户通过各自的终端使用同一台机器，共享主机系统中的各种资源，而每个用户程序又可进一步分为几个任务，使它们能并发执行，从而可进一步提高资源利用率和系统吞吐量。 其中最有代表性的是 UNIX OS。现在最有影响的两个能运行在微机上的 UNIX 操作系统的变型是 Solaris OS 和 Linux OS。 1.3 操作系统的基本特性1.3.1 并发性 并行与并发 并行性和并发性(Concurrence)是既相似又有区别的两个概念，并行性是指两个或多个事件在同一时刻发生；而并发性是指两个或多个事件在同一时间间隔内发生。 在多道程序环境下，并发性是指在一段时间内宏观上有多个程序在同时运行，但在单处理机系统中，每一时刻却仅能有一道程序执行，故微观上这些程序只能是分时地交替执行。 倘若在计算机系统中有多个处理机，则这些可以并发执行的程序便可被分配到多个处理机上，实现并行执行，即利用每个处理机来处理一个可并发执行的程序，这样，多个程序便可同时执行。 引入进程 应当指出，通常的程序是静态实体(Passive Entity)，在多道程序系统中，它们是不能独立运行的，更不能和其它程序并发执行。在操作系统中引入进程的目的，就是为了使多个程序能并发执行。 为使多个程序能并发执行，系统必须分别为每个程序建立进程(Process)。简单说来，进程是指在系统中能独立运行并作为资源分配的基本单位，它是由一组机器指令、数据和堆栈等组成的，是一个能独立运行的活动实体。多个进程之间可以并发执行和交换信息。一个进程在运行时需要一定的资源，如 CPU、存储空间及 I/O 设备等。 引入线程 通常在一个进程中可以包含若干个线程，它们可以利用进程所拥有的资源。在引入线程的 OS 中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位。 1.3.2 共享性在操作系统环境下，所谓共享(Sharing)，是指系统中的资源可供内存中多个并发执行的进程(线程)共同使用，相应地，把这种资源共同使用称为资源共享，或称为资源复用。 互斥共享方式 系统中的某些资源，如打印机、磁带机，虽然它们可以提供给多个进程(线程)使用，但为使所打印或记录的结果不致造成混淆，应规定在一段时间内只允许一个进程(线程)访问该资源。为此，系统中应建立一种机制，以保证对这类资源的互斥访问。 为此，系统中应建立一种机制，以保证对这类资源的互斥访问。当一个进程 A 要访问某资源时，必须先提出请求。如果此时该资源空闲，系统便可将之分配给请求进程 A 使用。此后若再有其它进程也要访问该资源时(只要 A 未用完)，则必须等待。仅当 A 进程访问完并释放该资源后，才允许另一进程对该资源进行访问。 我们把这种资源共享方式称为互斥式共享，而把在一段时间内只允许一个进程访问的资源称为临界资源或独占资源。计算机系统中的大多数物理设备，以及某些软件中所用的栈、变量和表格，都属于临界资源，它们要求被互斥地共享。为此，在系统中必需配置某种机制来保证诸进程互斥地使用独占资源。 临界资源是定义在共享资源上的，临界资源一定是共享资源。 同时共享方式 系统中还有另一类资源，允许在一段时间内由多个进程“同时”对它们进行访问。这里所谓的“同时”，在单处理机环境下往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问。典型的可供多个进程“同时”访问的资源是磁盘设备，一些用重入码编写的文件也可以被“同时”共享，即若干个用户同时访问该文件。 虚拟性 时分复用技术 在虚拟处理机技术中，利用多道程序设计技术，为每道程序建立一个进程，让多道程序并发地执行，以此来分时使用一台处理机。此时，虽然系统中只有一台处理机，但它却能同时为多个用户服务，使每个终端用户都认为是有一个处理机在专门为他服务。 空分复用技术 如果说时分复用技术是利用处理机的空闲时间来运行其它的程序，使处理机的利用率得以提高，那么空分复用则是利用存储器的空闲空间来存放其它的程序，以提高内存的利用率。 1.3.4 异步性进程是以人们不可预知的速度向前推进，此即进程的异步性(Asynchronism)。 1.4 操作系统的主要功能1.4.1 处理机管理功能 进程控制 进程控制的主要功能是为作业创建进程，撤消已结束的进程，以及控制进程在运行过程中的状态转换。在现代 OS 中，进程控制还应具有为一个进程创建若干个线程的功能和撤消(终止)已完成任务的线程的功能。 进程同步 前已述及，进程是以异步方式运行的，并以人们不可预知的速度向前推进。为使多个进程能有条不紊地运行，系统中必须设置进程同步机制。 (1) 进程互斥方式。这是指诸进程(线程)在对临界资源进行访问时，应采用互斥方式； (2) 进程同步方式。这是指在相互合作去完成共同任务的诸进程(线程)间，由同步机构对它们的执行次序加以协调。 进程通信 当相互合作的进程(线程)处于同一计算机系统时，通常在它们之间是采用直接通信方式，即由源进程利用发送命令直接将消息(Message)挂到目标进程的消息队列上，以后由目标进程利用接收命令从其消息队列中取出消息。 调度 在后备队列上等待的每个作业都需经过调度才能执行。在传统的操作系统中，包括作业调度和进程调度两步。 1.4.2 存储器管理功能 内存分配 内存分配的主要任务是为每道程序分配内存空间，使它们“各得其所”；提高存储器的利用率，以减少不可用的内存空间；允许正在运行的程序申请附加的内存空间，以适应程序和数据动态增长的需要。 内存保护 内存保护的主要任务是确保每道用户程序都只在自己的内存空间内运行，彼此互不干扰；绝不允许用户程序访问操作系统的程序和数据；也不允许用户程序转移到非共享的其它用户程序中去执行。 地址映射 为使程序能正确运行，存储器管理必须提供地址映射功能，以将地址空间中的逻辑地址转换为内存空间中与之对应的物理地址。该功能应在硬件的支持下完成。 内存扩充 存储器管理中的内存扩充任务并非是去扩大物理内存的容量，而是借助于虚拟存储技术，从逻辑上去扩充内存容量，使用户所感觉到的内存容量比实际内存容量大得多，以便让更多的用户程序并发运行。 (1) 请求调入功能。允许在装入一部分用户程序和数据的情况下，便能启动该程序运行。在程序运行过程中，若发现要继续运行时所需的程序和数据尚未装入内存，可向 OS 发出请求，由 OS 从磁盘中将所需部分调入内存，以便继续运行。 (2) 置换功能。若发现在内存中已无足够的空间来装入需要调入的程序和数据时，系统应能将内存中的一部分暂时不用的程序和数据调至盘上，以腾出内存空间，然后再将所需调入的部分装入内存。 1.4.3 设备管理功能设备管理用于管理计算机系统中所有的外围设备，而设备管理的主要任务是：完成用户进程提出的 I/O 请求；为用户进程分配其所需的 I/O 设备；提高 CPU 和 I/O 设备的利用率；提高I/O 速度；方便用户使用 I/O 设备。 缓冲功能 CPU 运行的高速性和 I/O 低速性间的矛盾自计算机诞生时起便已存在了。如果在 I/O 设备和 CPU之间引入缓冲，则可有效地缓和 CPU 与 I/O 设备速度不匹配的矛盾，提高 CPU 的利用率，进而提高系统吞吐量。提高 CPU 与设备之间的并行程度。 设备分配 设备分配的基本任务是根据用户进程的 I/O 请求、系统的现有资源情况以及按照某种设备的分配策略，为之分配其所需的设备。 设备处理 设备处理程序又称为设备驱动程序。其基本任务是用于实现 CPU 和设备控制器之间的通信，即由 CPU 向设备控制器发出 I/O 命令，要求它完成指定的 I/O 操作；反之，由 CPU 接收从控制器发来的中断请求，并给予迅速的响应和相应的处理。 1.4.4 文件管理功能 文件存储空间的管理 系统应设置相应的数据结构，用于记录文件存储空间的使用情况，以供分配存储空间时参考；系统还应具有对存储空间进行分配和回收的功能。为了提高存储空间的利用率，对存储空间的分配，通常是采用离散分配方式，以减少外存零头，并以盘块为基本分配单位。盘块的大小通常为 1～8 KB。 目录管理 为了使用户能方便地在外存上找到自己所需的文件，通常由系统为每个文件建立一个目录项。目录项包括文件名、文件属性、文件在磁盘上的物理位置等。由若干个目录项又可构成一个目录文件。其次，目录管理还应能实现文件共享，这样，只须在外存上保留一份该共享文件的副本。此外，还应能提供快速的目录查询手段，以提高对文件的检索速度。 文件的读/写管理和保护 1.4.5 操作系统与用户之间的接口 用户接口 它是提供给用户使用的接口，用户可通过该接口取得操作系统的服务； 程序接口 它是提供给程序员在编程时使用的接口，是用户程序取得操作系统服务的惟一途径。 1.51.5.1 微内核 OS 结构 微内核操作系统的优点 (1) 提高了系统的可扩展性 (2) 增强了系统的可靠性 (3) 可移植性 (4) 提供了对分布式系统的支持 (5) 融入了面向对象技术 微内核操作系统存在的问题 微内核 OS 的运行效率有所降低。效率降低的最主要的原因是，在完成一次客户对 OS 提出的服务请求时，需要利用消息实现多次交互和进行用户/内核模式及上下文的多次切换。 第二章 进程管理2.1 进程的基本概念2.1.1 程序的顺序执行及其特征 程序顺序执行时的特征 (1) 顺序性：处理机的操作严格按照程序所规定的顺序执行，即每一操作必须在上一个操作结束之后开始。 (2) 封闭性：程序是在封闭的环境下执行的，即程序运行时独占全机资源，资源的状态(除初始状态外)只有本程序才能改变它。程序一旦开始执行，其执行结果不受外界因素影响。 (3) 可再现性：只要程序执行时的环境和初始条件相同，当程序重复执行时，不论它是从头到尾不停顿地执行，还是“停停走走”地执行，都将获得相同的结果。 2.1.2 程序的并发执行及其特征 程序的并发执行时的特征 (1) 间断性：程序在并发执行时，由于它们共享系统资源，以及为完成同一项任务而相互合作，致使在这些并发执行的程序之间，形成了相互制约的关系。 (2) 失去封闭性：程序在并发执行时，是多个程序共享系统中的各种资源，因而这些资源的状态将由多个程序来改变，致使程序的运行失去了封闭性。这样，某程序在执行时，必然会受到其它程序的影响。例如，当处理机这一资源已被某个程序占有时，另一程序必须等待。 (3) 不可再现性：程序在并发执行时，由于失去了封闭性，也将导致其再失去可再现性。程序经过多次执行后，虽然它们执行时的环境和初始条件相同，但得到的结果却各不相同。 2.1.3 进程的特征与状态 进程的特征和定义 为使程序能并发执行，且为了对并发执行的程序加以描述和控制，人们引入了“进程”的概念。下面对进程的特征加以描述。 (1) 结构特征： 通常的程序是不能并发执行的。为使程序(含数据)能独立运行，应为之配置一进程控制块，即 PCB(Process Control Block)；而由程序段、相关的数据段和 PCB三部分便构成了进程实体。在早期的 UNIX 版本中，把这三部分总称为“进程映像”。值得指出的是，在许多情况下所说的进程，实际上是指进程实体，例如，所谓创建进程，实质上是创建进程实体中的 PCB；而撤消进程，实质上是撤消进程的 PCB。 (2) 动态性： 进程的实质是进程实体的一次执行过程，因此，动态性是进程的最基本的特征。动态性还表现在：“它由创建而产生，由调度而执行，由撤消而消亡”。可见，进程实体有一定的生命期，而程序则只是一组有序指令的集合，并存放于某种介质上，其本身并不具有运动的含义，因而是静态的。 (3) 并发性： 这是指多个进程实体同存于内存中，且能在一段时间内同时运行。并发性是进程的重要特征，同时也成为 OS 的重要特征。引入进程的目的也正是为了使其进程实体能和其它进程实体并发执行；而程序(没有建立 PCB)是不能并发执行的。 (4) 独立性： 在传统的 OS 中，独立性是指进程实体是一个能独立运行、独立分配资源和独立接受调度的基本单位。凡未建立 PCB 的程序都不能作为一个独立的单位参与运行。 (5) 异步性： 这是指进程按各自独立的、 不可预知的速度向前推进，或说进程实体按异步方式运行。 现在我们再来讨论进程的定义。曾有许多人从不同的角度对进程下过定义，其中较典型的进程定义有： (1) 进程是程序的一次执行。 (2) 进程是一个程序及其数据在处理机上顺序执行时所发生的活动。 (3) 进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。 在引入了进程实体的概念后，我们可以把传统 OS 中的进程定义为：“进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位”。 进程的三种基本状态 (1) 就绪（ready）状态： 当进程已分配到除 CPU 以外的所有必要资源后，只要再获得 CPU，便可立即执行，进程这时的状态称为就绪状态。在一个系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。 (2) 执行状态： 进程已获得 CPU，其程序正在执行。在单处理机系统中，只有一个进程处于执行状态；在多处理机系统中，则有多个进程处于执行状态。 (3) 阻塞状态： 正在执行的进程由于发生某事件而暂时无法继续执行时，便放弃处理机而处于暂停状态，亦即进程的执行受到阻塞，把这种暂停状态称为阻塞状态，有时也称为等待状态或封锁状态。致使进程阻塞的典型事件有：请求 I/O，申请缓冲空间等。通常将这种处于阻塞状态的进程也排成一个队列。有的系统则根据阻塞原因的不同而把处于阻塞状态的进程排成多个队列。 处于就绪状态的进程，在调度程序为之分配了处理机之后，该进程便可执行，相应地，它就由就绪状态转变为执行状态。正在执行的进程也称为当前进程，如果因分配给它的时间片已完而被暂停执行时，该进程便由执行状态又回复到就绪状态；如果因发生某事件而使进程的执行受阻(例如，进程请求访问某临界资源，而该资源正被其它进程访问时)，使之无法继续执行，该进程将由执行状态转变为阻塞状态。图 2-5 示出了进程的三种基本状态以及各状态之间的转换关系。 挂起状态 在引入挂起状态后，又将增加从挂起状态(又称为静止状态)到非挂起状态(又称为活动状态)的转换；或者相反。可有以下几种情况： (1) 活动就绪→静止就绪。 (2) 活动阻塞→静止阻塞。 (3) 静止就绪→活动就绪。 (4) 静止阻塞→活动阻塞。 创建状态和终止状态 (1) 创建状态：创建一个进程一般要通过两个步骤：首先，为一个新进程创建 PCB，并填写必要的管理信息； 其次，把该进程转入就绪状态并插入就绪队列之中。 当一个新进程被创建时，系统已为其分配了 PCB，填写了进程标识等信息，但由于该进程所必需的资源或其它信息，如主存资源尚未分配等，一般而言，此时的进程已拥有了自己的 PCB，但进程自身还未进入主存，即创建工作尚未完成，进程还不能被调度运行，其所处的状态就是创建状态。 (2) 终止状态：进程的终止也要通过两个步骤：首先等待操作系统进行善后处理，然后将其 PCB 清零，并将 PCB 空间返还系统。 2.1.4 进程控制块（PCB） 进程控制块的作用 为了描述和控制进程的运行，系统为每个进程定义了一个数据结构——进程控制块PCB(Process Control Block)，它是进程实体的一部分，是操作系统中最重要的记型数据结构。 PCB 中记录了操作系统所需的、用于描述进程的当前情况以及控制进程运行的全部信息。进程控制块的作用是使一个在多道程序环境下不能独立运行的程序(含数据)，成为一个能独立运行的基本单位，一个能与其它进程并发执行的进程。或者说，OS 是根据 PCB 来对并发执行的进程进行控制和管理的。 可见，在进程的整个生命期中，系统总是通过 PCB 对进程进行控制的，亦即，系统是根据进程的 PCB 而不是任何别的什么而感知到该进程的存在的。所以说，PCB 是进程存在的惟一标志。 当系统创建一个新进程时，就为它建立了一个 PCB；进程结束时又回收其 PCB，进程于是也随之消亡。PCB 可以被操作系统中的多个模块读或修改，如被调度程序、资源分配程序、中断处理程序以及监督和分析程序等读或修改。因为 PCB 经常被系统访问，尤其是被运行频率很高的进程及分派程序访问，故 PCB 应常驻内存。系统将所有的 PCB 组织成若干个链表(或队列)，存放在操作系统中专门开辟的 PCB 区内。 进程控制块中的信息 (1) 进程标识符： 进程标识符用于惟一地标识一个进程。一个进程通常有两种标识符： 内部标识符。在所有的操作系统中，都为每一个进程赋予了一个惟一的数字标识符，它通常是一个进程的序号。设置内部标识符主要是为了方便系统使用。 外部标识符。它由创建者提供，通常是由字母、数字组成，往往是由用户(进程)在访问该进程时使用。为了描述进程的家族关系，还应设置父进程标识及子进程标识。此外，还可设置用户标识，以指示拥有该进程的用户。 (2) 处理机状态： 处理机状态信息主要是由处理机的各种寄存器中的内容组成的。处理机在运行时，许多信息都放在寄存器中。当处理机被中断时，所有这些信息都必须保存在 PCB 中，以便在该进程重新执行时，能从断点继续执行。 (3) 进程调度信息： 在 PCB 中还存放一些与进程调度和进程对换有关的信息，包括： ① 进程状态，指明进程的当前状态，作为进程调度和对换时的依据； ② 进程优先级，用于描述进程使用处理机的优先级别的一个整数，优先级高的进程应优先获得处理机； ③ 进程调度所需的其它信息，它们与所采用的进程调度算法有关，比如，进程已等待 CPU 的时间总和、进程已执行的时间总和等； ④ 事件，指进程由执行状态转变为阻塞状态所等待发生的事件，即阻塞原因。 (4) 进程控制信息： 进程控制信息包括：① 程序和数据的地址，指进程的程序和数据所在的内存或外存地(首)址，以便再调度到该进程执行时，能从 PCB 中找到其程序和数据； ② 进程同步和通信机制，指实现进程同步和进程通信时必需的机制，如消息队列指针、信号量等，它们可能全部或部分地放在 PCB 中； ③ 资源清单，即一张列出了除 CPU 以外的、进程所需的全部资源及已经分配到该进程的资源的清单； ④ 链接指针，它给出了本进程(PCB)所在队列中的下一个进程的 PCB 的首地址。 2.2 进程控制进程控制一般是由 OS 的内核中的原语来实现的。 原语(Primitive)是由若干条指令组成的，用于完成一定功能的一个过程。它与一般过程的区别在于：它们是“原子操作(Action Operation)”。所谓原子操作，是指一个操作中所有动作要么全做，要么全不做。换言之，它是一个不可分割的基本单位，因此，在执行过程中不允许被中断。原子操作在管态下执行，常驻内存。 原语的作用是为了实现进程的通信和控制，系统对进程的控制如不使用原语，就会造成其状态的不确定性，从而达不到进程控制的目的。 管态又叫特权态，系统态或核心态。CPU在管态下可以执行指令系统的全集。通常，操作系统在管态下运行。 目态又叫常态或用户态。机器处于目态时，程序只能执行非特权指令。用户程序只能在目态下运行，如果用户程序在目态下执行特权指令，硬件将发生中断，由操作系统获得控制，特权指令执行被禁止，这样可以防止用户程序有意或无意的破坏系统。 从目态转换为管态的唯一途径是中断。 从管态到目态可以通过修改程序状态字来实现，这将伴随这由操作系统程序到用户程序的转换。 2.2.1 进程的创建 进程图 进程图是用于描述一个进程的家族关系的有向树，如图 2-11 所示。图中的结点(圆圈)代表进程。在进程 D 创建了进程 I 之后，称 D 是 I 的父进程(Parent Process)，I 是 D 的子进程(Progeny Process)。这里可用一条由父进程指向子进程的有向边来描述它们之间的父子关系。创建父进程的进程称为祖先进程，这样便形成了一棵进程树，把树的根结点作为进程家族的祖先(Ancestor)。 了解进程间的这种关系是十分重要的。因为子进程可以继承父进程所拥有的资源，例如，继承父进程打开的文件，继承父进程所分配到的缓冲区等。当子进程被撤消时，应将其从父进程那里获得的资源归还给父进程。此外，在撤消父进程时，也必须同时撤消其所有的子进程。为了标识进程之间的家族关系，在 PCB 中都设置了家族关系表项，以标明自己的父进程及所有的子进程。 引起创建进程的事件 在多道程序环境中，只有(作为)进程(时)才能在系统中运行。因此，为使程序能运行，就必须为它创建进程。导致一个进程去创建另一个进程的典型事件，可有以下四类： (1) 用户登录。在分时系统中，用户在终端键入登录命令后，如果是合法用户，系统将为该终端建立一个进程，并把它插入就绪队列中。 (2) 作业调度。在批处理系统中，当作业调度程序按一定的算法调度到某作业时，便将作业装入内存，为它分配必要的资源，并立即为它创建进程，再插入就绪队列中。 (3) 提供服务。当运行中的用户程序提出某种请求后，系统将专门创建一个进程来提供用户所需要的服务，例如，用户程序要求进行文件打印，操作系统将为它创建一个打印进程，这样，不仅可使打印进程与该用户进程并发执行，而且还便于计算出为完成打印任务所花费的时间。 (4) 应用请求。在上述三种情况下，都是由系统内核为它创建一个新进程；而第 4 类事件则是基于应用进程的需求，由它自己创建一个新进程，以便使新进程以并发运行方式完成特定任务。例如，某应用程序需要不断地从键盘终端输入数据，继而又要对输入数据进行相应的处理，然后，再将处理结果以表格形式在屏幕上显示。该应用进程为使这几个操作能并发执行，以加速任务的完成，可以分别建立键盘输入进程、表格输出进程。 进程的创建 一旦操作系统发现了要求创建新进程的事件后，便调用进程创建原语 Creat() 按下述步骤创建一个新进程。 (1) 申请空白 PCB。为新进程申请获得惟一的数字标识符，并从 PCB 集合中索取一个空白 PCB。 (2) 为新进程分配资源。为新进程的程序和数据以及用户栈分配必要的内存空间。 (3) 初始化进程控制块。PCB 的初始化包括： ① 初始化标识信息，将系统分配的标识符和父进程标识符填入新 PCB 中； ② 初始化处理机状态信息，使程序计数器指向程序的入口地址，使栈指针指向栈顶； ③ 初始化处理机控制信息，将进程的状态设置为就绪状态或静止就绪状态，对于优先级，通常是将它设置为最低优先级，除非用户以显式方式提出高优先级要求。 (4) 将新进程插入就绪队列，如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列。 2.2.2 进程的终止 进程的终止过程 如果系统中发生了上述要求终止进程的某事件，OS 便调用进程终止原语，按下述过程去终止指定的进程。 (1) 根据被终止进程的标识符，从 PCB 集合中检索出该进程的 PCB，从中读出该进程的状态。 (2) 若被终止进程正处于执行状态，应立即终止该进程的执行，并置调度标志为真，用于指示该进程被终止后应重新进行调度。 (3) 若该进程还有子孙进程，还应将其所有子孙进程予以终止，以防它们成为不可控的进程。 (4) 将被终止进程所拥有的全部资源，或者归还给其父进程，或者归还给系统。 (5) 将被终止进程(PCB)从所在队列(或链表)中移出，等待其他程序来搜集信息。 2.2.3 进程的阻塞与唤醒 进程阻塞过程 正在执行的进程，当发现上述某事件时，由于无法继续执行，于是进程便通过调用阻塞原语 block 把自己阻塞。可见，进程的阻塞是进程自身的一种主动行为。进入 block过程后，由于此时该进程还处于执行状态，所以应先立即停止执行，把进程控制块中的现行状态由“执行”改为“阻塞”，并将 PCB 插入阻塞队列。如果系统中设置了因不同事件而阻塞的多个阻塞队列，则应将本进程插入到具有相同事件的阻塞(等待)队列。最后，转调度程序进行重新调度，将处理机分配给另一就绪进程并进行切换，亦即，保留被阻塞进程的处理机状态(在 PCB 中)，再按新进程的 PCB 中的处理机状态设置 CPU 的环境。 进程唤醒状态 当被阻塞进程所期待的事件出现时，如 I/O 完成或其所期待的数据已经到达，则由有关进程(比如用完并释放了该 I/O 设备的进程)调用唤醒原语 wakeup( )，将等待该事件的进程唤醒。唤醒原语执行的过程是：首先把被阻塞的进程从等待该事件的阻塞队列中移出，将其PCB 中的现行状态由阻塞改为就绪，然后再将该 PCB 插入到就绪队列中。 应当指出，block 原语和 wakeup 原语是一对作用刚好相反的原语。因此，如果在某进程中调用了阻塞原语，则必须在与之相合作的另一进程中或其他相关的进程中安排唤醒原语，以能唤醒阻塞进程；否则，被阻塞进程将会因不能被唤醒而长久地处于阻塞状态，从而再无机会继续运行。 2.3 进程同步在 OS 中引入进程后，虽然提高了资源的利用率和系统的吞吐量，但由于进程的异步性，也会给系统造成混乱，尤其是在他们争用临界资源时。 进程同步的主要任务是对多个相关进程在执行次序上进行协调，以使并发执行的诸进程之间能有效地共享资源和相互合作，从而使程序的执行具有可再现性。 2.3.1 进程同步的基本概念 两种形式的制约关系：在多道程序环境下，当程序并发执行时，由于资源共享和进程合作，使同处于一个系统中的诸进程之间可能存在着以下两种形式的制约关系。 (1) 间接相互制约关系。 (2) 直接相互制约关系。 临界资源 在第一章中我们曾经介绍过，许多硬件资源如打印机、磁带机等，都属于临界资源(Critical Resouce)，诸进程间应采取互斥方式，实现对这种资源的共享。（临界资源首先是共享资源）。 临界区 由前所述可知，不论是硬件临界资源，还是软件临界资源，多个进程必须互斥地对它进行访问。人们把在每个进程中访问临界资源的那段代码称为临界区(critical section)。 同步机制应遵循的规则 为实现进程互斥地进入自已的临界区，可用软件方法，更多的是在系统中设置专门的同步机构来协调各进程间的运行。所有同步机制都应遵循下述四条准则： (1) 空闲让进。当无进程处于临界区时，表明临界资源处于空闲状态，应允许一个请求进入临界区的进程立即进入自己的临界区，以有效地利用临界资源。 (2) 忙则等待。当已有进程进入临界区时，表明临界资源正在被访问，因而其它试图进入临界区的进程必须等待，以保证对临界资源的互斥访问。 (3) 有限等待。对要求访问临界资源的进程，应保证在有限时间内能进入自己的临界区，以免陷入“死等”状态。 (4) 让权等待。当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入“忙等”状态。 2.3.2 信号量机制信号量机构是一种功能较强的机制，可用来解决互斥与同步的问题，它只能被两个标准的原语wait(S)和signal(S)来访问，也可以记为“P操作”和“V操作”。 2.3.3 信号量的应用 利用信号量实现进程互斥。 利用信号量实现前趋关系。 2.3.4 管程机制虽然信号量机制是一种既方便、又有效的进程同步机制，但每个要访问临界资源的进程都必须自备同步操作 wait(S)和 signal(S)。这就使大量的同步操作分散在各个进程中。这不仅给系统的管理带来了麻烦，而且还会因同步操作的使用不当而导致系统死锁。这样，在解决上述问题的过程中，便产生了一种新的进程同步工具——管程(Monitors)。 管程的定义 代表共享资源的数据结构，以及由对该共享数据结构实施操作的一组过程所组成的资源管理程序，共同构成了一个操作系统的资源管理模块，我们称之为管程。管程被请求和释放资源的进程所调用。 2.4 进程通信（very important）进程通信，是指进程之间的信息交换，其所交换的信息量少者是一个状态或数值，多者则是成千上万个字节。进程之间的互斥和同步，由于其所交换的信息量少而被归结为低级通信。在进程互斥中，进程通过只修改信号量来向其他进程表明临界资源是否可用。 应当指出，信号量机制作为同步工具是卓有成效的，但作为通信工具，则不够理想，主要表现在下述两方面： (1) 效率低，生产者每次只能向缓冲池投放一个产品(消息)，消费者每次只能从缓冲区中取得一个消息； (2) 通信对用户不透明。 2.4.1 进程通信的类型目前，高级通信机制可归结为三大类：共享存储器系统、消息传递系统以及管道通信系统。 共享存储器系统 (1) 基于共享数据结构的通信方式。这种通信方式是低效的，只适于传递相对少量的数据。 (2) 基于共享存储区的通信方式。为了传输大量数据，在存储器中划出了一块共享存储区，诸进程可通过对共享存储区中数据的读或写来实现通信。 消息传递系统 消息传递系统(Message passing system)是当前应用最为广泛的一种进程间的通信机制。在该机制中，进程间的数据交换是以格式化的消息(message)为单位的；在计算机网络中，又把 message 称为报文。程序员直接利用操作系统提供的一组通信命令(原语)，不仅能实现大量数据的传递，而且还隐藏了通信的实现细节，使通信过程对用户是透明的，从而大大减化了通信程序编制的复杂性，因而获得了广泛的应用。 特别值得一提的是，在当今最为流行的微内核操作系统中，微内核与服务器之间的通信，无一例外地都采用了消息传递机制。又由于它能很好地支持多处理机系统、分布式系统和计算机网络，因此它也成为这些领域最主要的通信工具。消息传递系统的通信方式属于高级通信方式。又因其实现方式的不同而进一步分成直接通信方式和间接通信方式两种。 管道通信 所谓“管道”，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名 pipe 文件。向管道(共享文件)提供输入的发送进程(即写进程)，以字符流形式将大量的数据送入管道；而接受管道输出的接收进程(即读进程)，则从管道中接收(读)数据。由于发送进程和接收进程是利用管道进行通信的，故又称为管道通信。这种方式首创于UNIX 系统，由于它能有效地传送大量数据，因而又被引入到许多其它的操作系统中。 为了协调双方的通信，管道机制必须提供以下三方面的协调能力： (1) 互斥，即当一个进程正在对 pipe 执行读/写操作时，其它(另一)进程必须等待。 (2) 同步，指当写(输入)进程把一定数量(如 4 KB)的数据写入 pipe，便去睡眠等待，直到读(输出)进程取走数据后，再把它唤醒。当读进程读一空 pipe 时，也应睡眠等待，直至写进程将数据写入管道后，才将之唤醒。 (3) 确定对方是否存在，只有确定了对方已存在时，才能进行通信。 2.5 线程2.5.1 线程的基本概念 线程的引入 如果说，在操作系统中引入进程的目的，是为了使多个程序能并发执行，以提高资源利用率和系统吞吐量，那么，在操作系统中再引入线程，则是为了减少程序在并发执行时所付出的时空开销，使 OS 具有更好的并发性。 线程与进程的比较 线程具有许多传统进程所具有的特征，所以又称为轻型进程(Light-Weight Process)或进程元，相应地把传统进程称为重型进程(Heavy-Weight Process)，传统进程相当于只有一个线程的任务。在引入了线程的操作系统中，通常一个进程都拥有若干个线程，至少也有一个线程。下面我们从调度性、并发性、系统开销和拥有资源等方面对线程和进程进行比较。 (1) 调度 在传统的操作系统中，作为拥有资源的基本单位和独立调度、分派的基本单位都是进程。而在引入线程的操作系统中，则把线程作为调度和分派的基本单位，而进程作为资源拥有的基本单位，把传统进程的两个属性分开，使线程基本上不拥有资源，这样线程便能轻装前进，从而可显著地提高系统的并发程度。在同一进程中，线程的切换不会引起进程的切换，但从一个进程中的线程切换到另一个进程中的线程时，将会引起进程的切换。 (2) 并发性 在引入线程的操作系统中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间亦可并发执行，使得操作系统具有更好的并发性，从而能更加有效地提高系统资源的利用率和系统的吞吐量。 (3) 拥有资源 不论是传统的操作系统，还是引入了线程的操作系统，进程都可以拥有资源，是系统中拥有资源的一个基本单位。一般而言，线程自己不拥有系统资源(也有一点必不可少的资源)，但它可以访问其隶属进程的资源，即一个进程的代码段、数据段及所拥有的系统资源，如已打开的文件、I/O 设备等，可以供该进程中的所有线程所共享。 (4) 系统开销 在创建或撤消进程时，系统都要为之创建和回收进程控制块，分配或回收资源，如内存空间和 I/O 设备等，操作系统所付出的开销明显大于线程创建或撤消时的开销。 线程的属性 (1) 轻型实体。线程中的实体基本上不拥有系统资源，只是有一点必不可少的、 能保证其独立运行的资源，比如，在每个线程中都应具有一个用于控制线程运行的线程控制块TCB，用于指示被执行指令序列的程序计数器，保留局部变量、少数状态参数和返回地址等的一组寄存器和堆栈。 (2) 独立调度和分派的基本单位。在多线程 OS 中，线程是能独立运行的基本单位，因而也是独立调度和分派的基本单位。由于线程很“轻”，故线程的切换非常迅速且开销小。 (3) 可并发执行。在一个进程中的多个线程之间可以并发执行，甚至允许在一个进程中的所有线程都能并发执行；同样，不同进程中的线程也能并发执行。 (4) 共享进程资源。在同一进程中的各个线程都可以共享该进程所拥有的资源，这首先表现在所有线程都具有相同的地址空间(进程的地址空间)。这意味着线程可以访问该地址空间中的每一个虚地址；此外，还可以访问进程所拥有的已打开文件、定时器、信号量机构等。 2.6 线程间的同步和通信 互斥锁 互斥锁是一种比较简单的、用于实现线程间对资源互斥访问的机制。由于操作互斥锁的时间和空间开销都较低，因而较适合于高频度使用的关键共享数据和程序段。 条件变量 在许多情况下，只利用 mutex 来实现互斥访问可能会引起死锁，每一个条件变量通常都与一个互斥锁一起使用，亦即，在创建一个互斥锁时便联系着一个条件变量。单纯的互斥锁用于短期锁定，主要是用来保证对临界区的互斥进入。而条件变量则用于线程的长期等待，直至所等待的资源成为可用的资源。 信号量机制 前面所介绍的用于实现进程同步的最常用工具——信号量机制，也可用于多线程 OS中，实现诸线程或进程之间的同步。为了提高效率，可为线程和进程分别设置相应的信号量。 第三章 处理机调度与死锁3.1 调度算法3.1.1 先来先服务和短作业(进程)优先调度算法 先来先服务调度算法 先来先服务(FCFS)调度算法是一种最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。 在进程调度中采用 FCFS 算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。FCFS 算法比较有利于长作业(进程)，而不利于短作业(进程)。 短作业（进程）优先调度算法 短作业(进程)优先调度算法 SJ(P)F，是指对短作业或短进程优先调度的算法。它们可以分别用于作业调度和进程调度。短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。 SJ(P)F 调度算法也存在不容忽视的缺点： (1) 该算法对长作业不利，如作业 C 的周转时间由 10 增至 16，其带权周转时间由 2 增至 3.1。更严重的是，如果有一长作业(进程)进入系统的后备队列(就绪队列)，由于调度程序总是优先调度那些(即使是后进来的)短作业(进程)，将导致长作业(进程)长期不被调度。 (2) 该算法完全未考虑作业的紧迫程度，因而不能保证紧迫性作业(进程)会被及时处理。 (3) 由于作业(进程)的长短只是根据用户所提供的估计执行时间而定的，而用户又可能会有意或无意地缩短其作业的估计运行时间，致使该算法不一定能真正做到短作业优先调度。 3.1.2 高优先权优先调度算法 优先权调度算法的类型 为了照顾紧迫型作业，使之在进入系统后便获得优先处理，引入了最高优先权优先(FPF)调度算法。此算法常被用于批处理系统中，作为作业调度算法，也作为多种操作系统中的进程调度算法，还可用于实时系统中。当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程，这时，又可进一步把该算法分成如下两种。 (1) 非抢占式优先权算法 在这种方式下，系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时，系统方可再将处理机重新分配给另一优先权最高的进程。这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。 (2) 抢占式优先权调度算法 在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。 显然，这种抢占式的优先权调度算法能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。 优先权的类型 (1) 静态优先权 静态优先权是在创建进程时确定的，且在进程的整个运行期间保持不变。 确定进程优先权的依据有如下三个方面： ① 进程类型。通常，系统进程(如接收进程、对换进程、磁盘 I/O 进程)的优先权高于一般用户进程的优先权。 ② 进程对资源的需求。如进程的估计执行时间及内存需要量的多少，对这些要求少的进程应赋予较高的优先权。 ③ 用户要求。这是由用户进程的紧迫程度及用户所付费用的多少来确定优先权的。 静态优先权法简单易行，系统开销小，但不够精确，很可能出现优先权低的作业(进程)长期没有被调度的情况。因此，仅在要求不高的系统中才使用静态优先权。 (2) 动态优先权 动态优先权是指在创建进程时所赋予的优先权，是可以随进程的推进或随其等待时间的增加而改变的，以便获得更好的调度性能。 高响应比优先调度算法 如果我们能为每个作业引入前面所述的动态优先权，并使作业的优先级随着等待时间的增加而以速率 a 提高，则长作业在等待一定的时间后，必然有机会分配到处理机。该优先权的变化规律可描述为： 优先权 = (等待时间 + 要求服务时间) / 要求服务时间 由于等待时间与服务时间之和就是系统对该作业的响应时间，故该优先权又相当于响应比 RP。据此，又可表示为： RP = (等待时间 + 要求服务时间) / 要求服务时间 = 响应时间 / 要求服务时间 由上式可以看出： (1) 如果作业的等待时间相同，则要求服务的时间愈短，其优先权愈高，因而该算法有利于短作业。 (2) 当要求服务的时间相同时，作业的优先权决定于其等待时间，等待时间愈长，其优先权愈高，因而它实现的是先来先服务。 (3) 对于长作业，作业的优先级可以随等待时间的增加而提高，当其等待时间足够长时，其优先级便可升到很高，从而也可获得处理机。 简言之，该算法既照顾了短作业，又考虑了作业到达的先后次序，不会使长作业长期得不到服务。因此，该算法实现了一种较好的折衷。当然，在利用该算法时，每要进行调度之前，都须先做响应比的计算，这会增加系统开销。 3.1.3 基于时间片的轮转调度算法在早期，分时系统中采用的是简单的时间片轮转法；进入 20 世纪 90年代后，广泛采用多级反馈队列调度算法 时间片轮转法 在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把 CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几 ms 到几百 ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间。换言之，系统能在给定的时间内响应所有用户的请求。 多级反馈队列调度算法 前面介绍的各种用作进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程，而且如果并未指明进程的长度，则短进程优先和基于进程长度的抢占式调度算法都将无法使用。而多级反馈队列调度算法则不必事先知道各种进程所需的执行时间，而且还可以满足各种类型进程的需要，因而它是目前被公认的一种较好的进程调度算法。在采用多级反馈队列调度算法的系统中，调度算法的实施过程如下所述。 (1) 应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，……，第 i+1 个队列的时间片要比第 i 个队列的时间片长一倍。图 3-7 是多级反馈队列算法的示意。 (2) 当一个新进程进入内存后，首先将它放入第一队列的末尾，按 FCFS 原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按 FCFS原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第 n 队列后，在第 n 队列中便采取按时间片轮转的方式运行。 (3) 仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第 1～(i-1)队列均空时，才会调度第 i 队列中的进程运行。如果处理机正在第 i 队列中为某进程服务时，又有新进程进入优先权较高的队列(第 1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第 i 队列的末尾，把处理机分配给新到的高优先权进程。 多级反馈队列调度算法的性能 多级反馈队列调度算法具有较好的性能，能很好地满足各种类型用户的需要。 (1) 终端型作业用户。由于终端型作业用户所提交的作业大多属于交互型作业，作业通常较小，系统只要能使这些作业(进程)在第一队列所规定的时间片内完成，便可使终端型作业用户都感到满意。 (2) 短批处理作业用户。对于很短的批处理型作业，开始时像终端型作业一样，如果仅在第一队列中执行一个时间片即可完成，便可获得与终端型作业一样的响应时间。对于稍长的作业，通常也只需在第二队列和第三队列各执行一个时间片即可完成，其周转时间仍然较短。 (3) 长批处理作业用户。对于长作业，它将依次在第 1，2，…，n 个队列中运行，然后再按轮转方式运行，用户不必担心其作业长期得不到处理。 3.2 实时调度由于在实时系统中都存在着若干个实时进程或任务，它们用来反应或控制某个(些)外部事件，往往带有某种程度的紧迫性，因而对实时系统中的调度提出了某些特殊要求。前面所介绍的多种调度算法并不能很好地满足实时系统对调度的要求，为此，需要引入一种新的调度，即实时调度。 3.2.1 实现实时调度的基本条件1．提供必要的信息 (1) 就绪时间。这是该任务成为就绪状态的起始时间，在周期任务的情况下，它就是事先预知的一串时间序列；而在非周期任务的情况下，它也可能是预知的。 (2) 开始截止时间和完成截止时间。对于典型的实时应用，只须知道开始截止时间，或者知道完成截止时间。 (3) 处理时间。这是指一个任务从开始执行直至完成所需的时间。在某些情况下，该时间也是系统提供的。 (4) 资源要求。这是指任务执行时所需的一组资源。 (5) 优先级。如果某任务的开始截止时间已经错过，就会引起故障，则应为该任务赋予“绝对”优先级；如果开始截止时间的推迟对任务的继续运行无重大影响，则可为该任务赋予“相对”优先级，供调度程序参考。 处理能力强 在实时系统中，通常都有着多个实时任务。若处理机的处理能力不够强，则有可能因处理机忙不过来而使某些实时任务不能得到及时处理，从而导致发生难以预料的后果。 采用抢占式调度机制 在含有硬实时任务的实时系统中，广泛采用抢占机制。当一个优先权更高的任务到达时，允许将当前任务暂时挂起，而令高优先权任务立即投入运行，这样便可满足该硬实时任务对截止时间的要求。但这种调度机制比较复杂。 对于一些小型实时系统，如果能预知任务的开始截止时间，则对实时任务的调度可采用非抢占调度机制，以简化调度程序和对任务调度时所花费的系统开销。但在设计这种调度机制时，应使所有的实时任务都比较小，并在执行完关键性程序和临界区后，能及时地将自己阻塞起来，以便释放出处理机，供调度程序去调度那种开始截止时间即将到达的任务。 具有快速切换机制 为保证要求较高的硬实时任务能及时运行，在实时系统中还应具有快速切换机制，以保证能进行任务的快速切换。该机制应具有如下两方面的能力： (1) 对外部中断的快速响应能力。 (2) 快速的任务分派能力。 3.2.2 常用的几种实时调度算法1．最早截止时间优先即 EDF(Earliest Deadline First)算法 该算法是根据任务的开始截止时间来确定任务的优先级。截止时间愈早，其优先级愈高。该算法要求在系统中保持一个实时任务就绪队列，该队列按各任务截止时间的早晚排序；当然，具有最早截止时间的任务排在队列的最前面。调度程序在选择任务时，总是选择就绪队列中的第一个任务，为之分配处理机，使之投入运行。最早截止时间优先算法既可用于抢占式调度，也可用于非抢占式调度方式中。 2．最低松弛度优先即 LLF(Least Laxity First)算法 该算法是根据任务紧急(或松弛)的程度，来确定任务的优先级。任务的紧急程度愈高，为该任务所赋予的优先级就愈高，以使之优先执行。 3.3 产生死锁的原因和必要条件3.3.1 产生死锁的原因产生死锁的原因可归结为如下两点： (1) 竞争资源。当系统中供多个进程共享的资源如打印机、公用队列等，其数目不足以满足诸进程的需要时，会引起诸进程对资源的竞争而产生死锁。 (2) 进程间推进顺序非法。进程在运行过程中，请求和释放资源的顺序不当，也同样会导致产生进程死锁。 3.3.2 产生死锁的必要条件死锁的发生必须具备下列四个必要条件。 (1) 互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求该资源，则请求者只能等待，直至占有该资源的进程用毕释放。 (2) 请求和保持条件：指进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。 (3) 不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。 (4) 环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，…，Pn}中的 P0正在等待一个 P1占用的资源； P1正在等待 P2占用的资源，……，Pn正在等待已被 P0占用的资源。 3.3.3 处理死锁的基本方法预防，避免，检测，解除 3.4 预防死锁的方法3.4.1 预防死锁预防死锁的方法是使四个必要条件中的第 2、3、4 个条件之一不能成立，来避免发生死锁。至于必要条件 1，因为它是由设备的固有特性所决定的，不仅不能改变，还应加以保证。 摒弃“请求和保持”条件 在采用这种方法时，系统规定所有进程在开始运行之前，都必须一次性地申请其在整个运行过程所需的全部资源。此时，若系统有足够的资源分配给某进程，便可把其需要的所有资源分配给该进程，这样，该进程在整个运行期间便不会再提出资源要求，从而摒弃了请求条件。 这种预防死锁的方法其优点是简单、易于实现且很安全。但其缺点却也极其明显：首先表现为资源被严重浪费，其次是使进程延迟运行，仅当进程在获得了其所需的全部资源后，才能开始运行，但可能因有些资源已长期被其它进程占用而致使等待该资源的进程迟迟不能运行。 摒弃“不剥夺”条件 在采用这种方法时系统规定，进程是逐个地提出对资源的要求的。当一个已经保持了某些资源的进程，再提出新的资源请求而不能立即得到满足时，必须释放它已经保持了的所有资源，待以后需要时再重新申请。这意味着某一进程已经占有的资源，在运行过程中会被暂时地释放掉，也可认为是被剥夺了，从而摒弃了“不剥夺”条件。 这种预防死锁的方法实现起来比较复杂且要付出很大的代价。此外，这种策略还可能因为反复地申请和释放资源，致使进程的执行被无限地推迟，这不仅延长了进程的周转时间，而且也增加了系统开销，降低了系统吞吐量。 摒弃“环路等待”条件 这种方法中规定，系统将所有资源按类型进行线性排队，并赋予不同的序号。例如，令输入机的序号为 1，打印机的序号为 2，磁带机为 3，磁盘为 4。所有进程对资源的请求必须严格按照资源序号递增的次序提出，这样，在所形成的资源分配图中，不可能再出现环路，因而摒弃了“环路等待”条件。 首先是为系统中各类资源所分配(确定)的序号必须相对稳定，这就限制了新类型设备的增加。为方便用户，系统对用户在编程时所施加的限制条件应尽量少。然而这种按规定次序申请的方法，必然会限制用户简单、自主地编程。 3.4.2 系统安全状态在该方法中把系统的状态分为安全状态和不安全状态，只要能使系统始终都处于安全状态，便可避免发生死锁。 安全状态 所谓安全状态，是指系统能按某种进程顺序(P1，P2，…，Pn)(称〈P1，P2，…，Pn〉序列为安全序列)，来为每个进程 Pi分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成。如果系统无法找到这样一个安全序列，则称系统处于不安全状态。 虽然并非所有的不安全状态都必然会转为死锁状态，但当系统进入不安全状态后，便有可能进而进入死锁状态；反之，只要系统处于安全状态，系统便可避免进入死锁状态。因此，避免死锁的实质在于：系统在进行资源分配时，如何使系统不进入不安全状态。 3.5 死锁的检测与解除3.5.1 死锁的解除当发现有进程死锁时，便应立即把它们从死锁状态中解脱出来。常采用解除死锁的两种方法是： (1) 剥夺资源。从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态。 (2) 撤消进程。最简单的撤消进程的方法是使全部死锁进程都夭折掉；稍微温和一点的方法是按照某种顺序逐个地撤消进程，直至有足够的资源可用，使死锁状态消除为止。 第四章 存储器管理4.1 存储器的层次结构4.1.1 多级存储器结构对于通用计算机而言，存储层次至少应具有三级：最高层为 CPU 寄存器，中间为主存，最底层是辅存。在较高档的计算机中，还可以根据具体的功能分工细划为寄存器、高速缓存、主存储器、磁盘缓存、固定磁盘、可移动存储介质等 6 层。如图 4-1 所示，在存储层次中越往上，存储介质的访问速度越快，价格也越高，相对存储容量也越小。其中，寄存器、高速缓存、主存储器和磁盘缓存均属于操作系统存储管理的管辖范畴，掉电后它们存储的信息不再存在。固定磁盘和可移动存储介质属于设备管理的管辖范畴，它们存储的信息将被长期保存。 4.1.2 主存储器与寄存器 主存储器 主存储器(简称内存或主存)是计算机系统中一个主要部件，用于保存进程运行时的程序和数据，也称可执行存储器，CPU的控制部件只能从主存储器中取得指令和数据，数据能够从主存储器读取并将它们装入到寄存器中，或者从寄存器存入到主存储器。CPU 与外围设备交换的信息一般也依托于主存储器地址空间。由于主存储器的访问速度远低于 CPU 执行指令的速度，为缓和这一矛盾，在计算机系统中引入了寄存器和高速缓存。 寄存器 寄存器访问速度最快，完全能与 CPU 协调工作，但价格却十分昂贵，因此容量不可能做得很大。寄存器的长度一般以字(word)为单位。寄存器用于加速存储器的访问速度，如用寄存器存放操作数，或用作地址寄存器加快地址转换速度等。 4.1.3 高速缓存和磁盘缓存 高速缓存 高速缓存是现代计算机结构中的一个重要部件，其容量大于或远大于寄存器，而比内存约小两到三个数量级左右，从几十 KB 到几 MB，访问速度快于主存储器。 根据程序执行的局部性原理(即程序在执行时将呈现出局部性规律，在一较短的时间内，程序的执行仅局限于某个部分)，将主存中一些经常访问的信息存放在高速缓存中，减少访问主存储器的次数，可大幅度提高程序执行速度。通常，进程的程序和数据是存放在主存储器中，每当使用时，被临时复制到一个速度较快的高速缓存中。当 CPU 访问一组特定信息时，首先检查它是否在高速缓存中，如果已存在，可直接从中取出使用，以避免访问主存，否则，再从主存中读出信息。 磁盘缓存 由于目前磁盘的 I/O 速度远低于对主存的访问速度，因此将频繁使用的一部分磁盘数据和信息，暂时存放在磁盘缓存中，可减少访问磁盘的次数。磁盘缓存本身并不是一种实际存在的存储介质，它依托于固定磁盘，提供对主存储器存储空间的扩充，即利用主存中的存储空间，来暂存从磁盘中读出(或写入)的信息。主存也可以看做是辅存的高速缓存，因为，辅存中的数据必须复制到主存方能使用；反之，数据也必须先存在主存中，才能输出到辅存。 4.2 程序的装入和链接在多道程序环境下，要使程序运行，必须先为之创建进程。而创建进程的第一件事，便是将程序和数据装入内存。如何将一个用户源程序变为一个可在内存中执行的程序，通常都要经过以下几个步骤：首先是要编译，由编译程序(Compiler)将用户源代码编译成若干个目标模块(Object Module)；其次是链接，由链接程序(Linker)将编译后形成的一组目标模块，以及它们所需要的库函数链接在一起，形成一个完整的装入模块(Load Module)；最后是装入，由装入程序(Loader)将装入模块装入内存。 4.2.1 程序的装入 绝对装入方式 在编译时，如果知道程序将驻留在内存的什么位置，那么，编译程序将产生绝对地址的目标代码。 绝对装入程序按照装入模块中的地址，将程序和数据装入内存。装入模块被装入内存后，由于程序中的逻辑地址与实际内存地址完全相同，故不须对程序和数据的地址进行修改。 可重定位装入方式 在多道程序环境下，所得到的目标模块的起始地址通常是从 0 开始的，程序中的其它地址也都是相对于起始地址计算的。此时应采用可重定位装入方式，根据内存的当前情况，将装入模块装入到内存的适当位置。 通常是把在装入时对目标程序中指令和数据的修改过程称为重定位。又因为地址变换通常是在装入时一次完成的，以后不再改变，故称为静态重定位。 动态运行时装入方式 动态运行时的装入程序在把装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序真正要执行时才进行。因此，装入内存后的所有地址都仍是相对地址。为使地址转换不影响指令的执行速度，这种方式需要一个重定位寄存器的支持。 4.2.2 程序的链接源程序经过编译后，可得到一组目标模块，再利用链接程序将这组目标模块链接，形成装入模块。根据链接时间的不同，可把链接分成如下三种： (1) 静态链接。在程序运行之前，先将各目标模块及它们所需的库函数，链接成一个完整的装配模块，以后不再拆开。我们把这种事先进行链接的方式称为静态链接方式。 (2) 装入时动态链接。这是指将用户源程序编译后所得到的一组目标模块，在装入内存时，采用边装入边链接的链接方式。 (3) 运行时动态链接。这是指对某些目标模块的链接，是在程序执行中需要该(目标)模块时，才对它进行的链接。 4.3 连续分配方式连续分配方式，是指为一个用户程序分配一个连续的内存空间。 4.3.1 单一连续分配这是最简单的一种存储管理方式，但只能用于单用户、单任务的操作系统中。采用这种存储管理方式时，可把内存分为系统区和用户区两部分，系统区仅提供给 OS 使用，通常是放在内存的低址部分；用户区是指除系统区以外的全部内存空间，提供给用户使用。 4.3.2 固定分区分配固定分区式分配是最简单的一种可运行多道程序的存储管理方式。这是将内存用户空间划分为若干个固定大小的区域，在每个分区中只装入一道作业，这样，把用户空间划分为几个分区，便允许有几道作业并发运行。当有一空闲分区时，便可以再从外存的后备作业队列中选择一个适当大小的作业装入该分区，当该作业结束时，又可再从后备作业队列中找出另一作业调入该分区。 划分分区的方法 (1) 分区大小相等，即使所有的内存分区大小相等。其缺点是缺乏灵活性，即当程序太小时，会造成内存空间的浪费；当程序太大时，一个分区又不足以装入该程序，致使该程序无法运行。 (2) 分区大小不等。为了克服分区大小相等而缺乏灵活性的这个缺点，可把内存区划分成含有多个较小的分区、适量的中等分区及少量的大分区。这样，便可根据程序的大小为之分配适当的分区。 内存分配 为了便于内存分配，通常将分区按大小进行排队，并为之建立一张分区使用表，其中各表项包括每个分区的起始地址、大小及状态(是否已分配)，见图 4-5(a)所示。当有一用户程序要装入时，由内存分配程序检索该表，从中找出一个能满足要求的、尚未分配的分区，将之分配给该程序，然后将该表项中的状态置为“已分配”；若未找到大小足够的分区，则拒绝为该用户程序分配内存。存储空间分配情况如图 4-5(b)所示。 4.3.3 动态分区分配 分区分配算法 (1) 首次适应算法(first fit) 我们以空闲分区链为例来说明采用 FF 算法时的分配情况。FF 算法要求空闲分区链以地址递增的次序链接。在分配内存时，从链首开始顺序查找，直至找到一个大小能满足要求的空闲分区为止；然后再按照作业的大小，从该分区中划出一块内存空间分配给请求者，余下的空闲分区仍留在空闲链中。若从链首直至链尾都不能找到一个能满足要求的分区，则此次内存分配失败，返回。该算法倾向于优先利用内存中低址部分的空闲分区，从而保留了高址部分的大空闲区。这给为以后到达的大作业分配大的内存空间创造了条件。其缺点是低址部分不断被划分，会留下许多难以利用的、很小的空闲分区，而每次查找又都是从低址部分开始，这无疑会增加查找可用空闲分区时的开销。 (2) 循环首次适应算法(next fit) 该算法是由首次适应算法演变而成的。在为进程分配内存空间时，不再是每次都从链首开始查找，而是从上次找到的空闲分区的下一个空闲分区开始查找，直至找到一个能满足要求的空闲分区，从中划出一块与请求大小相等的内存空间分配给作业。为实现该算法，应置一起始查寻指针，用于指示下一次起始查寻的空闲分区，并采用循环查找方式，即如果最后一个(链尾)空闲分区的大小仍不能满足要求，则应返回到第一个空闲分区，比较其大小是否满足要求。找到后，应调整起始查寻指针。该算法能使内存中的空闲分区分布得更均匀，从而减少了查找空闲分区时的开销，但这样会缺乏大的空闲分区。 (3) 最佳适应算法(best fit) 所谓“最佳”是指每次为作业分配内存时，总是把能满足要求、又是最小的空闲分区分配给作业，避免“大材小用”。为了加速寻找，该算法要求将所有的空闲分区按其容量以从小到大的顺序形成一空闲分区链。这样，第一次找到的能满足要求的空闲区，必然是最佳的。孤立地看，最佳适应算法似乎是最佳的，然而在宏观上却不一定。因为每次分配后所切割下来的剩余部分总是最小的，这样，在存储器中会留下许多难以利用的小空闲区。 (4) 最坏适应算法(worst fit) 最坏适应分配算法要扫描整个空闲分区表或链表，总是挑选一个最大的空闲区分割给作业使用，其优点是可使剩下的空闲区不至于太小，产生碎片的几率最小，对中、小作业有利，同时最坏适应分配算法查找效率很高。该算法要求将所有的空闲分区按其容量以从大到小的顺序形成一空闲分区链，查找时只要看第一个分区能否满足作业要求。但是该算法的缺点也是明显的，它会使存储器中缺乏大的空闲分区。最坏适应算法与前面所述的首次适应算法、循环首次适应算法、最佳适应算法一起，也称为顺序搜索法。 (5) 快速适应算法(quick fit) 该算法又称为分类搜索法，是将空闲分区根据其容量大小进行分类，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表，这样，系统中存在多个空闲分区链表，同时在内存中设立一张管理索引表，该表的每一个表项对应了一种空闲分区类型，并记录了该类型空闲分区链表表头的指针。空闲分区的分类是根据进程常用的空间大小进行划分，如 2 KB、4 KB、8 KB 等，对于其它大小的分区，如 7 KB 这样的空闲区，既可以放在 8 KB 的链表中，也可以放在一个特殊的空闲区链表中。 该算法的优点是查找效率高，仅需要根据进程的长度，寻找到能容纳它的最小空闲区链表，并取下第一块进行分配即可。另外该算法在进行空闲分区分配时，不会对任何分区产生分割，所以能保留大的分区，满足对大空间的需求，也不会产生内存碎片。该算法的缺点是在分区归还主存时算法复杂，系统开销较大。此外，该算法在分配空闲分区时是以进程为单位，一个分区只属于一个进程，因此在为进程所分配的一个分区中，或多或少地存在一定的浪费。空闲分区划分越细，浪费则越严重，整体上会造成可观的存储空间浪费，这是典型的以空间换时间的作法。 分区分配操作 (1) 分配内存 系统应利用某种分配算法，从空闲分区链(表)中找到所需大小的分区。 (2) 回收内存 4.3.4 可重定位分区分配 动态重定位的引入 在连续分配方式中，必须把一个系统或用户程序装入一连续的内存空间。如果在系统中只有若干个小的分区，即使它们容量的总和大于要装入的程序，但由于这些分区不相邻接，也无法把该程序装入内存。 若想把作业装入，可采用的一种方法是：将内存中的所有作业进行移动，使它们全都相邻接，这样，即可把原来分散的多个小分区拼接成一个大分区，这时就可把作业装入该区。这种通过移动内存中作业的位置，以把原来多个分散的小分区拼接成一个大分区的方法，称为“拼接”或“紧凑”，见图 4-9(b)。由于经过紧凑后的某些用户程序在内存中的位置发生了变化，此时若不对程序和数据的地址加以修改(变换)，则程序必将无法执行。为此，在每次“紧凑”后，都必须对移动了的程序或数据进行重定位。 动态重定位的实现 在动态运行时装入的方式中，作业装入内存后的所有地址都仍然是相对地址，将相对地址转换为物理地址的工作，被推迟到程序指令要真正执行时进行。为使地址的转换不会影响到指令的执行速度，必须有硬件地址变换机构的支持，即须在系统中增设一个重定位寄存器，用它来存放程序(数据)在内存中的起始地址。程序在执行时，真正访问的内存地址是相对地址与重定位寄存器中的地址相加而形成的。 动态重定位分区分配算法 动态重定位分区分配算法与动态分区分配算法基本上相同，差别仅在于：在这种分配算法中，增加了紧凑的功能，通常，在找不到足够大的空闲分区来满足用户需求时进行紧凑。 4.3.5 对换 对换的引入 所谓“对换”，是指把内存中暂时不能运行的进程或者暂时不用的程序和数据调出到外存上，以便腾出足够的内存空间，再把已具备运行条件的进程或进程所需要的程序和数据调入内存。对换是提高内存利用率的有效措施。 如果对换是以整个进程为单位的，便称之为“整体对换”或“进程对换”。 而如果对换是以“页”或“段”为单位进行的，则分别称之为“页面对换”或“分段对换”，又统称为“部分对换”。 对换空间的管理 在具有对换功能的 OS 中，通常把外存分为文件区和对换区。前者用于存放文件，后者用于存放从内存换出的进程。 故对文件区管理的主要目标，是提高文件存储空间的利用率。对对换空间管理的主要目标，是提高进程换入和换出的速度。 由于对换分区的分配是采用连续分配方式，因而对换空间的分配与回收，与动态分区方式时的内存分配与回收方法雷同。其分配算法可以是首次适应算法、循环首次适应算法或最佳适应算法。具体的分配操作，也与内存的分配过程相同，这里不再赘述。 进程的换入与换出 (1) 进程的换出。每当一进程由于创建子进程而需要更多的内存空间，但又无足够的内存空间等情况发生时，系统应将某进程换出。其过程是：系统首先选择处于阻塞状态且优先级最低的进程作为换出进程，然后启动磁盘，将该进程的程序和数据传送到磁盘的对换区上。 (2) 进程的换入。 系统应定时地查看所有进程的状态，从中找出“就绪”状态但已换出的进程，将其中换出时间最久(换出到磁盘上)的进程作为换入进程，将之换入，直至已无可换入的进程或无可换出的进程为止。 4.4 基本分页存储管理方式4.1.1 页面与页表 页面 (1) 页面和物理块 分页存储管理是将一个进程的逻辑地址空间分成若干个大小相等的片，称为页面或页，并为各页加以编号，从 0 开始，如第 0 页、第 1 页等。相应地，也把内存空间分成与页面相同大小的若干个存储块，称为(物理)块或页框(frame)，也同样为它们加以编号，如 0#块、1#块等等。在为进程分配内存时，以块为单位将进程中的若干个页分别装入到多个可以不相邻接的物理块中。由于进程的最后一页经常装不满一块而形成了不可利用的碎片，称之为“页内碎片”。 (2) 页面大小 在分页系统中的页面其大小应适中。页面若太小，一方面虽然可使内存碎片减小，从而减少了内存碎片的总空间，有利于提高内存利用率，但另一方面也会使每个进程占用较多的页面，从而导致进程的页表过长，占用大量内存；此外，还会降低页面换进换出的效率。然而，如果选择的页面较大，虽然可以减少页表的长度，提高页面换进换出的速度，但却又会使页内碎片增大。因此，页面的大小应选择适中，且页面大小应是 2 的幂，通常为 512 B～8 KB。 页表 在分页系统中，允许将进程的各个页离散地存储在内存不同的物理块中，但系统应能保证进程的正确运行，即能在内存中找到每个页面所对应的物理块。为此，系统又为每个进程建立了一张页面映像表，简称页表。在进程地址空间内的所有页(0～n)，依次在页表中有一页表项，其中记录了相应页在内存中对应的物理块号，见图 4-12 的中间部分。在配置了页表后，进程执行时，通过查找该表，即可找到每页在内存中的物理块号。可见，页表的作用是实现从页号到物理块号的地址映射。 4.5 基本分段存储管理方式4.5.1 分段系统的基本原理 分段 在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段定义了一组逻辑信息。 段表 在前面所介绍的动态分区分配方式中，系统为整个进程分配一个连续的内存空间。而在分段式存储管理系统中，则是为每个分段分配一个连续的分区，而进程中的各个段可以离散地移入内存中不同的分区中。为使程序能正常运行，亦即，能从物理内存中找出每个逻辑段所对应的位置，应像分页系统那样，在系统中为每个进程建立一张段映射表，简称“段表”。 分页和分段的主要区别 (1) 页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率。或者说，分页仅仅是由于系统管理的需要而不是用户的需要。段则是信息的逻辑单位，它含有一组其意义相对完整的信息。分段的目的是为了能更好地满足用户的需要。 (2) 页的大小固定且由系统决定，由系统把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而在系统中只能有一种大小的页面；而段的长度却不固定，决定于用户所编写的程序，通常由编译程序在对源程序进行编译时，根据信息的性质来划分。 (3) 分页的作业地址空间是一维的，即单一的线性地址空间，程序员只需利用一个记忆符，即可表示一个地址；而分段的作业地址空间则是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。 4.5.2 段页式存储管理方式分页系统能有效地提高内存利用率，而分段系统则能很好地满足用户需要。如果能对两种存储管理方式“各取所长”，则可以将两者结合成一种新的存储管理方式系统。这种新系统既具有分段系统的便于实现、分段可共享、易于保护、可动态链接等一系列优点，又能像分页系统那样很好地解决内存的外部碎片问题，以及可为各个分段离散地分配内存等问题。把这种结合起来形成的新系统称为“段页式系统”。 基本原理段页式系统的基本原理，是分段和分页原理的结合，即先将用户程序分成若干个段，再把每个段分成若干个页，并为每一个段赋予一个段名。 4.6 虚拟存储器的基本概念4.6.1 虚拟存储器的引入 局部性原理 (1) 时间局限性。如果程序中的某条指令一旦执行，则不久以后该指令可能再次执行；如果某数据被访问过，则不久以后该数据可能再次被访问。产生时间局限性的典型原因是由于在程序中存在着大量的循环操作。 (2) 空间局限性。一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，其典型情况便是程序的顺序执行。 虚拟存储器的定义 由上所述可以得知，所谓虚拟存储器，是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。 4.6.2 虚拟存储器的实现方法1．分页请求系统 2．请求分段系统 4.6.3 虚拟存储器的特征 多次性 多次性是指一个作业被分成多次调入内存运行，亦即在作业运行时没有必要将其全部装入，只需将当前要运行的那部分程序和数据装入内存即可。 对换性 对换性是指允许在作业的运行过程中进行换进、换出，亦即，在进程运行期间，允许将那些暂不使用的程序和数据，从内存调至外存的对换区(换出)，待以后需要时再将它们从外存调至内存(换进)；甚至还允许将暂时不运行的进程调至外存，待它们重又具备运行条件时再调入内存。 虚拟性 虚拟性是指能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量。这是虚拟存储器所表现出来的最重要的特征，也是实现虚拟存储器的最重要的目标。 4.7 请求分页存储管理方式4.8 页面置换算法","categories":[],"tags":[{"name":"Operation System","slug":"Operation-System","permalink":"https://github.com/hzsss/tags/Operation-System/"}]},{"title":"Mac OS下配置多个GitHub账号","slug":"Mac-OS下配置多个GitHub账号","date":"2018-08-01T08:07:49.000Z","updated":"2018-12-19T08:03:32.938Z","comments":true,"path":"Mac-OS下配置多个GitHub账号/","link":"","permalink":"https://github.com/hzsss/Mac-OS下配置多个GitHub账号/","excerpt":"","text":"以前在学校用的实验室的 iMac，现在大三出来实习了，给自己买了一台 MacBook Pro。之前在 GitHub 上搭建了个人博客，写写知识总结或者生活分享也还是不错的。后来到了公司，用的也是自己的电脑，刚来也不懂 Git，以前在学校也只把 GitHub 当做存放代码的地方，公司用的企业版的 GitHub，给了我一个账号，于是我傻乎乎地照着网上一顿配置，直接设置了全局的 name 和 email，给后来挖了一个坑。 本来没打算折腾的，用简书或者掘金写写博客也还是不错的。可是最近在看一些技术博客，很喜欢 bestswifter 写的文章，不是说有多高深，而是能够把知识说得很通俗易懂，他自己也说“喜欢研究问题的本质，讨厌一切不说人话的描述”。能做到这一点，想必自己对问题已经理解得很透彻了。今天偶然点开霜神的博客 一缕殇流化隐半边冰霜，糟了，是心动的感觉，也太好看了叭。于是下定决心要把博客给迁移过来。 我的博客是在 GitHub 上搭建的，但是现在电脑上只配置了公司的 GitHub 账号。于是第一步，把我以前的 GitHub 账号配置到现在这台电脑上来，而且不能与公司的产生冲突。Google 了许多教程，对于一个小白来说，而且电脑上已经配置好了公司的账号，自然不敢瞎搞。参考对比了几篇教程，都或多或少有些许遗漏，（可能对于大神来说都知道了，但对于我这种小白来说，每一步都是很重要很谨慎的）。于是根据自己的经历，给大家分享一篇相对完整的教程。废话到此为止，let’s go。 实现原理要在同一台电脑上配置两个 GitHub 账号，（GitLab，码云同理）,需要生成各自配套的 SSH Key。这样，在 clone 和 push 代码的时候，就能区分用的是哪个账号。 取消全局设定如果之前在 git config 中全局设置过用户名和邮箱，则需要先取消设置。这个用户名和邮箱是记录每一次 commit 的用户和关联的邮箱。公司和个人用的是不同的邮箱，所以应该分别设置。这里在后面再说。123git config --global --unset user.namegit config --global --unset user.email 生成 SSH Key1$ ssh-keygen -t rsa -C &quot;youremail@xxx.com&quot; 按一次回车后：12345678Generating public/private rsa key pair.Enter file in which to save the key (/Users/Shinancao/.ssh/id_rsa): id_rsa_company(取个名字)Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in id_rsa_companyYour public key has been saved in id_rsa_company.pub. 这里我首先设置的是公司的 SSH Key，使用的是公司邮箱。记得要给 SSH Key 取一个名字，不然会使用默认的名字，当后面再设置个人的 SSH Key 时，如果还使用的默认的名字，则会把前面的覆盖掉。好了，接着按上面的方式创建个人的 SSH Key，这次我取的名字是 id_rsa_personal。这样，就生成了两套 SSH Key。如果生成的 Key 不在 .ssh 文件夹中，可以拖进去。 在 GitHub 上添加 Key为了避免新手读者不知道怎么添加，在这里我还是提一下吧。在本地通过 cat ~/.ssh/ssh_key_name.pub 获取公钥的内容，复制，然后登录 GitHub 账号，点击 Settings-&gt;SSH and GPG keys&gt;New SSH Key 进行添加。 在本地 SSH Agent 中添加 Key只有在本地的 SSH Agent 中添加了 Key，这样 SSH 服务器才能找到 id_rsa。123ssh-add -K ~/.ssh/id_rsa_personalssh-add -K ~/.ssh/id_rsa_company 修改 SSH config 文件config 文件不是默认生产的，有些人可能会没有，所以可以先创建一个。先进入到 .ssh 文件中cd ~/.ssh，然后执行 touch config进行创建。 打开刚才创建好的 config 文件，然后在里面添加如下内容：1234567891011# personalHost personal.github.comHostName github.comUser gitIdentityFile ~/.ssh/id_rsa# companyHost company.github.com # 这个名字可任意设置HostName github.comUser gitIdentityFile ~/.ssh/id_rsa_work OK，现在让我们测试一下配置是否成功：123ssh -T git@personal.github.comssh -T git@company.github.com 如果输出以下内容：1Hi xxx! You&apos;ve successfully authenticated 恭喜你，已经配置成功了！慢着慢着，刚才把全局设置给取消了，现在是不是要单独设置回来，没错，取消了全局设置的用户和邮箱后，我们要为每一个项目进行单独设置。我先给大家讲一下现在该如何对项目进行设置。 最后一步由于我们设置了 Host，这就相当于是 HostName 的别名。比如现在对个人 GitHub 上的 repo 进行 clone 的时候，要改成 git clone git@personal.github.com:xxx/xxx.git。如果是已经克隆到本地的项目，则可以在项目中修改：123$ git remote rm origin$ git remote add origin git@personal.github.com:xxx/xxx.git 可以执行 git remote -v 查看是否修改成功。 然后在每个项目中，执行：123git config user.email &quot;xxx@xxx.com&quot;git config user.name &quot;xxname&quot; 对公司和个人项目单独设置用户名和邮箱。可以查看一下：123git config user.namegit config user.email push 的话还是照常使用：git push origin master 好啦，全部设置完了，终于可以继续把我 GitHub 上的博客迁移过来了。 迁移的教程：使用hexo，如果换了电脑怎么更新博客？ 再贴一个我的个人博客：hzsss","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"https://github.com/hzsss/tags/技术/"}]},{"title":"在 Mac OSX 上安装 Oh My Zsh","slug":"在-Mac-OSX-上安装-Oh-My-Zsh","date":"2018-07-16T08:05:37.000Z","updated":"2018-12-19T08:15:29.882Z","comments":true,"path":"在-Mac-OSX-上安装-Oh-My-Zsh/","link":"","permalink":"https://github.com/hzsss/在-Mac-OSX-上安装-Oh-My-Zsh/","excerpt":"","text":"安装 Oh My Zsh1、切换到 zshMac OSX默认使用的是 bash shell，使用chsh -s /bin/zsh命令切换至 zsh2、使用curl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh进行安装12345678910111213141516171819202122232425262728293031% Total % Received % Xferd Average Speed Time Time Time CurrentDload Upload Total Spent Left Speed0 0 0 0 0 0 0 0 --:--:-- 0:00:02 --:--:-- 0100 3952 100 3952 0 0 821 0 0:00:04 0:00:04 --:--:-- 4272Cloning Oh My Zsh...Cloning into &apos;/Users/huangzishan/.oh-my-zsh&apos;...remote: Counting objects: 883, done.remote: Compressing objects: 100% (746/746), done.remote: Total 883 (delta 16), reused 784 (delta 10), pack-reused 0Receiving objects: 100% (883/883), 585.10 KiB | 693.00 KiB/s, done.Resolving deltas: 100% (16/16), done.Looking for an existing zsh config...Using the Oh My Zsh template file and adding it to ~/.zshrcTime to change your default shell to zsh!Changing shell for huangzishan.Password for huangzishan: chsh: no changes made__ __ ____ / /_ ____ ___ __ __ ____ _____/ /_ / __ \\/ __ \\ / __ `__ \\/ / / / /_ / / ___/ __ \\ / /_/ / / / / / / / / / / /_/ / / /_(__ ) / / / \\____/_/ /_/ /_/ /_/ /_/\\__, / /___/____/_/ /_/ /____/ ....is now installed!Please look over the ~/.zshrc file to select plugins, themes, and options.p.s. Follow us at https://twitter.com/ohmyzsh.p.p.s. Get stickers and t-shirts at https://shop.planetargon.com. 配置 Oh My Zsh1、使用vi ~/.zshrc打开配置文件2、在Oh My Zsh主题展示网站 ，选择喜欢的主题进行更改。这里使用的是 vim 来打开的配置文件，所以需要按字母 i 进行插入,然后把光标移动到 ZSH_THEME 这行,更改主题键值对，例如：ZSH_THEME=”agnoster” ，按 ESC 键后， 键入 :wq 保存退出。3、关闭终端，重新打开，键入 ls,效果如下：","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"https://github.com/hzsss/tags/技术/"}]},{"title":"weak原理探索","slug":"weak原理探索","date":"2018-06-15T07:56:48.000Z","updated":"2018-12-19T09:33:50.870Z","comments":true,"path":"weak原理探索/","link":"","permalink":"https://github.com/hzsss/weak原理探索/","excerpt":"","text":"weak 指针weak是弱引用，所引用对象的计数器不会加一，并在引用对象被释放的时候自动被设置为nil。通常用于解决循环引用问题。 weak 表runtime 维护了一个 weak 表，用于存储指向某个对象的所有 weak 指针。weak 表是一个 hash 表： weak 实现原理1、初始化时：runtime 会调用 objc_initWeak() 函数，objc_initWeak() 函数会初始化一个新的 weak 指针指向对象的地址。12// object 是要初始化的指针，value 是指针指向的对象id objc_initWeak(id *object, id value); objc_initWeak() 方法的实现如下：123456789101112id objc_initWeak(id *location, id newObj) &#123; // 查看对象实例是否有效 // 无效对象直接导致指针释放 if (!newObj) &#123; *location = nil; return nil; &#125; // 这里传递了三个 bool 数值 // 使用 template 进行常量参数传递是为了优化性能 return storeWeakfalse/*old*/, true/*new*/, true/*crash*/&gt; (location, (objc_object*)newObj);&#125; 这里判断了其指针指向的对象是否有效，无效则直接释放，不再往调用深层函数。若有效，则调用 objc_storeWeak() 函数，要被初始化的指针（object）将被注册为一个指向对象（value）的 __weak 指针对象。 objc_initWeak() 函数有一个前提条件：就是 object 必须是一个没有被注册为__weak 对象的有效指针。而 value 则可以是 null，或者指向一个有效的对象。 2、添加引用时：objc_initWeak() 函数会调用 objc_storeWeak() 函数， objc_storeWeak() 的作用是更新指针指向，创建对应的弱引用表。1id objc_storeWeak(id *location, id value); 1）创建 weak 弱引用表2）解除旧对象的弱引用表3）将新的弱引用表与对象进行关联绑定 3、释放时，调用 clearDeallocating 函数。clearDeallocating 函数首先根据对象地址获取所有 weak 指针地址的数组，然后遍历这个数组把其中的数据设为 nil，最后把这个 entry 从 weak 表中删除，最后清理对象的记录。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://github.com/hzsss/tags/iOS/"}]},{"title":"关于__block的一些思考","slug":"关于-block的一些思考","date":"2018-06-15T07:48:51.000Z","updated":"2018-12-19T09:39:31.541Z","comments":true,"path":"关于-block的一些思考/","link":"","permalink":"https://github.com/hzsss/关于-block的一些思考/","excerpt":"","text":"参考文章你真的理解__block修饰符的原理么？ 深入研究Block捕获外部变量和__block实现原理 Block 的实现1234567891011// Block 源码int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; void (^blk)(void) = ^&#123; printf(\"Block\\n\"); &#125;; blk(); &#125; return 0;&#125; 使用 clang 命令将源码改成编译后的 C/C++ 语言：1234567891011121314151617181920212223242526272829struct __main_block_impl_0 &#123; // block 对象 struct __block_impl impl; // 包含 block 的实现 struct __main_block_desc_0* Desc; // 包含了 block 的内存管理 __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123; // 构造函数 impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; // block 中的代码，包含 __main_block_func_0 方法 Desc = desc; &#125;&#125;;// block 中的代码，传入 block 以便获取其中的捕获的值或变量static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; printf(\"Block\\n\");&#125;static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size;&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;int main(int argc, const char * argv[]) &#123; /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; // 创建一个 block，调用构造方法 void (*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA)); // 调用 block，即调用 __main_block_func_0 方法 ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk); &#125; return 0;&#125; 关系图： 流程：定义 block 的时候，调用 main_block_impl_0 的构造函数，创建 block，main_block_impl_0 结构体中包括 block_impl（block 的实现，而这个结构体又包含 block 中的代码，及静态方法 main_block_func_0），并且把捕获进来的变量成为 __main_block_impl_0 的成员变量。 调用 block 的时候，即调用 block_impl 结构体中的 main_block_func_0 方法，并且把 __block_impl 自身传入方法，以供方法取得值或变量。 为什么 __block 可以修改自动变量的值1234567891011121314151617181920212223242526272829303132333435363738394041424344454647struct __Block_byref_i_0 &#123; void *__isa; __Block_byref_i_0 *__forwarding; int __flags; int __size; int i;&#125;;struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; __Block_byref_i_0 *i; // by ref __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_i_0 *_i, int flags=0) : i(_i-&gt;__forwarding) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; __Block_byref_i_0 *i = __cself-&gt;i; // bound by ref (i-&gt;__forwarding-&gt;i)++; printf(\"%d\\n\",(i-&gt;__forwarding-&gt;i));&#125;static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;i, (void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*);&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;int main(int argc, const char * argv[]) &#123; /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; __attribute__((__blocks__(byref))) __Block_byref_i_0 i = &#123;(void*)0,(__Block_byref_i_0 *)&amp;i, 0, sizeof(__Block_byref_i_0), 10&#125;; void (*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_i_0 *)&amp;i, 570425344)); (i.__forwarding-&gt;i)++; ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk); &#125; return 0;&#125; block 拷贝到堆上，捕获的自动变量值也拷贝到了堆上。123456789101112131415161718#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; __block int i = 10; void (^blk)(void) = ^&#123; i++; printf(\"%d\\n\",i); &#125;; i++; blk(); &#125; return 0;&#125;// 输出12 由于Block_byref_i_0 中有一个可以指向本类型的 forwarding 指针。 在调用 block 之前，即未拷贝之前，栈上的 __forwarding 指向自己，进行一次自增。 经过拷贝之后，栈上的 forwarding 指针指向堆上的变量，而堆上的 forwarding 指针又指向自己。 这样不论是堆中的变量还是栈中的变量调用 (i-&gt;forwarding-&gt;i)++; ，都是堆上变量的值发生了改变，而栈中变量的值则指向了堆中变量的值，即对 block 中的变量进行自增操作，栈中的值也发生了改变（forwarding 指针改变了指向，指向堆中的变量）即对外部的自动变量也可以进行自增操作。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://github.com/hzsss/tags/iOS/"}]},{"title":"Core ML","slug":"Core-ML","date":"2018-06-12T07:43:52.000Z","updated":"2018-12-19T09:35:33.435Z","comments":true,"path":"Core-ML/","link":"","permalink":"https://github.com/hzsss/Core-ML/","excerpt":"","text":"Core ML 概述借助 Core ML，我们可以将经过训练的机器学习模型整合到我们的应用程序中。 一个训练有素的模型是将机器学习算法来训练数据集合的结果。该模型根据新的输入数据进行预测。例如，一个在某个地区的历史房价上受过培训的模型可能能够在给定卧室和浴室的数量时预测房屋的价格。 Core ML 是领域特定框架和功能的基础。Core ML 支持Vision 图像分析，Natural Language 的自然语言处理，以及评估学习决策树的GameplayKit。Core ML 本身建立在像Accelerate和BNNS这样的低级原语以及Metal Performance Shaders 之上。Core ML 针对器件性能进行了优化，最大限度地减少了内存占用量和功耗。在设备上严格运行可确保用户数据的隐私，并确保我们的应用在网络连接不可用时保持功能和响应。 获取 Core ML 模型Core ML 支持多种机器学习模型，包括神经网络，tree ensembles，支持向量机和广义线性模型。Core ML 需要 Core ML 模型格式（带有.mlmodel文件扩展名的模型）。 使用 Create ML 和我们的数据，我们可以训练自定义模型来执行任务，如识别图像，从文本中提取含义或查找数值之间的关系。使用 Create ML 进行培训的模型采用 Core ML 模型格式，可以在我们的应用程序中使用。 Apple还提供了几种已经是 Core ML 模型格式的流行的开源模型。我们可以下载这些模型并在我们的应用中使用它们。另外，各种研究团队和大学都会发布他们的模型和培训数据，这些数据可能不在 Core ML 模型中。如果我们要在应用中使用这些模型，需要转换它们，如受训模型转换为 Core ML。 集成 Core ML 模型将模型添加到 Xcode 项目中这里我使用的是已经训练好的MoblieNet模型，将模型拖放到项目导航栏中，即可将模型添加到项目中： 在Compile Source中添加 .mlmodel 文件： 在 Xcode 中查看模型的信息：我们可以看到具体的模型类 MoblieNet，数据输入格式以及输出格式，在这里输入的是 image 格式的图片，输出的是字典和字符串。 用代码创建模型使用模型类的初始化程序来创建模型：MobileNet1let model = MobileNet() 获取输入值传递给模型在这里我们将相册中选中的图片传给模型：123let image = info[UIImagePickerControllerOriginalImage] as! UIImagelet pixelBuffer = image.pixelBuffer(width: 224, height: 224) 使用模型进行预测在这里我们将模型返回的值显示到界面中，包括结果以及匹配度：1234567891011let output = try?model.prediction(image: pixelBuffer!)let probs = output?.classLabelProbs.sorted &#123; $0.value &gt; $1.value &#125;if let prob = probs?.first &#123; resultLabel.text = \"结果：\\(prob.key) \" let probText = String(format:\"%.2f %\", prob.value * 100) probLabel.text = \"匹配度：\\(probText)%\"&#125; demo 下载 使用 Create ML 创建模型在 WWDC18 中，苹果发布了最新的 Xcode10，在 Xcode10 中使用 Create ML 可以自己创建机器学习模型。 图像分类器是经过训练识别图像的机器学习模型。当我们给它一张图片时，它会返回图片的名称。通过显示大量已标记图像的示例来训练图像分类器。例如，我们可以通过展示大象，长颈鹿，狮子等各种照片来训练图像分类器来识别野生动物园动物。 准备数据首先准备好用来训练和评估分类器的数据。选择约80％的图像创建一个训练数据集。从剩余的图像创建一个测试数据集。确保任何给定的图像仅出现在这两组中的一组中。 接下来，创建一个名为 Training Data 的文件夹，另一个名为 Testing Data。在每个文件夹中，使用我们的标签作为名称创建子文件夹。然后将图像分类到每个数据集合适的子文件夹中。我们不需要以任何特定方式命名图像文件或向其添加元数据。只需将它们放入具有正确标签的文件夹中即可。 每个标签至少使用10个图像作为训练集，当然了，越多越好。此外，需要均衡每个种类的图像数量。例如，不要使用10张猎豹的图像和1000大象张图像。 图像可以是统一类型标识符合public.image的任何格式。这包括常见的格式，如JPEG和PNG。这些图像不需要是相同的尺寸，也不需要任何特定的尺寸，但最好使用至少为299x299像素的图像。如果可能的话，训练收集的图像的方式与收集图像以进行预测的方式类似。 需要提供多种图像。例如，使用从不同角度和不同照明条件下显示动物的图像。对于给定标签几乎相同的图像进行训练的分类器往往比在不同图像集上训练的分类器性能更差。 在 Playground 显示图像分类器准备好数据后，用 macOS 中创建一个新的 Xcode Playground。使用 Playground 创建 MLImageClassifierBuilder 实例并在实时视图中显示它：123456// Import CreateMLUI to train the image classifier in the UI.// For other Create ML tasks, import CreateML instead.import CreateMLUI let builder = MLImageClassifierBuilder()builder.showInLiveView() 训练模型将 Training Data 文件夹从 Finder 拖到实时视图中的指定位置。训练过程开始，图像分类器显示其进展：作为训练过程的一部分，图像分类器会自动将训练数据分成训练集和验证集。这些都会影响训练，但方式各不相同。由于分割是随机完成的，因此每次训练模型时可能会得到不同的结果。 训练结束后，实时视图会显示培训和验证的准确性。这些报告了训练好的模型如何将来自相应组的图像分类。因为使用了这些图像训练模型，所以可以对它们进行很好的分类。 评估分类器的性能接下来，通过使用以前从未使用过的图像进行测试，评估训练好的模型的性能。使用在开始训练之前创建的测试数据集。就像使用培训数据一样，将 Test Data 文件夹拖到实时视图中。 该模型处理所有的图像，为每个图像做出预测。因为这是标记数据，所以模型可以检查自己的预测。然后它将整体评估准确性作为 UI 中的最终指标。如果评估表现不够好，可以重新培训更多数据，或更改其他一些培训配置。有关如何进行更详细的模型评估以及改进模型性能的策略的信息，可以参阅提高模型的准确性。 保存 Core ML 模型当模型运行良好时，保存它以便在我们的应用程序中使用它。 给分类器一个有意义的名字。通过将 UI 中默认的 ImageClassifier 改为 AnimalClassifier。还可以添加更多关于模型的信息，例如作者和简介。点击显示三角形显示这些元数据字段并填写详细信息。点击保存。将该模型保存到指定目录中。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://github.com/hzsss/tags/iOS/"}]},{"title":"iOS开发之Block详解","slug":"iOS开发之Block详解","date":"2018-04-24T07:22:14.000Z","updated":"2018-12-19T09:47:12.492Z","comments":true,"path":"iOS开发之Block详解/","link":"","permalink":"https://github.com/hzsss/iOS开发之Block详解/","excerpt":"","text":"Block定义代码块Block是苹果在iOS4开始引入的对C语言的扩展,用来实现匿名函数的特性,Block是一种特殊的数据类型,其可以正常定义变量、作为参数、作为返回值,特殊地,Block还可以保存一段代码,在需要的时候调用,目前Block已经广泛应用于iOS开发中,常用于GCD、动画、排序及各类回调。一句话来形容Block，带有自动变量（局部变量）的匿名函数。 Block的声明与赋值只是保存了一段代码段,必须调用才能执行内部代码。 Block使用(1) 标准声明与定义1234return_type (^blockName)(var_type) = ^return_type (var_type varName) &#123; // ...&#125;;blockName(var); (2) 当返回类型为void1234void (^blockName)(var_type) = ^void (var_type varName) &#123; // ...&#125;;blockName(var); 可省略写成1234void (^blockName)(var_type) = ^(var_type varName) &#123; // ...&#125;;blockName(var); (3) 当参数类型为void1234return_type (^blockName)(void) = ^return_type (void) &#123; // ...&#125;;blockName(); 可省略写成1234return_type (^blockName)(void) = ^return_type &#123; // ...&#125;;blockName(); (4) 当返回类型和参数类型都为void1234void (^blockName)(void) = ^void (void) &#123; // ...&#125;;blockName(); 可省略写成1234void (^blockName)(void) = ^&#123; // ...&#125;;blockName(); (5) 匿名BlockBlock实现时，等号右边就是一个匿名Block，它没有blockName，称之为匿名Block：1234^return_type (var_type varName)&#123; //...&#125;; (6) typedef简化Block的声明12345678910// 定义一种无返回值无参数列表的Block类型typedef void(^SayHello)();// 我们可以像OC中声明变量一样使用Block类型SayHello来声明变量SayHello hello = ^()&#123; NSLog(@\"hello\");&#125;;// 调用后控制台输出\"hello\"hello(); Block捕获外部变量(1)捕获全局变量和静态全局变量123456789101112131415161718192021222324#import &lt;Foundation/Foundation.h&gt;int global_a = 1;static int global_b = 2;int main(int argc, const char * argv[]) &#123;@autoreleasepool &#123; void (^myBlock)(void) = ^&#123; global_a++; global_b++; NSLog(@\"在Block中：global_a = %d, global_b = %d\", global_a, global_b); &#125;; global_a++; global_b++; NSLog(@\"在Block外：global_a = %d, global_b = %d\", global_a, global_b); myBlock();&#125;return 0;&#125; 输出：122018-04-24 20:56:10.676151+0800 Block简书代码[83038:38449696] 在Block外：global_a = 2, global_b = 32018-04-24 20:56:10.676303+0800 Block简书代码[83038:38449696] 在Block中：global_a = 3, global_b = 4 可以看到全局变量global_a和静态全局变量global_b在Block中进行了++操作，Block结束后，它们的值依然保留了下来。 通过clang命令将OC转为C++代码来查看一下Block底层实现12345678910111213141516171819202122232425262728293031323334353637int global_a = 1;static int global_b = 2;struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;; static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; global_a++; global_b++; NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_s6_gg35g_r90q514w_6xv0vb4fr0000gp_T_main_fd88b4_mi_0, global_a, global_b); &#125; static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size; &#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;; int main(int argc, const char * argv[]) &#123; /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; void (*myBlock)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA)); global_a++; global_b++; NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_s6_gg35g_r90q514w_6xv0vb4fr0000gp_T_main_fd88b4_mi_1, global_a, global_b); ((void (*)(__block_impl *))((__block_impl *)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock); &#125; return 0;&#125; 首先全局变量global_a和静态全局变量global_b的值增加，以及它们被Block捕获进去，这一点很好理解，因为是全局的，作用域很广，他们并没有变成Block结构体__main_block_impl_0的成员变量，因为他们的作用域大，所以可以直接更改他们的值。Block捕获了它们进去之后，在Block里面进行++操作，Block结束之后，它们的值依旧可以得以保存下来。 (2)捕获静态变量和局部变量1234567891011121314#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[]) &#123; // 捕获静态变量@autoreleasepool &#123; static int static_a = 1; void (^myBlock)(void) = ^&#123; static_a++; NSLog(@\"static_a = %d\", static_a); &#125;; myBlock();&#125;return 0;&#125; 输出：123456789101112131415161718192021222324252627282930313233343536372018-04-24 21:11:11.337102+0800 Block简书代码[83204:38537226] static_a = 2struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; int *static_a; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_static_a, int flags=0) : static_a(_static_a) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; int *static_a = __cself-&gt;static_a; // bound by copy (*static_a)++; NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_s6_gg35g_r90q514w_6xv0vb4fr0000gp_T_main_74a550_mi_0, (*static_a));&#125;static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size;&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;int main(int argc, const char * argv[]) &#123; /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; static int static_a = 1; void (*myBlock)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;static_a)); // 传入的是静态变量static_a的内存地址 ((void (*)(__block_impl *))((__block_impl *)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock); &#125; return 0;&#125; 可以看出，Block捕获了静态变量static_a的内存地址，故可以在Block中对静态变量进行修改。123456789101112131415#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[]) &#123; // 捕获局部变量@autoreleasepool &#123; int part_a = 1; void (^myBlock)(void) = ^&#123; NSLog(@\"part_a = %d\", part_a); &#125;; myBlock();&#125; return 0;&#125; 输出：1234567891011121314151617181920212223242526272829303132333435362018-04-24 21:17:22.128069+0800 Block简书代码[83415:38568895] part_a = 1struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; int part_a; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _part_a, int flags=0) : part_a(_part_a) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; int part_a = __cself-&gt;part_a; // bound by copy NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_s6_gg35g_r90q514w_6xv0vb4fr0000gp_T_main_961862_mi_0, part_a);&#125;static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size;&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;int main(int argc, const char * argv[]) &#123; /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; int part_a = 1; void (*myBlock)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, part_a)); // 传入的是局部变量part_a的值，故无法在Block中对part_a进行修改 ((void (*)(__block_impl *))((__block_impl *)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock); &#125; return 0;&#125; 我们可以发现，系统自动给我们加上的注释，bound by copy，局部变量part_a虽然被捕获进来了，但是是用 __cself-&gt; part_a来访问的。Block仅仅捕获了part_a的值，并没有捕获part_a的内存地址。所以在__main_block_func_0这个函数中即使我们重写这个局部变量part_a的值，依旧没法去改变Block外面自动变量part_a的值。 OC可能是基于这一点，在编译的层面就防止开发者可能犯的错误，因为局部变量没法在Block中改变外部变量的值，所以编译过程中就报编译错误。 (3)捕获静态变量和局部变量1234567891011121314#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[]) &#123; // 捕获局部变量 @autoreleasepool &#123; __block int part_a = 1; void (^myBlock)(void) = ^&#123; part_a++; NSLog(@\"part_a = %d\", part_a); &#125;; myBlock(); &#125; return 0;&#125; 输出：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849502018-04-24 21:35:20.456984+0800 Block简书代码[83648:38653724] part_a = 2struct __Block_byref_part_a_0 &#123; void *__isa; __Block_byref_part_a_0 *__forwarding; int __flags; int __size; int part_a;&#125;;struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; __Block_byref_part_a_0 *part_a; // by ref __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_part_a_0 *_part_a, int flags=0) : part_a(_part_a-&gt;__forwarding) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; __Block_byref_part_a_0 *part_a = __cself-&gt;part_a; // bound by ref (part_a-&gt;__forwarding-&gt;part_a)++; NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_s6_gg35g_r90q514w_6xv0vb4fr0000gp_T_main_61637c_mi_0, (part_a-&gt;__forwarding-&gt;part_a));&#125;static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;part_a, (void*)src-&gt;part_a, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;part_a, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*);&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;int main(int argc, const char * argv[]) &#123; /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; __attribute__((__blocks__(byref))) __Block_byref_part_a_0 part_a = &#123;(void*)0,(__Block_byref_part_a_0 *)&amp;part_a, 0, sizeof(__Block_byref_part_a_0), 1&#125;; void (*myBlock)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_part_a_0 *)&amp;part_a, 570425344)); // 传入的是part_a的内存地址，故可以在Block中修改它的值 ((void (*)(__block_impl *))((__block_impl *)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock); &#125; return 0;&#125; Block循环引用一般来说我们总会在设置Block之后，在合适的时间回调Block，而不希望回调Block的时候Block已经被释放了，所以我们需要对Block进行copy，copy到堆中，以便后用。Block可能会导致循环引用问题，因为Block在拷贝到堆上的时候，会retain其引用的外部变量，那么如果Block中如果引用了他的宿主对象，那很有可能引起循环引用，如：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657TestCycleRetain- (void) dealloc &#123; NSLog(@\"no cycle retain\");&#125; - (id) init &#123; self = [super init];if (self) &#123; #if TestCycleRetainCase1 //会循环引用 self.myblock = ^&#123; [self doSomething]; &#125;; #elif TestCycleRetainCase2 //会循环引用 __block TestCycleRetain * weakSelf = self; self.myblock = ^&#123; [weakSelf doSomething]; &#125;; #elif TestCycleRetainCase3 //不会循环引用 __weak TestCycleRetain * weakSelf = self; self.myblock = ^&#123; [weakSelf doSomething]; &#125;; #elif TestCycleRetainCase4 //不会循环引用 __unsafe_unretained TestCycleRetain * weakSelf = self; self.myblock = ^&#123; [weakSelf doSomething]; &#125;; #endif NSLog(@\"myblock is %@\", self.myblock);&#125;return self;&#125; - (void) doSomething &#123; NSLog(@\"do Something\");&#125;mainint main(int argc, char * argv[]) &#123; @autoreleasepool &#123; TestCycleRetain * obj = [[TestCycleRetain alloc] init]; obj = nil; return 0; &#125;&#125; MRC情况下，用__block可以消除循环引用。 ARC情况下，必须用弱引用才可以解决循环引用问题，iOS 5之后可以直接使用__weak 在上述使用Block中，虽说使用__weak，但是此处会有一个隐患，你不知道self什么时候会被释放，为了保证在Block内不会被释放，我们添加__strong。更多的时候需要配合strongSelf使用，如下：12345__weak __typeof(self) weakSelf = self; self.testBlock = ^&#123; __strong __typeof(weakSelf) strongSelf = weakSelf; [strongSelf test]; &#125;); Block实现链式编程我们下面就需要使用这些基础知识来实现链式编程和函数式编程。 场景：实现加法计算，比如我需要计算1+2+5+14。通常做法如下：定义加法函数：123-(NSInteger)addWithParam1:(NSInteger)param1 param2:(NSInteger)param2 &#123; return param1 + param2;&#125; 然后调用：1234NSInteger result = [self addWithParam1:1 param2:2];result = [self addWithParam1:result param2:5];result = [self addWithParam1:result param2:14];NSLog(@\"%zd\",result); 有多少个数字需要相加，我们就需要调用多少次这个方法，相当麻烦。我们想实现如下效果的调用，类似于masonry，也就是所谓的链式编程，看起来就十分优雅。123int reslut = [NSObject makeCalculate:^(CalculateManager *mgr) &#123; mgr.add(5).add(6).add(7).add(10);&#125;]; 下面我们就来看看具体的实现过程吧。 1、先定义一个NSObject的分类如下：1234567891011121314151617181920212223242526#import #import \"CalculateManager.h\"@interface NSObject (Calculate)+ (int)makeCalculate:(void(^)(CalculateManager *))block;@end==============================================================================#import \"NSObject+Calculate.h\"#import \"CalculateManager.h\"@implementation NSObject (Calculate)+ (int)makeCalculate:(void (^)(CalculateManager *))block&#123; // 创建计算管理者 CalculateManager *mgr = [[CalculateManager alloc] init]; // 执行计算 block(mgr); return mgr.result;&#125;@end 2、继续定义一个类实现计算过程，比如add：1234567891011121314151617181920212223242526#import @interface CalculateManager : NSObject@property (nonatomic, assign) int result;- (CalculateManager *(^)(int))add;@end=======================================================#import \"CalculateManager.h\"@implementation CalculateManager- (CalculateManager * (^)(int))add&#123; return ^(int value)&#123; _result += value; return self; &#125;;&#125;@end 3、然后调用:1234int reslut = [NSObject makeCalculate:^(CalculateManager *mgr) &#123; mgr.add(5).add(6).add(7).add(10);&#125;];NSLog(@\"%zd\",reslut); 要实现链式调用的一个关键点：就是每次调用add方法必须返回自身，然后才可以继续调用，如此一致循环下去，实现这一切都是Block的功劳。 4、实现过程分析：上面的步骤3，调用nsobject的分类方法makeCalculate:^(CalculateManager *mgr)block，该方法的参数是一个Block，我们在这里传递一个定义好的Block到该函数。Block的实现是mgr.add(5).add(6).add(7).add(10)回到步骤1，是分类方法makeCalculate:^(CalculateManager *mgr)block的具体实现，该方法内部初始化一个CalculateManager实例对象mgr，然后作为Block的参数传入block，也就是步骤3的Block内部的mgr参数，然后调用该Block，也就是上一步实现的这句代码mgr.add(5).add(6).add(7).add(10)，然后返回执行完毕后的结果，也就是mgr.result。回到步骤2，是链式调用代码mgr.add(5).add(6).add(7).add(10)的关键，可以看到add方法返回的是一个Block，该Block的实现是累加传递进来的值然后赋值给属性result保存下来，然后返回值是self，也就是CalculateManager实例对象。这样又可以实现点语法继续调用add方法。 ####Block实现函数式编程不了解什么是函数编程的童鞋可以看看这篇文章，作为一个入门了解： 函数式编程初探 函数编程有两个好处： 去掉了中间变量 把运算过程写成一系列的函数嵌套调用，逻辑更加清楚 还是上面的例子，不过这次我们想如下写： 123456789101112131415CalculateManager *mgr = [[CalculateManager alloc] init];[[[[mgr calculate:^(int result)&#123; // 存放所有的计算代码 result += 5; result *= 5; return result;&#125;]printResult:^(int result) &#123; NSLog(@\"第一次计算结果为：%d\",result);&#125;]calculate:^int(int result) &#123; result -= 2; result /= 3; return result;&#125;]printResult:^(int result) &#123; NSLog(@\"第二次计算结果为：%d\",result);&#125;]; 可以看到计算函数calculate和输出函数printResult可以一直循环嵌套调用，所有的运算过程全部聚在一起，看起来逻辑更加清楚。 下面来看看如何实现：1234567891011121314151617181920212223#import @interface CalculateManager : NSObject@property (nonatomic, assign) int result;- (instancetype)calculate:(int(^)(int))calculateBlock;-(instancetype)printResult:(void(^)(int))printBlock;@end===========================================================#import \"CalculateManager.h\"@implementation CalculateManager- (instancetype)calculate:(int (^)(int))calculateBlock&#123; _result = calculateBlock(_result); return self;&#125;-(instancetype)printResult:(void(^)(int))printBlock&#123; printBlock(_result); return self;&#125;@end 上面两个函数的关键点在于每次都必须返回self，这样才可以继续嵌套调用其他函数。函数的内部实现是做一些内部处理，然后传入参数来调用block。 参考链接： 深入研究Block捕获外部变量和__block实现原理一篇文章看懂iOS代码块BlockiOS中Block的用法，示例，应用场景，与底层原理解析（这可能是最详细的Block解析）Block使用场景网络回调：Block和Delegate的对比使用FBRetainCycleDetector检测引用循环","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://github.com/hzsss/tags/iOS/"}]},{"title":"iOS开发之深复制和浅复制","slug":"iOS开发之深复制和浅复制","date":"2018-04-09T07:09:35.000Z","updated":"2018-12-19T09:47:36.333Z","comments":true,"path":"iOS开发之深复制和浅复制/","link":"","permalink":"https://github.com/hzsss/iOS开发之深复制和浅复制/","excerpt":"","text":"概述 浅复制并不拷贝对象本身，仅仅是拷贝指向对象的指针。 深复制直接拷贝整个对象内存到另一块内存中。 无论是深复制还是浅复制，被复制的对象都会被复制一份。浅复制只是复制指针，而深复制除了复制指针外，还会复制指针指向的内容。如下图所示： copy 与 mutableCopy不论是集合类对象，还是非集合类对象，接受到copy和mutableCopy消息时，都会循序一下准则。 copy返回immutable对象。如果对copy返回值使用mutable对象接口，就会crash。 mutableCopy返回mutable对象。 非集合类对象的 copy 与 mutableCopy系统非集合类对象指的是NSString，NSNumber之类的对象。下面来看一个例子：12345678910111213// 不可变对象复制NSString *str = @\"haha\";NSString *strCopy = [str copy];NSMutableString *strMCopy = [str mutableCopy];NSLog(@\"%p\", str);NSLog(@\"%p\", strCopy);NSLog(@\"%p\", strMCopy);---------------------------------输出---------------------------------2018-04-09 18:21:08.339512+0800 copyTest[42882:16259329] 0x10314b0782018-04-09 18:21:08.339685+0800 copyTest[42882:16259329] 0x10314b0782018-04-09 18:21:08.339757+0800 copyTest[42882:16259329] 0x60c0002568c0 我们可以看到，strCopy和str的地址一样，说明进行了指针复制，而strMCopy和str地址不一样，说明进行了内容复制。12345678910111213// 可变对象复制NSMutableString *mStr = [NSMutableString stringWithString:@\"hahaha\"];NSString *mStrCopy = [mStr copy];NSString *mStrMCopy = [mStr mutableCopy];NSLog(@\"%p\", mStr);NSLog(@\"%p\", mStrCopy);NSLog(@\"%p\", mStrMCopy);---------------------------------输出---------------------------------2018-04-09 18:21:08.339932+0800 copyTest[42882:16259329] 0x60800005d1002018-04-09 18:21:08.340003+0800 copyTest[42882:16259329] 0xa0061686168616862018-04-09 18:21:08.340051+0800 copyTest[42882:16259329] 0x608000241020 此时mStr，mstrCopy和mStrMCopy返回的对象内存地址都不一样，说明进行了内容复制。 可以总结为以下情况： [immutableObject copy] 浅复制，不可变对象copy后，生成不可变对象，依然无法修改，指针指向同一块内存。 [immutableObject mutableCopy] 深复制，不可变对象mutableCopy后，生成可变对象，可以修改，指针指向不同内存。 [mutableObject copy] 深复制，可变对象copy后，生成不可变对象，变成无法修改，指针指向不同内存。 [mutableObject mutableCopy] 深复制，可变对象mutableCopy后，生成可变对象，可以修改，指针指向不同内存。 集合类对象的 copy 与 mutableCopy集合类对象是指NSArray、NSDictionary、NSSet之类的对象。下面来看一个例子：12345678910111213// 不可变对象复制NSArray *array1 = @[@1, @\"asdas\"];NSArray *array1Copy = [array1 copy];NSMutableArray *array1MCopy = [array1 mutableCopy];NSLog(@\"%p\", array1);NSLog(@\"%p\", array1Copy);NSLog(@\"%p\", array1MCopy);---------------------------------输出---------------------------------2018-04-09 18:33:17.954789+0800 copyTest[42935:16321517] 0x6040000301602018-04-09 18:33:17.954860+0800 copyTest[42935:16321517] 0x6040000301602018-04-09 18:33:17.954935+0800 copyTest[42935:16321517] 0x60400004aad0 可以看到array1和array1Copy内存地址是一样的，而array1和array1MCopy内存地址是不一样的。说明copy进行了指针复制，而mutableCopy进行了内容复制。12345678910111213141516// 可变对象复制NSMutableArray *array = [NSMutableArray array];[array addObject:@2];NSArray *arrayCopy = [array copy];NSMutableArray *arrayMCopy = [array mutableCopy];NSLog(@\"%p\", array);NSLog(@\"%p\", arrayCopy);NSLog(@\"%p\", arrayMCopy);---------------------------------输出---------------------------------2018-04-09 18:33:17.954271+0800 copyTest[42935:16321517] 0x60400004ab302018-04-09 18:33:17.954446+0800 copyTest[42935:16321517] 0x6040000065a02018-04-09 18:33:17.954526+0800 copyTest[42935:16321517] 0x60400004ab60 此时array，arrayCopy和arrayMCopy返回的对象内存地址都不一样，说明进行了内容复制。同样我们可以得出结论： 在集合类对象中，对immutable对象进行copy，是指针复制，mutableCopy是内容复制；对mutable对象进行copy和mutableCopy都是内容复制。但是：集合对象的内容复制仅限于对象本身，对象元素仍然是指针复制。 [immutableObject copy] // 浅复制[immutableObject mutableCopy] //单层深复制[mutableObject copy] //单层深复制[mutableObject mutableCopy] //单层深复制 这个代码结论和非集合类的非常相似。但是如果要对集合中的对象复制元素怎么办？如果在多层数组中，对第一层进行内容拷贝，其它层进行指针拷贝，这种情况是属于深复制，还是浅复制？对此，苹果官网文档有这样一句话描述 This kind of copy is only capable of producing a one-level-deep copy. If you only need a one-level-deep copy, you can explicitly call for one as in Listing 212Listing 2 Making a deep copy:NSArray *deepCopyArray=[[NSArray alloc] initWithArray:someArray copyItems:YES]; 对于集合类型的对象，将 initWithArray:copyItems:第二个参数设置成YES时，会对集合内每一个元素发送copyWithZone:消息，元素进行复制，但是对于元素中指针类型的成员变量，依然是浅拷贝，因此这种拷贝被称为单层深拷贝（one-level-deep copy）。 如何进行深复制呢？如果想进行完全的深复制，可以先通过NSKeyedArchiver将对象归档，再通过 NSKeyedUnarchiver 将对象解归档。由于在归档时，对象中每个成员变量都会收到 encodeWithCoder:消息，相当于将对象所有的数据均序列化保存到磁盘上（可以看成换了种数据格式的复制），再通过initWithCoder:解归档时，就将拷贝过的数据经过转换后读取出来，深复制。1NSArray *trueDeepCopyArray = [NSKeyedUnarchiver unarchiveObjectWithData:[NSKeyedArchiver archivedDataWithRootObject:oldArray]]; 小结 浅复制(shallow copy)：在浅复制操作时，对于被复制对象的每一层都是指针复制。 深复制(one-level-deep copy)：在深复制操作时，对于被复制对象，至少有一层是深复制。 完全复制(real-deep copy)：在完全复制操作时，对于被复制对象的每一层都是对象复制。 补充12345678NSString *str = @\"string\";NSLog(@\"%p\", str);str = @\"newString\";NSLog(@\"%p\", str);---------------------------------输出---------------------------------2018-04-09 18:47:58.582265+0800 copyTest[43000:16423995] 0x10c96d1582018-04-09 18:47:58.582298+0800 copyTest[43000:16423995] 0x10c96d178 此处修改的是内存地址。所以第二行应该这样理解：将@”newStirng”当做一个新的对象，将这段对象的内存地址赋值给str。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://github.com/hzsss/tags/iOS/"}]},{"title":"Objective-C Runtime 及消息发送与转发","slug":"Objective-C-Runtime-及消息发送与转发","date":"2018-03-29T06:51:45.000Z","updated":"2019-01-23T09:04:32.040Z","comments":true,"path":"Objective-C-Runtime-及消息发送与转发/","link":"","permalink":"https://github.com/hzsss/Objective-C-Runtime-及消息发送与转发/","excerpt":"","text":"什么是 RuntimeObjective-C语言是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理。之所以能具备这种特性，离不开运行时系统即objc Runtime，objc Runtime即 Runtime库。Runtime很好的解决了如何在运行时期找到调用方法这样的问题。 类与对象基础数据结构ClassObjective-C类是由Class类型来表示的，它实际上是一个指向objc_class结构体的指针。它的定义如下：typedef struct objc_class *Class;我们再来看objc/runtime.h中objc_class结构体的定义如下：1234567891011121314struct objc_class &#123; Class isa OBJC_ISA_AVAILABILITY; #if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; // 父类 const char *name OBJC2_UNAVAILABLE; // 类名 long version OBJC2_UNAVAILABLE; // 类的版本信息，默认为0 long info OBJC2_UNAVAILABLE; // 类信息，供运行期使用的一些位标识 long instance_size OBJC2_UNAVAILABLE; // 该类的实例变量大小 struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; // 该类的成员变量链表 struct objc_method_list **methodLists OBJC2_UNAVAILABLE; // 方法定义的链表 struct objc_cache *cache OBJC2_UNAVAILABLE; // 方法缓存 struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; // 协议链表 #endif&#125; OBJC2_UNAVAILABLE; 其中，有几个字段是我们需要掌握的。1.isa：需要注意的是在Objective-C中，所有的类自身也是一个对象，这个对象的Class里面也有一个isa指针，它指向metaClass(元类)。2.super_class：指向该类的父类，如果该类已经是最顶层的根类(如NSObject或NSProxy)，则super_class为NULL。3.methodLists：看名字也容易理解，这个methodLists就是用来存放方法列表的。4.cache：用于缓存最近使用的方法。5.version：我们可以使用这个字段来提供类的版本信息。这对于对象的序列化非常有用，它可是让我们识别出不同类定义版本中实例变量布局的改变。 元类（Meta Class）所有的类自身也是一个对象，我们可以向这个对象发送消息(即调用类方法)。既然是对象，那么它也是一个objc_object指针，它包含一个指向其类的一个isa指针。那么这些就有一个问题了，这个isa指针指向什么呢？这个类的isa指针必须指向一个包含这些类方法的一个objc_class结构体。这就引出了meta-class的概念：meta-class是一个类对象的类。当我们向一个对象发送消息时，runtime会在这个对象所属的这个类的方法列表中查找方法；而向一个类发送消息时，会在这个类的meta-class的方法列表中查找。meta-class之所以重要，是因为它存储着一个类的所有类方法。每个类都会有一个单独的meta-class，因为每个类的类方法基本不可能完全相同。再深入一下，meta-class也是一个类，也可以向它发送一个消息，那么它的isa又是指向什么呢？为了不让这种结构无限延伸下去，Objective-C的设计者让所有的meta-class的isa指向基类的meta-class，以此作为它们的所属类。即，任何NSObject继承体系下的meta-class都使用NSObject的meta-class作为自己的所属类，而基类的meta-class的isa指针是指向它自己。这样就形成了一个完美的闭环。通过上面的描述，再加上对objc_class结构体中super_class指针的分析，我们就可以描绘出类及相应meta-class类的一个继承体系了，如下图所示：1234567891011121314151617181920212223242526272829303132333435MyClass *myClass = [[MyClass alloc] init];Class class = [myClass class];Class metaClass = object_getClass(class);Class metaOfMetaClass = object_getClass(metaClass);Class rootMetaClass = object_getClass(metaOfMetaClass);Class superclass = class_getSuperclass(class);Class superOfSuperclass = class_getSuperclass(superclass);Class superOfMetaOfSuperclass = class_getSuperclass(object_getClass(superclass));NSLog(@\"MyClass 实例对象是：%p\",myClass);NSLog(@\"MyClass 类对象是：%p\",class);NSLog(@\"MyClass 元类对象是：%p\",metaClass);NSLog(@\"MyClass 元类对象的元类对象是：%p\",metaOfMetaClass);NSLog(@\"MyClass 根元类对象是：%p\",rootMetaClass);NSLog(@\"MyClass 父类是：%@\",class_getSuperclass(class));NSLog(@\"MyClass 父类的父类是：%@\",superOfSuperclass);NSLog(@\"MyClass 父类的元类的父类是：%@\",superOfMetaOfSuperclass);NSLog(@\"NSObject 元类对象是：%p\",object_getClass([NSObject class]));NSLog(@\"NSObject 父类是：%@\",[[NSObject class] superclass]);NSLog(@\"NSObject 元类对象的父类是：%@\",[object_getClass([NSObject class]) superclass]);//输出：MyClass 实例对象是：0x60c00000b8d0MyClass 类对象是：0x109ae3fd0MyClass 元类对象是：****0x109ae3fa8MyClass 元类对象的元类对象是：****0x10ab02e58**MyClass 根元类对象是：0x10ab02e58MyClass 父类是：NSObjectMyClass 父类的父类是：(null)MyClass 父类的元类的父类是：NSObjectNSObject 元类对象是：0x10ab02e58NSObject 父类是：(null)NSObject 元类对象的父类是：NSObject 现在我们能知道各种对象之间的关系 实例对象通过 isa 指针，找到类对象 Class；类对象同样通过 isa 指针，找到元类对象；元类对象也是通过 isa 指针，找到根元类对象；最后，根元类对象的 isa 指针，指向自己。可以发现 NSObject 是整个消息机制的核心，绝大数对象都继承自它。 methodLists我们再来看看objc_method_list这个结构体12345678910struct objc_method_list &#123; struct objc_method_list * _Nullable obsolete OBJC2_UNAVAILABLE; int method_count OBJC2_UNAVAILABLE; #ifdef __LP64__ int space OBJC2_UNAVAILABLE; #endif /* variable length structure */ struct objc_method method_list[1] OBJC2_UNAVAILABLE;&#125; 里面的objc_method，也就是我们熟悉的Method12345struct objc_method &#123; SEL _Nonnull method_name OBJC2_UNAVAILABLE; //方法的名称 char * _Nullable method_types OBJC2_UNAVAILABLE; //方法的类型 IMP _Nonnull method_imp OBJC2_UNAVAILABLE; // 方法的具体实现&#125; 由此我们可以得出实例对象调用方法的大致逻辑：12MyClass *myClass = [[MyClass alloc] init];[myClass printLog]; 先被编译成 ((void (*)(id, SEL))(void *) objc_msgSend)(myClass, @selector(printLog));沿着入参myClass的isa指针，找到myClass的类对象（Class），也就是 MyClass接着在MyClass的方法列表methodLists中，找到对应的Method最后找到 Method 中的 IMP 指针，执行具体实现 由上文，我们已经知道，实例对象是通过isa指针，找到其类对象（Class）中保存的方法列表中的具体实现的。printLog方法就是保存在MyClass中的。那么如果是个类方法，又是保存在什么地方的呢？我们也知道了类对象的isa指针是指向元类对象的。那么不难得出： 类对象的类方法，是保存在元类对象中的！ cache我们大概知道，方法是通过isa指针，查找Class 中的methodLists的。如果子类没实现对应的方法实现，还会沿着父类去查找。整个工程，可能有成万上亿个方法，是如何解决性能问题的呢？如果每调用一次都需要遍历methodLists，性能是非常差的。所以引入了 Class Cache 机制：Class Cache 认为，当一个方法被调用，那么它之后被调用的可能性就越大。查找方法时，会先从缓存中查找，找到直接返回 ；找不到，再去Class的方法列表中找。在上文中 Class 的定义中，我们可以发现 cache：struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE;说明了缓存是存在类中的，每个类都有一份方法缓存，而不是每个类的 object 都保存了一份。 父类（superclass）在Objective-C中，子类调用一个方法，如果没有子类没有实现，父类实现了，会去调用父类的实现。上文中，找到methodLists后，寻找 Method 的大致过程如下： ps: 其实这里的寻找过程远没有这么简单，可能会遍历很多遍，因为我们可能会在运行时动态的添加方法（比如category）。遍历的过程中同样不时的去查询缓存表。 消息转发如果方法列表（methodLists）没找到对应的 selector 呢？[self performSelector:@selector(myTestPrint:) withObject:@&quot;嘻嘻&quot;];系统会提供三次补救的机会。 第一次+ (BOOL)resolveInstanceMethod:(SEL)sel {} (实例方法)+ (BOOL)resolveClassMethod:(SEL)sel {} (类方法) 这两个方法，一个针对实例方法；一个针对类方法。返回值都是Bool。1234567891011121314151617// ViewController.m 中void myMethod(id self, SEL _cmd,NSString *nub) &#123; NSLog(@\"ifelseboyxx%@\",nub);&#125;+ (BOOL)resolveInstanceMethod:(SEL)sel &#123; #pragma clang diagnostic push #pragma clang diagnostic ignored \"-Wundeclared-selector\" if (sel == @selector(myTestPrint:)) &#123; #pragma clang diagnostic pop class_addMethod([self class],sel,(IMP)myMethod,\"v@:@\"); return YES; &#125;else &#123; return [super resolveInstanceMethod:sel]; &#125;&#125; 我们只需要在 resolveInstanceMethod: 方法中，利用 class_addMethod 方法，将未实现的myTestPrint:绑定到 myMethod上就能完成转发，最后返回YES。 第二次- (id)forwardingTargetForSelector:(SEL)aSelector {}这个方法要求返回一个id。使用场景一般是将 A 类的某个方法，转发到 B 类的实现中去。使用示例：想转发到 Person 类中的-myTestPrint:方法中：1234567891011121314151617181920@interface Person : NSObject@end@implementation Person- (void)myTestPrint:(NSString *)str &#123; NSLog(@\"ifelseboyxx%@\",str);&#125;@end// ViewController.m 中- (id)forwardingTargetForSelector:(SEL)aSelector &#123; #pragma clang diagnostic push #pragma clang diagnostic ignored \"-Wundeclared-selector\" if (aSelector == @selector(myTestPrint:)) &#123; #pragma clang diagnostic pop return [Person new]; &#125;else&#123; return [super forwardingTargetForSelector:aSelector]; &#125;&#125; 第三次- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {}- (void)forwardInvocation:(NSInvocation *)anInvocation {}第一个要求返回一个方法签名，第二个方法转发具体的实现。二者相互依赖，只有返回了正确的方法签名，才会执行第二个方法。这次的转发作用和第二次的比较类似，都是将 A 类的某个方法，转发到 B 类的实现中去。不同的是，第三次的转发相对于第二次更加灵活，forwardingTargetForSelector:只能固定的转发到一个对象；forwardInvocation:可以让我们转发到多个对象中去。使用实例：想转发到 Person 类以及Animal类中的-myTestPrint:方法中：123456789101112131415161718192021222324252627282930313233343536373839@interface Person : NSObject@end@implementation Person- (void)myTestPrint:(NSString *)str &#123; NSLog(@\"ifelseboyxx%@\",str);&#125;@end@interface Animal : NSObject@end@implementation Animal- (void)myTestPrint:(NSString *)str &#123; NSLog(@\"tiger%@\",str);&#125;@end// ViewController.m 中- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123; #pragma clang diagnostic push #pragma clang diagnostic ignored \"-Wundeclared-selector\" if (aSelector == @selector(myTestPrint:)) &#123; #pragma clang diagnostic pop return [NSMethodSignature signatureWithObjCTypes:\"v@:@\"]; &#125; return [super methodSignatureForSelector:aSelector];&#125;- (void)forwardInvocation:(NSInvocation *)anInvocation &#123; Person *person = [Person new]; Animal *animal = [Animal new]; if ([person respondsToSelector:anInvocation.selector]) &#123; [anInvocation invokeWithTarget:person]; &#125; if ([animal respondsToSelector:anInvocation.selector]) &#123; [anInvocation invokeWithTarget:animal]; &#125;&#125; ⚠️ 如果到了第三次机会，还没找到对应的实现，就会 crash：unrecognized selector sent to instance 0x7f9f817072b0 消息发送和消息转发的过程","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://github.com/hzsss/tags/iOS/"}]},{"title":"App Store被拒的一次经历（附解决方案）","slug":"App-Store被拒的一次经历（附解决方案）","date":"2018-03-12T06:42:32.000Z","updated":"2019-04-28T02:28:42.936Z","comments":true,"path":"App-Store被拒的一次经历（附解决方案）/","link":"","permalink":"https://github.com/hzsss/App-Store被拒的一次经历（附解决方案）/","excerpt":"","text":"现已上架 App Store，可以点击链接下载使用 第一次上架App被拒，苹果在解决方案中心发来了以下的说明邮件ITC.date.dateAtTime ITC.apps.resolutionCenter.header.from 3. 1.4 Business: Payments - Content Codes4. 3 Design: Spam5. 1.1 Legal: Privacy - Data Collection and StorageGuideline 3.1.4 - Business - Payments - Content CodesYour app enables additional features or functionality when used with augmented reality markers. However, those features are not available in the app to users without the necessary markers. Next StepsTo resolve this issue, please provide a means to access the augmented reality features from within the app, such as through achievements or in-app purchase. If they can be freely obtained, such as through a link to a website, please revise your app to include clear instructions for obtaining the necessary markers. Please note that apps cannot require users to purchase unrelated products or engage in advertising or marketing activities to unlock app functionality. Request a phone call from App ReviewAt your request, we can arrange for an Apple Representative to call you within the next three to five business days to discuss your App Review issue. Our representative will be able to discuss the issue in English or Chinese. Request a call to discuss your app’s review. 申请应用审核团队致电联系如果您有需要，我们将根据您的要求在三到五个工作日内安排一位精通中文的苹果公司代表致电与您联系，讨论您的应用审核结果。 申请应用审核团队致电联系 申請應用審核團隊致電聯繫如果您有需要，我們將根據您的要求在三到五個工作日內安排一位精通中文的蘋果公司代表致電與您聯繫，討論您的應用審核結果。 申請應用審核團隊致電聯繫 Guideline 4.3 - DesignThis app duplicates the content and functionality of other apps submitted by you or another developer to the App Store, which is considered a form of spam. Apps that simply duplicate content or functionality create clutter, diminish the overall experience for the end user, and reduce the ability of developers to market their apps. The next submission of this app may require a longer review time, and this app will not be eligible for an expedited review until this issue is resolved. Next Steps Review the Design section of theApp Store Review Guidelines. Ensure your app is compliant with all sections of theApp Store Review Guidelinesand theTerms &amp; Conditionsof the Apple Developer Program. Once your app is fully compliant, resubmit your app for review. Submitting apps designed to mislead or harm customers or evade the review process may result in the termination of your Apple Developer Program account. Review theTerms &amp; Conditionsof the Apple Developer Program to learn more about our policies regarding termination. If you believe your app is compliant with theApp Store Review Guidelines, you may submit an appeal. Alternatively, you may provide additional details about your app by replying directly to this message. Guideline 5.1.1 - Legal - Privacy - Data Collection and StorageWe noticed that your app requests the user’s consent to access their camera but does not clarify the use of this feature in the permission modal alert. Please see attached screenshots for details. Next StepsTo resolve this issue, please revise the permission modal alert to specify why the app is requesting access to the user’s camera. ResourcesTo learn more about requesting the user’s permission to access app features, visit theiOS Human Interface Guidelines. You may also want to review theTechnical Q&amp;A QA1937: Resolving the Privacy-Sensitive Data App Rejectionpage for details on how to provide a usage description for permission request alerts. 原因其中此次提交违反了苹果审核指南中的3.1.4，4.3以及5.1.1。 3.1.4 内容代码 App 不得使用自身机制来解锁内容或功能，如许可证密钥、增强现实标记、二维码等。在为数不多的情形中，例如当功能依赖于特定的硬件功能时，app 可在不使用 App 内购买项目的情况下解锁该功能 (例如，天文 app 会在与望远镜同步后增加功能)。与经过批准的实际产品 (如玩具) 配合使用的可选 app 功能可在不使用 App 内购买项目的情况下解锁特定功能，前提是同时也提供 App 内购买项目选项。您不得要求用户通过购买无关产品或参与广告或市场活动来解锁 app 功能。 4.3 重复 App 请不要为同一个 app 创建多个套装 ID。如果您的 app 针对特定位置、运动队、大学等存在不同版本，请考虑提交单个 app，并提供 App 内购买项目以提供不同的功能。同时，请避免继续在已有大量类似 app 的类别下进行开发；App Store 上已经有太多模拟放屁、打嗝声音的 app，以及手电筒和爱经 app。上传大量相似版本 app 的开发者会遭到 Apple Developer Program 的除名。 5.1.1 数据收集和存储 (i) App 须先制定隐私政策，并征得用户的同意，才能对用户信息或使用数据进行收集。这包括 (但不限于) 以下 app：实施 HealthKit 或其他健康/医疗技术、使用 ARKit、相机 API、照片 API 或其他软件功能以获取深度面谱信息的 app，HomeKit、Keyboard 扩展、Apple Pay、Stickers和 iMessage 扩展的 app；包含登录信息的 app；或访问设备上用户数据的 app。App 描述中应当注明 app 会要求访问哪些内容类型 (例如，位置、通讯录和日历等)，并说明当用户不授予许可时，app 的哪些功能会无法正常工作。 (ii) 如果 app 不包含基于帐户的重要功能，请允许用户在不登录的情况下使用。App 不得要求用户提供个人信息才能正常使用，除非个人信息与 app 的核心功能直接相关，或是法律要求时。如果您的核心 app 功能与特定的社交网络 (如 Facebook、微信、微博或 Twitter 等) 不相关，您必须提供无需登录或其他类似机制的访问权限。调取基本档案信息、分享到社交网络或邀请朋友使用 app 等不视为核心 app 功能。 (iii) 如果开发者开发的 app 试图暗中收集用户密码或其他用户私人数据，那么该开发者会遭到 Apple Developer Program 的除名。 (iv) 必须使用 SafariViewController 在显著位置向用户显示信息；不得隐藏该控制器，也不能被其他视图或图层遮挡。此外，未经用户的知情和同意，app 不得私下利用 SafariViewController 来追踪用户。 解决方案大致参考了一下苹果审核指南，再结合本次上架的App，是扫描实体图书中的图片，识别成功后播放对应的介绍视频和音频。 这其中就涉及到两项，其一是需要在App中说明或添加要扫描的标记对象，其二就是需要对相机权限进行更加详细的说明。申请苹果的中文技术支持后，和她电话确认了3.1.4和5.1.1的解决方案。分别是添加电子书的下载链接，和对相机权限的描述进行更改。 关于4.3，苹果这几年加大了对重复应用和马甲包的审核力度。搜索App Store中类似的App，也有很多针对各个博物馆的App，功能都是类似的，但是却都顺利上架了。第二次和技术支持通电话后，她很干脆地说出此次提交的版本是与其他两个帐号提交的版本高度类似。此时Boss才想起来，原来之前用过两个个人开发者帐号提交过，但都被拒了，一直放在那里。 原来只要提交过，不管有没有上架的版本，后来别人提交的就不能与之类似。后来针对4.3给出的解决方案是，在那两个提交过的帐号下，在各自的解决方案中心，申请放弃审核此版本。然后在需要上架的开发者帐号中，说明与其他两个帐号的关系。 信心满满地第三次提交，延迟审核了十天，结果被拒，没有道理呀，我明明都按要求改了。结果第二天一大早，又发邮件通知我在重新审核。到了晚上终于告诉我审核通过了。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://github.com/hzsss/tags/iOS/"}]},{"title":"iOS应用上架遇到的一些坑","slug":"iOS应用上架遇到的一些坑","date":"2017-11-28T06:30:47.000Z","updated":"2018-08-05T08:14:46.511Z","comments":true,"path":"iOS应用上架遇到的一些坑/","link":"","permalink":"https://github.com/hzsss/iOS应用上架遇到的一些坑/","excerpt":"","text":"学习iOS开发一年多了，也算是一个入门小菜鸟了，期间也做过一些小项目。最近一个公司的老师让我帮他上架一个App到App Store，我很爽快地答应了。当然，也遇到了一些坑。 由于这是我第一次上架APP，很多东西都是借鉴学习别人的经验。下面，就让我和大家分享一些上架干货和遇到的问题。 购买开发者帐号老师刚开始让我帮他购买个人开发者帐号，我是参考这篇文章购买的。 iOS苹果个人开发者账号购买流程 最后需要使用信用卡支付一年99美元约合人民币688元的账单，只支持带有Visa/MasterCard标志的银联信用卡，也就是支持双币的信用卡。 购买完成后，本应该显示的是这个界面。 可是我的一直停留在这个界面。 一直显示我还有订单未完成。可是我只有这一份订单，难道是我支付的时候出问题了？可是电子发票已经发给我了。于是我去问苹果客服，态度都蛮好的，说是刷新几次就好了。可是我一直刷新似乎都没有反应。网上有说等48小时之后就好了。于是我又等了两天。 三天后继续问苹果客服，客服说订单没有任何问题，让我拨打开发者部门的电话400-670-1855*，*果然开发者的问题还是需要开发者来解决。打完电话后不久，就收到了邮件。 原来是我的信息填错了，简直太粗心了。于是我又问老师到底想购买个人开发者帐号还是公司开发者帐号。老师又改变注意想要购买公司开发者帐号。于是我回复邮件后，客服回复我已经在处理退款了。回到Apple Developer主页，已经回到最初没有购买的状态了。 申请邓白氏编码购买公司开发者帐号有很重要的一步，那就是需要提交公司的邓白氏编码。很多公司第一次发布App的话，需要去申请邓白氏编码。 申请邓白氏编码的超详细流程介绍 iOS公司开发者账号申请教程 期间没有遇到任何的问题，只是需要等待较长的时间。中途会发送邮件让你确认信息，只有三个小时左右的时间让你回复邮件，你需要提前准备确认信息。包括以下信息： 至此，公司开发者帐号购买完毕。 App打包上架帐号都准备完毕后，接下来就是App的上架流程了。中途老师也让我帮他更新了一个已经上架的App，我参考了这位同学写的两篇文章。 [iOS]AppStore最新上架流程梳理 [iOS]AppStore中APP版本更新流程梳理 注意，更新App的时候，打包ipa文件的时候使用的App ID是之前那个。只有上架App的时候才需要新建一个。 打包的时候也遇到了一个错误，显示the Info.plist in the package must contain the CFBundleVersion key. 上网搜了一下，说是在在info.plist表中找到CFBundle Version并给其填写Build version值即可。 iOS进行项目上传时遇到The Info.plist in the package must contain the CFBundleVersion key的解决方法 但好像在打包完成后的包中直接更改无效。我是退出更改后，重新Archive后解决的。 所有的信息都填写完毕后，提交Apple需要你确认两个信息： 出口合规要求，我在网上搜索的答案是，大多数人都是安全点NO，大家也可以根据自己的情况去搜索或者询问。 广告标识符，我在网上看到有很多检测iOS项目中是否使用IDFA的方法，分享其中一篇： 检查iOS项目中是否使用了IDFA 但我的检测输出结果是：./Classes/Unity/DeviceSettings.mm: NSString* adid = [[manager performSelector:@Selector(advertisingIdentifier)] UUIDString]; 有人回答说这个方法就是获取idfa的实现，如果不是自已的代码，应该是包含IDFA了。但我在他回答之前已经点击『是』提交了。估计将会被拒绝，以上流程我又要重新来一遍。悲催。 这些就是我给大家分享的关于App上架的干货和我遇到的一些问题。希望对大家有帮助。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://github.com/hzsss/tags/iOS/"}]},{"title":"逆风飞翔，愿你归来仍是少年","slug":"逆风飞翔，愿你归来仍是少年","date":"2017-10-20T15:07:47.000Z","updated":"2018-08-05T11:48:32.911Z","comments":true,"path":"逆风飞翔，愿你归来仍是少年/","link":"","permalink":"https://github.com/hzsss/逆风飞翔，愿你归来仍是少年/","excerpt":"","text":"这两天的心情，真的很沉重。期盼已久的新赛季好不容易到了，以为又可以看书豪在球场上打球的。昨天是篮网新赛季的第一场球，比赛前书豪还在ins上发了一张图，是队友伸手将他拉起来，然后写道：我们回来了。 这赛季篮网的阵容深度又加强了，书豪经过这几年的NBA生涯，终于当上了球队的首发控卫，自己也变得更加强壮和成熟。今年本是书豪带队冲击季后赛的最好机会，也本是书豪生涯的巅峰时期。他信心满满地想要在这个赛季证明自己。 在揭幕战打了25分钟便拿下18分，但如今书豪这个赛季的出场时间，也定格在了25分钟。 书豪在一次突破上篮中，身体失去平衡，然后摔倒在地。书豪用手捂着膝盖愣了两秒钟，感受着膝盖传来的痛楚，然后露出了惶恐的眼神，连喊了六遍”I’m done，I’m done”（我完了），然后捶着地板掩面哭泣。 真的，看到这个场景，我的心瞬间就凉了。为什么书豪这么优秀，哈佛毕业，NBA首发控卫，这一点放到我们任何人身上都可以吹嘘一辈子。但书豪却依旧那么刻苦，一年比一年进步，终于当上了球队老大。这本是一个充满希望的赛季，可是，在这一刻，所有的希望都破灭了。也许书豪哭泣，不是因为痛苦，而是眼看着梦想就要起航，却又在瞬间支离破碎。 赛后，书豪被确诊为髌骨肌腱断裂，赛季报销··· 忠于上帝的你，明明那么努力地准备，换来的却是一次又一次的考验。书豪，你的上帝，对你真的很严格。 又是一年看不到你在球场上飞驰，可是书豪，我们等你。 逆风飞翔，愿你归来仍是少年。","categories":[],"tags":[{"name":"life","slug":"life","permalink":"https://github.com/hzsss/tags/life/"}]},{"title":"移动应用创新赛决赛之旅","slug":"移动应用创新赛决赛之旅","date":"2017-09-29T11:22:40.000Z","updated":"2018-08-10T10:07:23.954Z","comments":true,"path":"移动应用创新赛决赛之旅/","link":"","permalink":"https://github.com/hzsss/移动应用创新赛决赛之旅/","excerpt":"","text":"中国高校计算机大赛(China Collegiate Computing Contest，简称 C4)是面向全国高校各专业在校学生的科技类竞赛活动，由教育部高等学校计算机类专业教学指导委员会、教育部高等学校软件工程专业教学指导委员会、教育部高等学校大学计算机课程教学指导委员会、全国高等学校计算机教育研究会联合主办，2017 年设五个竞赛模块，其中“移动应用创新赛”由浙江大学、Apple联合主办。 比赛分为初赛、复赛和决赛，当时一听赛制这么繁琐，初赛到复赛中间隔了好几个月，全国参赛人数之多，瞬间就感觉希望渺茫了，不报名又会挨骂，于是就临时想了个idea报名了。 没想到很顺利就通过了初赛，复赛的时候要求提交部分代码，于是暑假就和小伙伴们留在了学校，每天都在实验室完善自己的比赛作品。我们组有三个人，我是组长，负责所有的代码编写，还有两个女生，一个就叫猪猪女孩吧，另一个就叫狄仁杰吧，负责前端UI。 那一段经历还是很有趣的，中间遇到过困难，也出现过分歧。我平常都是脾气超好的，但是有的时候太认真也太固执了，不知道这样是好是坏。好几次队友做的图我都不是很满意，怎么改都不符合我的要求，比如刚开始的启动界面是这样的。。。 后来还因为这个事情把猪猪女孩给骂哭了，现在想想，不就是一张图么，不就是一个比赛么，竟然对人家女孩子发脾气。在这里给猪猪女孩道个歉，你还是最棒（胖）的~不过队友还是很给力的，最终的成品是这样的： 最后把作品提交上去了，等待了差不多半个月吧，最后竟然进了决赛，收到了浙江大学的决赛邀请函，哇，当时真的是高兴地要跳起来。 后来去了浙江大学参加比赛，比赛提供的环境还是很不错的，四星级酒店，每天都是自助餐。由于我的答辩时间是在第二天，于是前一天晚上都是在房间里做最后的准备。 中间还抽空去了西湖玩，虽然下着大雨，全身都淋湿了，不过回想起这一段经历，和大学同学在雨中骑车，还是蛮有趣的。 虽然只得了个优秀奖，奖品是一个 beats 耳机。不过这一次比赛，见识了很多非常厉害的同龄人，对自己来说，也得到了一次很大的提升。之前准备作品的时候每天都在coding，这一次也算出来放松一下了。 最后再上几张图吧：","categories":[],"tags":[{"name":"活动","slug":"活动","permalink":"https://github.com/hzsss/tags/活动/"}]},{"title":"iOS club夏令营","slug":"iOS-club夏令营","date":"2017-09-02T07:40:19.000Z","updated":"2018-08-05T08:16:14.454Z","comments":true,"path":"iOS-club夏令营/","link":"","permalink":"https://github.com/hzsss/iOS-club夏令营/","excerpt":"","text":"很幸运自己能够参加2017年iOS club的夏令营，这次夏令营不仅让我认识了很多朋友，也让我学到了很多知识。给我这个夏天留下了最美好的回忆。 8月21日上午，我们一行人抵达广州。中午赶到天环广场签到集合。看到这么多人，想到未来五天要和他们打交道，心里难免有点紧张。然后排队上车，经历一个小时的车程，终于到了期待已久的东莞理工学院。 一下车并没有立即去宿舍，而是带我们到了学术交流中心。老师先是向我们介绍了这次的夏令营，以及这所东莞理工学院城市学院。然后让我们每一组的组长进行介绍。我是第11组的组长，我们组名字叫做“晓组织”。介绍完之后，组长上台挑选T恤，我们组挑的是黑色的衣服。其实这个时候我还不知道我的组员到底长什么样，不过心里的紧张感却渐渐减弱了。 提着行李去宿舍楼领钥匙。路上我就遇到了我的组员们，把衣服给他们，又聊了几句。感觉这些人都很不错，甚至有一种莫名的亲切感。收拾好寝室，吃完晚饭，又买了一些生活用品，已经是晚上了。于是我们组几个男生便在寝室里，一直交谈到很晚。此时，我已经确定我能和他们相处得很融洽，开始期待以后到底会擦出怎样的火花。 第二天，一大早便开始上课。果不其然，大多数人在新的环境里还是睡不好的，昨天明明很累，却一直到凌晨两点才睡着。第一节课是赵航老师的Design Thinking，教会我们解决问题的双钻石模型，以及如何制作人物画像。课上还让我们一起合作，用意大利面、绳子和胶带，把棉花糖支到最高，一起进行人物采访，最后让我们上台表演。第一节课不仅没有让我们打瞌睡，还迅速拉近了组员之间的距离。 下午的课是“二次元的与时尚的Free Style”，两位老师给我们讲解了穿衣打扮的一些基本知识，邀请同学和老师上台，进行实战改造。不得不说，穿对衣服真的是可以让一个人的外貌气质发生比较大的变化。老师说了一句话让我印象非常深刻。老师说：be yourself，everyone else has already taken。做你自己，因为别人都有人去做了。是啊，在这个物欲横流，纷纷扰扰的世界，又有多少人能够保持初心，做真正的自己。 这次夏令营要求我们在短短五天之内，做出一个APP方案进行比赛。所以我们组第二天吃完晚饭，全组同学在寝室进行初期的一些计划和内容，包括APP提案的确定，以及组员之间的分工等。虽然才认识不到两天，但我们似乎已经有了一些微妙的默契。 接下来的两天，老师在课上向我们介绍了iOS软件开发相关的知识，包括Core Animation以及ARKit。教我们利用keynote制作产品原型。还邀请了苹果公司的面试官给我们讲解了校园招聘的一些情况。总之，如果想要通过Apple公司的面试，必须要有极强的专业能力和综合素质。 最美好也最忙碌的就是每天的夜晚了，我们一起讨论，一起合作。虽然也会有不同的意见，但这种思想上的碰撞却让我们的作品更加完善。看到这么多志同道合的朋友，在为同一个目标努力，每一个人的心中都充满着斗志。每天都熬夜到很晚。累了的时候，也会停下来，聊聊天。我们似乎是一群合作了很久的好朋友，一切都是那么自然，那么和谐。 五天的时间很短暂，但是我们却建立了深厚的友谊。最后一天上午，进行小组比赛。可以看得出来每一组都尽了自己最大的努力，老师们给的点评也都十分到位。每一天的辛苦和付出似乎都很值得，虽然很遗憾没有得奖，但这五天得到的收获远远比这实体的奖励更加丰厚。","categories":[],"tags":[{"name":"活动","slug":"活动","permalink":"https://github.com/hzsss/tags/活动/"}]},{"title":"如果我们不曾相遇","slug":"如果我们不曾相遇","date":"2016-08-29T11:40:45.000Z","updated":"2018-08-05T11:44:20.062Z","comments":true,"path":"如果我们不曾相遇/","link":"","permalink":"https://github.com/hzsss/如果我们不曾相遇/","excerpt":"","text":"阿信唱《温柔》时，不打电话给心中的那个人，才是这首歌的意义。 大一暑假一个人去鸟巢看五月天的演唱会，很震撼。。","categories":[],"tags":[{"name":"活动","slug":"活动","permalink":"https://github.com/hzsss/tags/活动/"}]},{"title":"十一月的肖邦","slug":"十一月的肖邦","date":"2015-12-07T14:53:59.000Z","updated":"2018-08-05T06:24:13.728Z","comments":true,"path":"十一月的肖邦/","link":"","permalink":"https://github.com/hzsss/十一月的肖邦/","excerpt":"","text":"九月，踏上离别的火车，内心充满了好奇和惶恐不安。经度，可以改变日出时间；纬度，却可以掌握四季变换。千里之外的城市，将是我四年落脚的地方。 以前我们总是抱怨高中生活的苦累，期盼着高考早日结束。而现在，我们早已走上人生新的旅程。于是便深刻地感受到时间飞逝的速度。仿佛一瞬间，记忆不停地倒带，从前经历过的欢乐和苦痛历历在目。无奈我们无法打破时间和空间的逻辑，只能任由记忆盘旋，留下我们深深的叹息。 来到一座陌生的城市，所有的一切都是新奇的。陌生的街道，陌生的商场，陌生的广场和公园。还有许多陌生的行人，他们也用好奇的眼神看着你。用自以为标准的普通话向过路的人问路，却被嘲笑成平翘舌不分。内心有一点小小的沮丧，就好像我是去荒岛上捉三只眼的那个人，却被他们捉了起来，自己反而成了两只眼的怪人。 但慢慢的，我认识了一群人，熟知了一座城。内心的躁动与不安渐渐平息下去，似乎重温了“家”的感觉。记住的街道越来越多，走在大街上，也不会轻易地迷路。跟别人讲话也有了一点本地人的口音。记住了哪里有好看的风景，哪里有美味的食物，公交车路线也记得清清楚楚。突然有一种感觉，就好像，这是我前世的故乡，却也终将成为我的第二故乡。 曾经在高中的无数个夜晚里，想象着大学生活的美好。但当我们走过那座独木桥，当我们真正来到大学时，却发现和自己的想象大相庭径。以为自己逃出了高中的牢笼，反而进了一个更加森严的监狱。生活并没有比高中轻松多少，事实也总是没有想象中那么美好。 时间总是不以人的意志为转移，按照惯例飞快地流逝着。转眼间三个月过去了，回家的车票也已经订好。依旧坚持每天写日记，手写而不是电子文档，当我回头看的时候，吹掉日记本上的灰尘，打开泛黄的纸，这种感觉是电子文档不能比的。也许是高中生活太过单调，那时候日记本上总是一段话就结束了一天的经历，而现在日记本写得满满的，似乎每天都过得很累却很充实。但当我真正回想起来，却不知道做那些事的目的是什么，自欺欺人么？也许吧。想起一句话，最可怕的不是无事可做，而是不知道自己要做什么。像我这样自欺欺人是否才是最可怕的呢？ 在大家面前总是表现出笑容，给人一种乐天派的印象。快乐是真的，孤独也是真的。行走在寒夜的冷风中，感受着家里从来没有过的零下温度，孤独和着寒意袭来，真真切切地感受到自己的渺小。偌大的城市，没有亲人，也没有昔日无话不说的朋友，要说不孤独，连自己都骗不过。 我不是那种喜欢活在精神世界的人，孤独也好，喧闹也罢。最终我们还是得着手于现实，还是得学会成长。生活处处有阳光，我也懂得了生活，懂得了善待自己。《后会无期》中有这么一句话“我们听过无数的道理，却依然过不好这一生”。可是如果我们能用尽一生去恪守一个道理，那么人生依旧会很美好。 一个人在外地，难免会受到许多委屈。和陌生人相处，和同学相处，和室友相处，我都时常提醒自己，这里不是家，不能像在家里那样随意，在这里没有人能原谅我的任性。有一次，我一个人来到百脑汇，那里的气氛特别不对劲，就好像是一个传销组织的基地，见到人便把人拉得去他的店铺。我在找客梯，又一个讨厌的人想拉我去他那里，我没有理他，他却突然开口骂我，还说脏话，在千里之外的老妈无辜躺枪。我转身走开，并不想跟他有任何纠葛。 这就是所谓的没有教养吧。“教养”是一个何其古老，于今天何其陌生的字眼啊，这个词本来才是品位的绝配，不过，由于教养困难，奢华容易，我们今天才会把品位许给了奢华，让空洞的无止境的消费去遮掩教养的匮乏。教养不必来自家教，更不是贵族的专利，上进的人更看重后天的自我育成。奢华和教养的分界点在哪里？一个向外——求胜。一个向内——求安。无时无刻不在和他人相比，自然就倾慕奢华。无时无刻不在要求自己进步，自然就有了教养。 我觉得我是一个很没有主见的人，总是想着成为某个人。打篮球时想成为林书豪，唱歌时想成为周杰伦，写作时想成为韩寒，生活上又想成为李易峰。迷失自我，觉得别人的才是好的。明知道这样不好，却摆脱不了别人的影子。每天都在思考，我到底是怎样的人，要到底要成为怎样的人。有人说我傻有人说我幼稚，可也有人说我很聪明。此时的我，就像迷路的孩子提着灯笼，孤独地站在起了大雾的十字路口。 可是成长是必然的，也许经常被人说成幼稚，可是内心是知道的，自己已经是小时候幻想过无数次的大人了。又想起无意中在网上看过的一段话“多年前的某一天，坐在课堂上发呆的你，老师的声音越飘越远，那时候的你觉得2008年的奥运遥远的不可想象，也不知道2015年的自己身在何方，窗外的树上，一群麻雀叽喳着飞过，粉笔砸中你的头，老师让你站着听课，同学们在窃窃私语，窗外的树叶滑落，没有人注意到时间它那么仓促，再次想起，是否想重新来过。”当完成了童年理想,童年又成了理想，也许是一种悲哀吧。 相比于高中，大学有更多可以自己支配的时间，读了更多书，明白了更多道理，体验了更多不曾有过的生活。可是却发现，手中的笔无法描写天马行空的思想，无法随心所欲地写出自己的想法。十一月的肖邦，十二月的飘雪，还有许多的话，不是假装沉默，只是无力诉说。","categories":[],"tags":[{"name":"life","slug":"life","permalink":"https://github.com/hzsss/tags/life/"}]},{"title":"梨花落","slug":"梨花落","date":"2015-03-06T14:44:00.000Z","updated":"2018-08-05T05:22:32.787Z","comments":true,"path":"梨花落/","link":"","permalink":"https://github.com/hzsss/梨花落/","excerpt":"","text":"三月，草长莺飞的季节。 五点半，准时起床，窗外下着雨。三月的雨，不像夏天“骤雨过，珍珠乱撒，打遍新荷”般猛烈，而是细密缠绵得让人不舒服。每天都这样，匆忙地赶到学校，然后新的一天又开始了。 现在距离高考早已没有一百天，百日势师大会上郑重地签下自己的名字，也已经是前几天的事了。每个人似乎都充满着斗志，连最坏的学生也安静下来，因为再也没有人会陪他闹了。其实都很疲倦，只是彼此心照不宣。 学校的梨花开了，大片大片的浅红色，似乎给校园渲染了些许浪漫色彩。但我们无瑕欣赏，为了高考，我们放弃了许多，新出的电影，未完结的动漫，甚至新闻……都与我们绝缘。以前见到学长们张口闭口都是学习，心里便十分鄙夷。但现在我渐渐发现，自己也变得跟他们一样，原来我们都是被现实所迫。现在的我，可以对语文试卷上的文章抒发的情感看得十分透彻，然而再也不能用文章随心所欲地表达自己的情感。 千军万马过独木桥注定是一件残忍的事。如今我们已经是箭在弦上。这种感觉，就像小时候排队打针，轮到自己时，心里总会有一种莫名的恐惧。教学楼前贴着写有“黎明前的黑暗最黑”的横幅。在这黑暗中，有的人看不到希望，有的人迷失了方向，有的人踌躇满志，决胜千里。而更多的人，像我一样，在黑暗中摸索、挣扎，企图抓住一根救命稻草，帮助自己渡过难关。然而哪里有什么救命稻草，这完全只能靠自己。 数学老师是个胖子，数学课代表也是个胖子。我讨厌他们，我并不讨厌胖子，我只是讨厌数学，久而久之连老师和课代表一起讨厌了。有些数学问题我就是不会做，有些甚至连题目都看不懂，但他们就这样硬生生地解出来了，还说得头头是道。没错，我的数学成绩很差。这本来就不公平，英语是我的强项，我目睹同学亲手撕掉理综试卷，他的理综三科总分还没我英语一科那么高。纵使我们再不喜欢哪一门科目，我们也别无选择。 难得元宵节有半天假期，从老家回来的路上，依旧下着雨。尽管早已过了春节，收音机里仍播放着电台的新年祝福。车窗外面，有人冒着雨前行。我们都一样，每个人都在为自己的生活奔波劳累。雨越下越大，心中竟不由得担心起梨花来。 第二天来到学校，只剩下光秃秃的枝桠，地面上铺满梨花。雨下一整晚，梨花终究还是凋落了。但它至少让我记住了它曾经的美丽，也许夏天，它会更枝繁叶茂。 拾起一片花瓣，夹在书里。 我回到教室，又开始了学习。不论结果怎样，这些日子像梨花般终会逝去，成为心中最美的记忆。这个夏天，一定会非常美丽。","categories":[],"tags":[{"name":"life","slug":"life","permalink":"https://github.com/hzsss/tags/life/"}]},{"title":"高三·考试·心情","slug":"高三·考试·心情","date":"2014-10-04T14:49:16.000Z","updated":"2018-08-05T01:17:28.806Z","comments":true,"path":"高三·考试·心情/","link":"","permalink":"https://github.com/hzsss/高三·考试·心情/","excerpt":"","text":"收录在某不知名电台公众号：歌单及文章 | 杨富江《考试》 在太阳的余晖照耀之下，铃声宣告着月考的结束。我放下手中的笔，等待着监考老师收走我们的试卷。然后我平静地收拾书包，独自穿过漫长拥挤的走廊，耳边充斥着大家对月考的议论。而我此刻却失去了心情，我知道我又考砸了。看着大家或高兴或气愤的唾沫横飞的情景，一切都像是慢镜头，令人目眩。 回到班上，月考的答案已经发下来了，大家依旧在讨论，好像谁的声音更大谁的答案就是对的。看到答案后，一方狂笑另一方则叹气或者双方都叹气，不过出现后者的情况多一些。而我面无表情地坐在座位上，抚平因考试做不出来时揉皱的试卷，内心感受着正确答案带给我的冲击。其实我是气愤的，绞尽脑汁写了一大堆公式算出来的答案是错误的，而标准答案上静静地躺着两个公式，放肆地嘲笑我。我逐渐迷惘。学了这么多还是有的题目不会做，该错的还是会错。 到现在为止我的高三消耗了一个月零三天，而这次月考已经是第二次月考。我觉得应该去掉“月”字。下次“月”考是在一个礼拜后。 上晚自习的时候，隔壁实验班突然传来一阵爆笑。原来是他们在放电影。我们在暗暗抱怨的时候又自叹不如，谁让人家是实验班的呢，成绩好到每次月考的班级和各科成绩上都写着“实验班除外’。我想我还不能看见烟花就写出烟花绽放时发生反应的化学方程式，我还没有到可以根据小明掉了一枚硬币就能算出太阳质量的程度。我只是一个普通学生，不是用来做实验的小白鼠。所以我们只能默默抱怨，然后埋头继续做题。 我上高三了，我发现我渐渐屈服了。我再也不会在球场上为多得几分而宁愿崴到脚了，再也不会追最新一集的动漫了，再也不会认为语文课不重要而看小说了，再也不会不懂装懂了。我只希望能够有多一点点时间，多做一道题，多背一个单词，在高考中多得一分。 正如一句话所说的那样“天空没有留下翅膀的痕迹，但我知道我已经飞过”。高考，无论结果如何，我都不会后悔，因为我知道我努力过。","categories":[],"tags":[{"name":"life","slug":"life","permalink":"https://github.com/hzsss/tags/life/"}]},{"title":"致高三","slug":"致高三","date":"2014-08-20T00:20:56.000Z","updated":"2018-08-06T09:44:40.035Z","comments":true,"path":"致高三/","link":"","permalink":"https://github.com/hzsss/致高三/","excerpt":"","text":"时间的洪流如此迅猛，以至于我还没有来得及实现我的幻想便把我拉回了现实。中考之后的那个暑假，看了许多校园小说，于是整日期待高中生活。而我还没有像小说中的男主角一样谈一场轰轰烈烈的恋爱或者做一些了不起的事情，我便发现我正现在高三的门口。 还有一天就正式迈入高三了，我身边有些朋友今年就高考完了，这个暑假他们似乎很疯狂，而我却在玩的时候还要时刻担心我的作业。他们买了手机买了电脑然后和一群小伙伴们旅游，而我所谓的娱乐也只是在看书累了的时候对着手机电脑发呆。真的很羡慕他们，逃脱了高三这个牢笼，我甚至也很想跟他们一起疯玩，哪怕一天也好。 高二结束紧接着的就是一个月的补课，老师说补课是为了让我们尽早适应高三生活。曾经觉得让我一个月不上体育课是很痛苦的一件事，但一个月过后，我才发现原来我真的可以忍受没有体育课的日子。会考过后就连可以让我们打打瞌睡发发呆的政史地课都取消了，于是整天绷紧神经，深怕上课一走神漏掉了某个知识点，下课铃成为了我们的催眠曲，课间大家都趴在桌子上。真的是累得不行，补课就这么辛苦，高三应该会更累吧，不过我相信乐在其中。 高三的确很紧张，高二的某个晚自习课间，我和同学下楼散步，突发奇想地来到了高三的楼下。办公室出来一个老师，看见了我俩：“同学高三了怎么这么悠闲，不如帮我搬点东西吧，来来来。”搬完后便在高三走廊走了一遍，一种紧张感油然而生。当我们高三的时候，那些从教室门口经过的学弟学妹们也会是这种感觉吧，而我也会忙得没有时间往窗外漂亮的女生多看两眼吧。 回想起高一高二虽然没有像校园小说那样，但也不失精彩与快乐。同学们就像一个大家庭，校运会或者打班赛大家都很团结努力，某个同学受伤生病了大家都会帮助他，或者某个同学摔倒了大家先笑够了再把他扶起来……最印象深刻的就是暑假补课后布置考场，我和好朋友晚上溜到空荡荡的考场，然后偷偷走进了女厕所。后来在考场外吹口哨吓得某个女老师脸都绿了笔也掉了，最后一路狂奔回到教室。诸如此类，我相信这些经历必将成为我们最好的回忆。 高中生涯的最后一个暑假就要结束了， 再见了动漫，再见了懒觉，再见了手机。老师说高三要拒绝一切诱惑，一切都是为了高考。说了这么多次努力，这次由不得你再说大话了，你不说你也得努力。士兵总有上战场的那一天，到时候身不由己也没有退路了。 既然回忆过去，痛苦的相思忘不了，不如活在当下，珍惜眼前的一切。至于未来，高考后再来幻想吧，毕竟，未来，未曾来。","categories":[],"tags":[{"name":"life","slug":"life","permalink":"https://github.com/hzsss/tags/life/"}]},{"title":"暑假","slug":"暑假","date":"2013-08-30T14:22:22.000Z","updated":"2018-08-04T14:43:33.834Z","comments":true,"path":"暑假/","link":"","permalink":"https://github.com/hzsss/暑假/","excerpt":"","text":"经历了三天但却觉得漫长的期末考试以后，暑假如期而至，幻想着暑假的种种快乐和自由，心里自然清凉。但到今天暑假快结束的时候，却觉得与自己的幻想有着天壤之别。毕竟，只是幻想。 暑假的第一天，就别有兴致的买了一把吉他，还报了培训班，记得周杰伦说过一技之长比学历重要，于是那天晚上便充满了斗志，想象着自己弹吉他给女生听就觉得很帅。第二天准时来到培训班，认真练习了一整天后便觉得很辛苦很无聊。再过几天发现那些老师竟然对我爱理不理，之后的几天感觉什么都没学到，一个礼拜后我很潇洒地离开了，发誓再也不去那种地方见到那种老师。对吉他也有了阴影，不会就不会，我将来又不是靠弹吉他吃饭。现在还是高中生，学习才是重中之重，吉他玩得再好，高考也不会给你加分。 过了几天，大哥和他同学去了打暑期工，而我则遵守着曾经跟班主任商量的计划每天上午都来学校学习，一开始也是很有斗志，但几天后发现根本没有效率，但还是每天都去，心里想着，暑假嘛，那么认真干嘛。但是现在我明白了，不应该放纵自己，我也明白了 ，老师说的话多数是错误的，我更加不相信老师了。暑假前定制的目标，到现在没有完成几个，比如说一个月写完暑假作业啊，看完《三国演义》和《红楼梦》啊，每天写日记啊之类的。也后悔没有跟大哥去打暑期工，在异地总是能够让自己见识世面，而且还能有钱自由地买东西，真好。 每天下午都会去打羽毛球，挥洒汗水，不会时不时地玩手机电脑，那时就会觉得很开心很有意义。因为都是些志同道合的同学，更有共同语言，一起切磋，一起交流，一起进步，一起大声地笑。又让我想起了某些女生，只会勾心斗角，只会嫉妒，只会玩心机，或者只会犯忧伤，只会沉迷于所谓的爱，那些真是恶心无聊，人生不只是有心机或者爱恨情仇，还有很多有意义的事。相比之下，我们活的有意义多了。 看过《中国合伙人》之后，更加对自己一个月来的无所作为后悔，自己真是太窝囊了——做事不好好考虑，不会坚持，遇到困难不会勇敢地面对和想办法解决，满足于现状，不思进取，目光短浅……自己这样一定会一事无成，所以不能再这样下去，如果我不逼自己一下，我永远都不会知道自己有多强大，我可以平凡但绝对不可以平庸，绝对不可以！我也很庆幸自己城府不深，不会勾心斗角。也很谢谢张玺以前能够听我倾诉，开导我，对感情渐渐看淡，明白学习才是重要。 八月，我回到龙岭，第一天就去了初中时每个周末都会去的球场打球，没想到初中时的好朋友都来了，一年了，大家都变了好多，但是彼此之间的感情是不会变的。那天打球，仿佛又回到了从前那无忧无虑的日子，阳光照耀着少年，那时的天空依旧很蓝。 第二天，我们几个朋友去了赣州，其中一个在赣州读书，于是便到他学校去玩，竟然还有几个外国人，我们自然很是兴奋，他说他有个日本同学叫叉叉君，于是我们商量着要不要我们几个人揍他一顿，直到他跪下来求饶并说出“钓鱼岛是中国的”，我们才肯罢休。学校好多树，很有夏天的感觉。然后去了八镜台那古城墙，想象着古时候赶考书生与二姑娘在柳树下吟诗作对，谈笑风生，就觉得很羡慕。沿着城墙走，忽然看到一棵树紧贴着城墙生长，于是我们几个伙伴们马上爬了上去，哈哈，那感觉真好。在城墙上走着，于是又联想到《御龙在天》里攻城的壮观景象，越来越想回到古时候，十二年前的白日梦，十二年后的才高八斗。 然后又来到江边，风吹动着我们的头发，水汽扑面，让我们更加清爽，我相信几年后回想起来一定是青春的感觉。 终于决定不去学校学习了，因为没有效率，在我看来是错误的，我现在一定要改变，虽然被班主任纠缠着叫我回去学校学习，但被我拒绝了，我想改变就从现在开始。每天我都在一高三朋友家和他一起认真学习，下午就和他还有他同学一起打篮球，慢慢的就有认识了他同学，球技和身体也有了提高，很喜欢那些天单纯而又充实的日子。 说到动漫, 这个看得最多的就是哆啦a梦了，真的很好看。最喜欢的还是太空和海底了，真希望也能去探险，和小伙伴们一起。可是现在，我的小伙伴呢？大多数时间还是一个人，不说悲伤孤独之类的话了，男人嘛，何必伤春悲秋的！像大雄和胖虎还有小夫静香一样，做个单纯的人，有小伙伴们，随时可以感到温暖，一起探险，一起经历，一起感动。也真希望身边有一个哆啦a梦，能够用任意门去探险，最后总是平安无事。那些道具，那些探险，那些梦幻，或许只存在于我的想象中吧。我不会失去想象力，因为我相信属于我的哆啦a梦存在于此。 发现自己变了，至少不会像去年一样玩忧郁了，爱情什么的，高中是不可能的，因为高考之后还是难逃分开的命运，这一点我理解深刻，也还是因为有张玺开导呐，真心想说一句thank you very much！记得自己初中的时候是多么的无忧无虑，整天瞎闹还有放肆地笑，这个学期终于有点回到当初的感觉。至今还认为今年遇到的许多同学朋友都是命运，也许改变注定要发生。这个学期成绩一直不如意，自己也很着急。这个暑假看了一本书《高考季》，那些状元们的成绩绝对不是盖的，而他们的努力我想我做不到，但是我不甘堕落，无论怎样我都会努力的。也许家人也许同学会嘲笑我，我的目标是浙大！ 暑假快要结束了，评价的话也只能说不如意了。但何必去遗憾，只有反思自己的缺点，勇敢迈出“改变”这一步，自己的梦想才可能实现。——“如果连尝试都不敢的话，那你就真的太懦落了。”","categories":[],"tags":[{"name":"life","slug":"life","permalink":"https://github.com/hzsss/tags/life/"}]}]}