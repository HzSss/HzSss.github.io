{"title":"iOS开发之深复制和浅复制","slug":"iOS开发之深复制和浅复制","date":"2018-04-09T07:09:35.000Z","updated":"2018-08-05T08:15:38.056Z","comments":true,"excerpt":"","content":"<p>###概述</p>\n<ul>\n<li>浅复制<br>并不拷贝对象本身，仅仅是拷贝指向对象的指针。</li>\n<li>深复制<br>直接拷贝整个对象内存到另一块内存中。</li>\n</ul>\n<p>无论是深复制还是浅复制，被复制的对象都会被复制一份。浅复制只是复制指针，而深复制除了复制指针外，还会复制指针指向的内容。如下图所示：<br><img src=\"https://upload-images.jianshu.io/upload_images/6365912-bc5ac092e0d62987.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"copy.png\"></p>\n<h3 id=\"copy-与-mutableCopy\"><a href=\"#copy-与-mutableCopy\" class=\"headerlink\" title=\"copy 与 mutableCopy\"></a>copy 与 mutableCopy</h3><p>不论是集合类对象，还是非集合类对象，接受到<code>copy</code>和<code>mutableCopy</code>消息时，都会循序一下准则。</p>\n<ul>\n<li><code>copy</code>返回<code>immutable</code>对象。如果对<code>copy</code>返回值使用<code>mutable</code>对象接口，就会crash。</li>\n<li><code>mutableCopy</code>返回<code>mutable</code>对象。</li>\n</ul>\n<p>###非集合类对象的 copy 与 mutableCopy<br>系统非集合类对象指的是<code>NSString</code>，<code>NSNumber</code>之类的对象。下面来看一个例子：</p>\n<pre><code>// 不可变对象复制\nNSString *str = @&quot;haha&quot;;\nNSString *strCopy = [str copy];\nNSMutableString *strMCopy = [str mutableCopy];\n\nNSLog(@&quot;%p&quot;, str);\nNSLog(@&quot;%p&quot;, strCopy);\nNSLog(@&quot;%p&quot;, strMCopy);\n\n---------------------------------输出---------------------------------\n2018-04-09 18:21:08.339512+0800 copyTest[42882:16259329] 0x10314b078\n2018-04-09 18:21:08.339685+0800 copyTest[42882:16259329] 0x10314b078\n2018-04-09 18:21:08.339757+0800 copyTest[42882:16259329] 0x60c0002568c0\n</code></pre><p>我们可以看到，<code>strCopy</code>和<code>str</code>的地址一样，说明进行了指针复制，而<code>strMCopy</code>和<code>str</code>地址不一样，说明进行了内容复制。</p>\n<pre><code>// 可变对象复制\nNSMutableString *mStr = [NSMutableString stringWithString:@&quot;hahaha&quot;];\nNSString *mStrCopy = [mStr copy];\nNSString *mStrMCopy = [mStr mutableCopy];\n\nNSLog(@&quot;%p&quot;, mStr);\nNSLog(@&quot;%p&quot;, mStrCopy);\nNSLog(@&quot;%p&quot;, mStrMCopy);\n\n---------------------------------输出---------------------------------\n2018-04-09 18:21:08.339932+0800 copyTest[42882:16259329] 0x60800005d100\n2018-04-09 18:21:08.340003+0800 copyTest[42882:16259329] 0xa006168616861686\n2018-04-09 18:21:08.340051+0800 copyTest[42882:16259329] 0x608000241020\n</code></pre><p>此时<code>mStr</code>，<code>mstrCopy</code>和<code>mStrMCopy</code>返回的对象内存地址都不一样，说明进行了内容复制。</p>\n<p>可以总结为以下情况：</p>\n<blockquote>\n<pre><code>[immutableObject copy] 浅复制，不可变对象copy后，生成不可变对象，依然无法修改，指针指向同一块内存。\n[immutableObject mutableCopy] 深复制，不可变对象mutableCopy后，生成可变对象，可以修改，指针指向不同内存。\n[mutableObject copy] 深复制，可变对象copy后，生成不可变对象，变成无法修改，指针指向不同内存。\n[mutableObject mutableCopy] 深复制，可变对象mutableCopy后，生成可变对象，可以修改，指针指向不同内存。\n</code></pre></blockquote>\n<p>###集合类对象的 copy 与 mutableCopy<br>集合类对象是指NSArray、NSDictionary、NSSet之类的对象。下面来看一个例子：</p>\n<pre><code>// 不可变对象复制\nNSArray *array1 = @[@1, @&quot;asdas&quot;];\n\nNSArray *array1Copy = [array1 copy];\nNSMutableArray *array1MCopy = [array1 mutableCopy];\n\nNSLog(@&quot;%p&quot;, array1);\nNSLog(@&quot;%p&quot;, array1Copy);\nNSLog(@&quot;%p&quot;, array1MCopy);\n---------------------------------输出---------------------------------\n2018-04-09 18:33:17.954789+0800 copyTest[42935:16321517] 0x604000030160\n2018-04-09 18:33:17.954860+0800 copyTest[42935:16321517] 0x604000030160\n2018-04-09 18:33:17.954935+0800 copyTest[42935:16321517] 0x60400004aad0\n</code></pre><p>可以看到<code>array1</code>和<code>array1Copy</code>内存地址是一样的，而<code>array1</code>和<code>array1MCopy</code>内存地址是不一样的。说明<code>copy</code>进行了指针复制，而<code>mutableCopy</code>进行了内容复制。</p>\n<pre><code>// 可变对象复制\nNSMutableArray *array = [NSMutableArray array];\n[array addObject:@2];\n\nNSArray *arrayCopy = [array copy];\nNSMutableArray *arrayMCopy = [array mutableCopy];\n\nNSLog(@&quot;%p&quot;, array);\nNSLog(@&quot;%p&quot;, arrayCopy);\nNSLog(@&quot;%p&quot;, arrayMCopy);\n\n---------------------------------输出---------------------------------\n2018-04-09 18:33:17.954271+0800  copyTest[42935:16321517] 0x60400004ab30\n2018-04-09 18:33:17.954446+0800  copyTest[42935:16321517] 0x6040000065a0\n2018-04-09 18:33:17.954526+0800  copyTest[42935:16321517] 0x60400004ab60\n</code></pre><p>此时<code>array</code>，<code>arrayCopy</code>和<code>arrayMCopy</code>返回的对象内存地址都不一样，说明进行了内容复制。<br>同样我们可以得出结论：</p>\n<ul>\n<li>在集合类对象中，对<code>immutable</code>对象进行<code>copy</code>，是指针复制，<code>mutableCopy</code>是内容复制；对<code>mutable</code>对象进行<code>copy</code>和<code>mutableCopy</code>都是内容复制。但是：集合对象的内容复制仅限于对象本身，对象元素仍然是指针复制。<blockquote>\n<p>   <code>[immutableObject copy] // 浅复制</code><br><code>[immutableObject mutableCopy] //单层深复制</code><br><code>[mutableObject copy] //单层深复制</code><br><code>[mutableObject mutableCopy] //单层深复制</code></p>\n</blockquote>\n</li>\n</ul>\n<p>这个代码结论和非集合类的非常相似。但是如果要对集合中的对象复制元素怎么办？如果在多层数组中，对第一层进行内容拷贝，其它层进行指针拷贝，这种情况是属于深复制，还是浅复制？对此，<a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Collections/Articles/Copying.html\" target=\"_blank\" rel=\"noopener\">苹果官网文档</a>有这样一句话描述</p>\n<blockquote>\n<p><code>This kind of copy is only capable of producing a one-level-deep copy. If you only need a one-level-deep copy, you can explicitly call for one as in Listing 2</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Listing 2 Making a deep copy:</span><br><span class=\"line\">NSArray *deepCopyArray=[[NSArray alloc] initWithArray:someArray copyItems:YES];</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>对于集合类型的对象，将 <code>initWithArray:copyItems:</code>第二个参数设置成<code>YES</code>时，会对集合内每一个元素发送<code>copyWithZone:</code>消息，元素进行复制，但是对于元素中指针类型的成员变量，依然是浅拷贝，因此这种拷贝被称为单层深拷贝<code>（one-level-deep copy）</code>。</p>\n<p>###如何进行深复制呢？<br>如果想进行完全的深复制，可以先通过<code>NSKeyedArchiver</code>将对象归档，再通过 <code>NSKeyedUnarchiver</code> 将对象解归档。由于在归档时，对象中每个成员变量都会收到 <code>encodeWithCoder:</code>消息，相当于将对象所有的数据均序列化保存到磁盘上（可以看成换了种数据格式的复制），再通过<code>initWithCoder:</code>解归档时，就将拷贝过的数据经过转换后读取出来，深复制。</p>\n<pre><code>NSArray *trueDeepCopyArray = [NSKeyedUnarchiver unarchiveObjectWithData:[NSKeyedArchiver archivedDataWithRootObject:oldArray]];\n</code></pre><p>###小结</p>\n<ul>\n<li>浅复制<code>(shallow copy)</code>：在浅复制操作时，对于被复制对象的每一层都是指针复制。</li>\n<li>深复制<code>(one-level-deep copy)</code>：在深复制操作时，对于被复制对象，至少有一层是深复制。</li>\n<li>完全复制<code>(real-deep copy)</code>：在完全复制操作时，对于被复制对象的每一层都是对象复制。</li>\n</ul>\n<p>###补充</p>\n<pre><code>NSString *str = @&quot;string&quot;;\nNSLog(@&quot;%p&quot;, str);\n\nstr = @&quot;newString&quot;;\nNSLog(@&quot;%p&quot;, str);\n---------------------------------输出---------------------------------\n2018-04-09 18:47:58.582265+0800 copyTest[43000:16423995] 0x10c96d158\n2018-04-09 18:47:58.582298+0800 copyTest[43000:16423995] 0x10c96d178\n</code></pre><p>此处修改的是内存地址。所以第二行应该这样理解：将<code>@”newStirng”</code>当做一个新的对象，将这段对象的内存地址赋值给<code>str</code>。</p>\n","thumbnail":"https://upload-images.jianshu.io/upload_images/6365912-bc5ac092e0d62987.png","categories":[],"tags":[{"name":"iOS","path":"api/tags/iOS.json"}]}