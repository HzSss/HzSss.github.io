{"title":"Object-C Runtime 及消息发送与转发","slug":"Object-C-Runtime-及消息发送与转发","date":"2018-08-05T06:51:45.000Z","updated":"2018-08-05T07:20:01.966Z","comments":true,"excerpt":"","content":"<h3 id=\"什么是-Runtime\"><a href=\"#什么是-Runtime\" class=\"headerlink\" title=\"什么是 Runtime\"></a>什么是 Runtime</h3><p>Objective-C语言是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理。之所以能具备这种特性，离不开运行时系统即<code>objc Runtime</code>，<code>objc Runtime</code>即 <code>Runtime</code>库。<code>Runtime</code>很好的解决了如何在运行时期找到调用方法这样的问题。</p>\n<h3 id=\"类与对象基础数据结构\"><a href=\"#类与对象基础数据结构\" class=\"headerlink\" title=\"类与对象基础数据结构\"></a>类与对象基础数据结构</h3><h4 id=\"Class\"><a href=\"#Class\" class=\"headerlink\" title=\"Class\"></a>Class</h4><p>Objective-C类是由Class类型来表示的，它实际上是一个指向objc_class结构体的指针。它的定义如下：<br><code>typedef struct objc_class *Class;</code><br>我们再来看<code>objc/runtime.h</code>中<code>objc_class</code>结构体的定义如下：</p>\n<pre><code>struct objc_class {\n  Class isa  OBJC_ISA_AVAILABILITY;\n  #if !__OBJC2__\n  Class super_class                     OBJC2_UNAVAILABLE;  // 父类\n  const char *name                        OBJC2_UNAVAILABLE;  // 类名\n  long version                            OBJC2_UNAVAILABLE;  // 类的版本信息，默认为0\n  long info                              OBJC2_UNAVAILABLE;  // 类信息，供运行期使用的一些位标识\n  long instance_size                     OBJC2_UNAVAILABLE;  // 该类的实例变量大小\n  struct objc_ivar_list *ivars           OBJC2_UNAVAILABLE;  // 该类的成员变量链表\n  struct objc_method_list **methodLists   OBJC2_UNAVAILABLE;  // 方法定义的链表\n  struct objc_cache *cache                OBJC2_UNAVAILABLE;  // 方法缓存\n  struct objc_protocol_list *protocols   OBJC2_UNAVAILABLE;  // 协议链表\n  #endif\n} OBJC2_UNAVAILABLE;\n</code></pre><p>其中，有几个字段是我们需要掌握的。<br>1.<code>isa</code>：需要注意的是在<code>Objective-C</code>中，所有的类自身也是一个对象，这个对象的<code>Class</code>里面也有一个<code>isa</code>指针，它指向<code>metaClass</code>(元类)。<br>2.<code>super_class</code>：指向该类的父类，如果该类已经是最顶层的根类(如NSObject或NSProxy)，则<code>super_class</code>为NULL。<br>3.<code>methodLists</code>：看名字也容易理解，这个<code>methodLists</code>就是用来存放方法列表的。<br>4.<code>cache</code>：用于缓存最近使用的方法。<br>5.<code>version</code>：我们可以使用这个字段来提供类的版本信息。这对于对象的序列化非常有用，它可是让我们识别出不同类定义版本中实例变量布局的改变。</p>\n<h3 id=\"元类（Meta-Class）\"><a href=\"#元类（Meta-Class）\" class=\"headerlink\" title=\"元类（Meta Class）\"></a>元类（Meta Class）</h3><p>所有的类自身也是一个对象，我们可以向这个对象发送消息(即调用类方法)。既然是对象，那么它也是一个<code>objc_object</code>指针，它包含一个指向其类的一个<code>isa</code>指针。那么这些就有一个问题了，这个<code>isa</code>指针指向什么呢？这个类的<code>isa</code>指针必须指向一个包含这些类方法的一个<code>objc_class</code>结构体。这就引出了<code>meta-class</code>的概念：<code>meta-class</code>是一个类对象的类。<br>当我们向一个对象发送消息时，<code>runtime</code>会在这个对象所属的这个类的方法列表中查找方法；而向一个类发送消息时，会在这个类的<code>meta-class</code>的方法列表中查找。<br><code>meta-class</code>之所以重要，是因为它存储着一个类的所有类方法。每个类都会有一个单独的<code>meta-class</code>，因为每个类的类方法基本不可能完全相同。<br>再深入一下，<code>meta-class</code>也是一个类，也可以向它发送一个消息，那么它的<code>isa</code>又是指向什么呢？为了不让这种结构无限延伸下去，<code>Objective-C</code>的设计者让所有的<code>meta-class</code>的<code>isa</code>指向基类的<code>meta-class</code>，以此作为它们的所属类。即，任何<code>NSObject</code>继承体系下的<code>meta-class</code>都使用<code>NSObject</code>的<code>meta-class</code>作为自己的所属类，而基类的<code>meta-class</code>的<code>isa</code>指针是指向它自己。这样就形成了一个完美的闭环。<br>通过上面的描述，再加上对<code>objc_class</code>结构体中<code>super_class</code>指针的分析，我们就可以描绘出类及相应<code>meta-class</code>类的一个继承体系了，如下图所示：<br><img src=\"https://upload-images.jianshu.io/upload_images/6365912-dcdc6ad08b4b4dbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"1.png\"></p>\n<pre><code>MyClass *myClass = [[MyClass alloc] init];\n\nClass class = [myClass class];\nClass metaClass = object_getClass(class);\nClass metaOfMetaClass = object_getClass(metaClass);\nClass rootMetaClass = object_getClass(metaOfMetaClass);\nClass superclass = class_getSuperclass(class);\nClass superOfSuperclass = class_getSuperclass(superclass);\nClass superOfMetaOfSuperclass = class_getSuperclass(object_getClass(superclass));\n\nNSLog(@&quot;MyClass 实例对象是：%p&quot;,myClass);\nNSLog(@&quot;MyClass 类对象是：%p&quot;,class);\nNSLog(@&quot;MyClass 元类对象是：%p&quot;,metaClass);\nNSLog(@&quot;MyClass 元类对象的元类对象是：%p&quot;,metaOfMetaClass);\nNSLog(@&quot;MyClass 根元类对象是：%p&quot;,rootMetaClass);\nNSLog(@&quot;MyClass 父类是：%@&quot;,class_getSuperclass(class));\nNSLog(@&quot;MyClass 父类的父类是：%@&quot;,superOfSuperclass);\nNSLog(@&quot;MyClass 父类的元类的父类是：%@&quot;,superOfMetaOfSuperclass);\n\nNSLog(@&quot;NSObject 元类对象是：%p&quot;,object_getClass([NSObject class]));\nNSLog(@&quot;NSObject 父类是：%@&quot;,[[NSObject class] superclass]);\nNSLog(@&quot;NSObject 元类对象的父类是：%@&quot;,[object_getClass([NSObject class]) superclass]);\n\n//输出：\nMyClass 实例对象是：0x60c00000b8d0\nMyClass 类对象是：0x109ae3fd0\nMyClass 元类对象是：****0x109ae3fa8\nMyClass 元类对象的元类对象是：****0x10ab02e58**\nMyClass 根元类对象是：0x10ab02e58\nMyClass 父类是：NSObject\nMyClass 父类的父类是：(null)\nMyClass 父类的元类的父类是：NSObject\nNSObject 元类对象是：0x10ab02e58\nNSObject 父类是：(null)\nNSObject 元类对象的父类是：NSObject\n</code></pre><p>现在我们能知道各种对象之间的关系</p>\n<blockquote>\n<p>实例对象通过 isa 指针，找到类对象 Class；类对象同样通过 isa 指针，找到元类对象；元类对象也是通过 isa 指针，找到根元类对象；最后，根元类对象的 isa 指针，指向自己。可以发现 NSObject 是整个消息机制的核心，绝大数对象都继承自它。</p>\n</blockquote>\n<h3 id=\"methodLists\"><a href=\"#methodLists\" class=\"headerlink\" title=\"methodLists\"></a>methodLists</h3><p>我们再来看看<code>objc_method_list</code>这个结构体</p>\n<pre><code>struct objc_method_list {\n  struct objc_method_list * _Nullable obsolete OBJC2_UNAVAILABLE;\n\n  int method_count OBJC2_UNAVAILABLE;\n  #ifdef __LP64__\n  int space  OBJC2_UNAVAILABLE;\n  #endif\n  /* variable length structure */\n  struct objc_method method_list[1]  OBJC2_UNAVAILABLE;\n}\n</code></pre><p>里面的<code>objc_method</code>，也就是我们熟悉的<code>Method</code></p>\n<pre><code>struct objc_method {\n  SEL _Nonnull method_name OBJC2_UNAVAILABLE;         //方法的名称\n  char * _Nullable method_types  OBJC2_UNAVAILABLE;   //方法的类型\n  IMP _Nonnull method_imp  OBJC2_UNAVAILABLE;         // 方法的具体实现\n}\n</code></pre><p>由此我们可以得出实例对象调用方法的大致逻辑：</p>\n<pre><code>MyClass *myClass = [[MyClass alloc] init];\n[myClass printLog];\n</code></pre><blockquote>\n<p>先被编译成 <code>((void (*)(id, SEL))(void *) objc_msgSend)(myClass, @selector(printLog));</code><br>沿着入参<code>myClass</code>的<code>isa</code>指针，找到<code>myClass</code>的类对象（<code>Class</code>），也就是 <code>MyClass</code><br>接着在<code>MyClass</code>的方法列表<code>methodLists</code>中，找到对应的<code>Method</code><br>最后找到 <code>Method</code> 中的 <code>IMP</code> 指针，执行具体实现</p>\n</blockquote>\n<p>由上文，我们已经知道，实例对象是通过<code>isa</code>指针，找到其类对象（<code>Class</code>）中保存的方法列表中的具体实现的。<code>printLog</code>方法就是保存在<code>MyClass</code>中的。<br>那么如果是个类方法，又是保存在什么地方的呢？我们也知道了类对象的<code>isa</code>指针是指向元类对象的。那么不难得出：</p>\n<blockquote>\n<p>类对象的类方法，是保存在元类对象中的！</p>\n</blockquote>\n<h3 id=\"cache\"><a href=\"#cache\" class=\"headerlink\" title=\"cache\"></a>cache</h3><p>我们大概知道，方法是通过<code>isa</code>指针，查找<code>Class</code> 中的<code>methodLists</code>的。如果子类没实现对应的方法实现，还会沿着父类去查找。整个工程，可能有成万上亿个方法，是如何解决性能问题的呢？如果每调用一次都需要遍历<code>methodLists</code>，性能是非常差的。所以引入了 <code>Class Cache</code> 机制：<code>Class Cache</code> 认为，当一个方法被调用，那么它之后被调用的可能性就越大。<br>查找方法时，会先从缓存中查找，找到直接返回 ；找不到，再去<code>Class</code>的方法列表中找。<br>在上文中 Class 的定义中，我们可以发现 cache：<br><code>struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE;</code><br>说明了缓存是存在类中的，每个类都有一份方法缓存，而不是每个类的 object 都保存了一份。</p>\n<h3 id=\"父类（superclass）\"><a href=\"#父类（superclass）\" class=\"headerlink\" title=\"父类（superclass）\"></a>父类（superclass）</h3><p>在<code>Objective-C</code>中，子类调用一个方法，如果没有子类没有实现，父类实现了，会去调用父类的实现。上文中，找到<code>methodLists</code>后，寻找 <code>Method</code> 的大致过程如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/6365912-83f14b531a14d3ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"2.png\"></p>\n<blockquote>\n<p>ps: 其实这里的寻找过程远没有这么简单，可能会遍历很多遍，因为我们可能会在运行时动态的添加方法（比如<code>category</code>）。遍历的过程中同样不时的去查询缓存表。</p>\n</blockquote>\n<h3 id=\"消息转发\"><a href=\"#消息转发\" class=\"headerlink\" title=\"消息转发\"></a>消息转发</h3><p>如果方法列表（methodLists）没找到对应的 selector 呢？<br><code>[self performSelector:@selector(myTestPrint:) withObject:@&quot;嘻嘻&quot;];</code><br>系统会提供三次补救的机会。</p>\n<h4 id=\"第一次\"><a href=\"#第一次\" class=\"headerlink\" title=\"第一次\"></a>第一次</h4><p><code>+ (BOOL)resolveInstanceMethod:(SEL)sel {} (实例方法)</code><br><code>+ (BOOL)resolveClassMethod:(SEL)sel {}  (类方法)</code></p>\n<p>这两个方法，一个针对实例方法；一个针对类方法。返回值都是<code>Bool</code>。</p>\n<pre><code>// ViewController.m 中\n\nvoid myMethod(id self, SEL _cmd,NSString *nub) {\n  NSLog(@&quot;ifelseboyxx%@&quot;,nub);\n}\n\n+ (BOOL)resolveInstanceMethod:(SEL)sel {\n  #pragma clang diagnostic push\n  #pragma clang diagnostic ignored &quot;-Wundeclared-selector&quot;\n  if (sel == @selector(myTestPrint:)) {\n    #pragma clang diagnostic pop\n    class_addMethod([self class],sel,(IMP)myMethod,&quot;v@:@&quot;);\n    return YES;\n  }else {\n    return [super resolveInstanceMethod:sel];\n  }\n}\n</code></pre><p>我们只需要在 <code>resolveInstanceMethod:</code> 方法中，利用 <code>class_addMethod</code> 方法，将未实现的<code>myTestPrint:</code>绑定到 <code>myMethod</code>上就能完成转发，最后返回<code>YES</code>。</p>\n<h4 id=\"第二次\"><a href=\"#第二次\" class=\"headerlink\" title=\"第二次\"></a>第二次</h4><p><code>- (id)forwardingTargetForSelector:(SEL)aSelector {}</code><br>这个方法要求返回一个<code>id</code>。使用场景一般是将 A 类的某个方法，转发到 B 类的实现中去。<br>使用示例：<br>想转发到 <code>Person</code> 类中的<code>-myTestPrint:</code>方法中：</p>\n<pre><code>@interface Person : NSObject\n@end\n\n@implementation Person\n- (void)myTestPrint:(NSString *)str {\n  NSLog(@&quot;ifelseboyxx%@&quot;,str);\n}\n@end\n// ViewController.m 中\n\n- (id)forwardingTargetForSelector:(SEL)aSelector {\n  #pragma clang diagnostic push\n  #pragma clang diagnostic ignored &quot;-Wundeclared-selector&quot;\n  if (aSelector == @selector(myTestPrint:)) {\n  #pragma clang diagnostic pop\n    return [Person new];\n  }else{\n    return [super forwardingTargetForSelector:aSelector];\n  }\n}\n</code></pre><h4 id=\"第三次\"><a href=\"#第三次\" class=\"headerlink\" title=\"第三次\"></a>第三次</h4><p><code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {}</code><br><code>- (void)forwardInvocation:(NSInvocation *)anInvocation {}</code><br>第一个要求返回一个方法签名，第二个方法转发具体的实现。二者相互依赖，只有返回了正确的方法签名，才会执行第二个方法。<br>这次的转发作用和第二次的比较类似，都是将 A 类的某个方法，转发到 B 类的实现中去。不同的是，第三次的转发相对于第二次更加灵活，<code>forwardingTargetForSelector:</code>只能固定的转发到一个对象；<code>forwardInvocation:</code>可以让我们转发到多个对象中去。<br>使用实例：<br>想转发到 <code>Person</code> 类以及<code>Animal</code>类中的<code>-myTestPrint:</code>方法中：</p>\n<pre><code>@interface Person : NSObject\n@end\n\n@implementation Person\n- (void)myTestPrint:(NSString *)str {\n  NSLog(@&quot;ifelseboyxx%@&quot;,str);\n}\n@end\n@interface Animal : NSObject\n@end\n\n@implementation Animal\n- (void)myTestPrint:(NSString *)str {\n  NSLog(@&quot;tiger%@&quot;,str);\n}\n@end\n\n// ViewController.m 中\n\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {\n  #pragma clang diagnostic push\n  #pragma clang diagnostic ignored &quot;-Wundeclared-selector&quot;\n  if (aSelector == @selector(myTestPrint:)) {\n    #pragma clang diagnostic pop\n    return [NSMethodSignature  signatureWithObjCTypes:&quot;v@:@&quot;];\n  }\n  return [super methodSignatureForSelector:aSelector];\n}\n\n- (void)forwardInvocation:(NSInvocation *)anInvocation {\n  Person *person = [Person new];\n  Animal *animal = [Animal new];\n  if ([person respondsToSelector:anInvocation.selector]) {\n    [anInvocation invokeWithTarget:person];\n  }\n  if ([animal respondsToSelector:anInvocation.selector]) {\n    [anInvocation invokeWithTarget:animal];\n  }\n}\n</code></pre><blockquote>\n<p>⚠️ 如果到了第三次机会，还没找到对应的实现，就会 crash：<br>unrecognized selector sent to instance 0x7f9f817072b0</p>\n</blockquote>\n<p>消息发送和消息转发的过程<br><img src=\"https://upload-images.jianshu.io/upload_images/6365912-1a12a79877ec160c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"3.png\"></p>\n","thumbnail":"/img/runtime.jpg","categories":[],"tags":[{"name":"iOS","path":"api/tags/iOS.json"}]}