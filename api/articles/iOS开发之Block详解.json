{"title":"iOS开发之Block详解","slug":"iOS开发之Block详解","date":"2018-04-24T07:22:14.000Z","updated":"2018-08-05T08:15:50.656Z","comments":true,"excerpt":"","content":"<h4 id=\"Block定义\"><a href=\"#Block定义\" class=\"headerlink\" title=\"Block定义\"></a>Block定义</h4><p>代码块<code>Block</code>是苹果在<code>iOS4</code>开始引入的对<code>C语言</code>的扩展,用来实现匿名函数的特性,<code>Block</code>是一种特殊的数据类型,其可以正常定义变量、作为参数、作为返回值,特殊地,<code>Block</code>还可以保存一段代码,在需要的时候调用,目前Block已经广泛应用于<code>iOS</code>开发中,常用于<code>GCD</code>、动画、排序及各类回调。一句话来形容<code>Block</code>，带有自动变量（局部变量）的匿名函数。</p>\n<blockquote>\n<p><code>Block</code>的声明与赋值只是保存了一段代码段,必须调用才能执行内部代码。</p>\n</blockquote>\n<h4 id=\"Block使用\"><a href=\"#Block使用\" class=\"headerlink\" title=\"Block使用\"></a>Block使用</h4><h6 id=\"1-标准声明与定义\"><a href=\"#1-标准声明与定义\" class=\"headerlink\" title=\"(1) 标准声明与定义\"></a>(1) 标准声明与定义</h6><pre><code>return_type (^blockName)(var_type) = ^return_type (var_type varName) {\n  // ...\n};\nblockName(var);\n</code></pre><h6 id=\"2-当返回类型为void\"><a href=\"#2-当返回类型为void\" class=\"headerlink\" title=\"(2) 当返回类型为void\"></a>(2) 当返回类型为void</h6><pre><code>void (^blockName)(var_type) = ^void (var_type varName) {\n  // ...\n};\nblockName(var);\n</code></pre><p>可省略写成</p>\n<pre><code>void (^blockName)(var_type) = ^(var_type varName) {\n  // ...\n};\nblockName(var);\n</code></pre><h6 id=\"3-当参数类型为void\"><a href=\"#3-当参数类型为void\" class=\"headerlink\" title=\"(3) 当参数类型为void\"></a>(3) 当参数类型为void</h6><pre><code>return_type (^blockName)(void) = ^return_type (void) {\n  // ...\n};\nblockName();\n</code></pre><p>可省略写成</p>\n<pre><code>return_type (^blockName)(void) = ^return_type {\n  // ...\n};\nblockName();\n</code></pre><h6 id=\"4-当返回类型和参数类型都为void\"><a href=\"#4-当返回类型和参数类型都为void\" class=\"headerlink\" title=\"(4) 当返回类型和参数类型都为void\"></a>(4) 当返回类型和参数类型都为void</h6><pre><code>void (^blockName)(void) = ^void (void) {\n  // ...\n};\nblockName();\n</code></pre><p>可省略写成</p>\n<pre><code>void (^blockName)(void) = ^{\n  // ...\n};\nblockName();\n</code></pre><h6 id=\"5-匿名Block\"><a href=\"#5-匿名Block\" class=\"headerlink\" title=\"(5) 匿名Block\"></a>(5) 匿名Block</h6><p>Block实现时，等号右边就是一个匿名Block，它没有blockName，称之为匿名Block：</p>\n<pre><code>^return_type (var_type varName)\n{\n  //...\n};\n</code></pre><h6 id=\"6-typedef简化Block的声明\"><a href=\"#6-typedef简化Block的声明\" class=\"headerlink\" title=\"(6) typedef简化Block的声明\"></a>(6) typedef简化Block的声明</h6><pre><code>// 定义一种无返回值无参数列表的Block类型\ntypedef void(^SayHello)();\n\n// 我们可以像OC中声明变量一样使用Block类型SayHello来声明变量\nSayHello hello = ^(){\n  NSLog(@&quot;hello&quot;);\n};\n\n// 调用后控制台输出&quot;hello&quot;\nhello();\n</code></pre><h4 id=\"Block捕获外部变量\"><a href=\"#Block捕获外部变量\" class=\"headerlink\" title=\"Block捕获外部变量\"></a>Block捕获外部变量</h4><h6 id=\"1-捕获全局变量和静态全局变量\"><a href=\"#1-捕获全局变量和静态全局变量\" class=\"headerlink\" title=\"(1)捕获全局变量和静态全局变量\"></a>(1)捕获全局变量和静态全局变量</h6><pre><code>#import &lt;Foundation/Foundation.h&gt;\n\nint global_a = 1;\nstatic int global_b = 2;\n\nint main(int argc, const char * argv[]) {\n@autoreleasepool {\n\n  void (^myBlock)(void) = ^{\n    global_a++;\n    global_b++;\n\n    NSLog(@&quot;在Block中：global_a = %d, global_b = %d&quot;, global_a, global_b);\n  };\n\n  global_a++;\n  global_b++;\n\n  NSLog(@&quot;在Block外：global_a = %d, global_b = %d&quot;, global_a, global_b);\n\n  myBlock();\n}\nreturn 0;\n}\n</code></pre><p>输出：</p>\n<pre><code>2018-04-24 20:56:10.676151+0800 Block简书代码[83038:38449696] 在Block外：global_a = 2, global_b = 3\n2018-04-24 20:56:10.676303+0800 Block简书代码[83038:38449696] 在Block中：global_a = 3, global_b = 4\n</code></pre><p>可以看到全局变量<code>global_a</code>和静态全局变量<code>global_b</code>在<code>Block</code>中进行了<code>++</code>操作，<code>Block</code>结束后，它们的值依然保留了下来。</p>\n<blockquote>\n<p>通过clang命令将OC转为C++代码来查看一下Block底层实现</p>\n</blockquote>\n<pre><code>int global_a = 1;\nstatic int global_b = 2;\n\nstruct __main_block_impl_0 {\n  struct __block_impl impl;\n  struct __main_block_desc_0* Desc;\n  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {\n    impl.isa = &amp;_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n  }\n};\n  static void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n    global_a++;\n    global_b++;\n\n    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_s6_gg35g_r90q514w_6xv0vb4fr0000gp_T_main_fd88b4_mi_0, global_a, global_b);\n  }\n  static struct __main_block_desc_0 {\n    size_t reserved;\n    size_t Block_size;\n  } __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};\n  int main(int argc, const char * argv[]) {\n    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; \n\n    void (*myBlock)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA));\n\n    global_a++;\n    global_b++;\n\n    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_s6_gg35g_r90q514w_6xv0vb4fr0000gp_T_main_fd88b4_mi_1, global_a, global_b);\n\n    ((void (*)(__block_impl *))((__block_impl *)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock);\n  }\n  return 0;\n}\n</code></pre><p>首先全局变量<code>global_a</code>和静态全局变量<code>global_b</code>的值增加，以及它们被<code>Block</code>捕获进去，这一点很好理解，因为是全局的，作用域很广，他们并没有变成<code>Block</code>结构体<code>__main_block_impl_0</code>的成员变量，因为他们的作用域大，所以可以直接更改他们的值。<code>Block</code>捕获了它们进去之后，在<code>Block</code>里面进行<code>++</code>操作，<code>Block</code>结束之后，它们的值依旧可以得以保存下来。</p>\n<h6 id=\"2-捕获静态变量和局部变量\"><a href=\"#2-捕获静态变量和局部变量\" class=\"headerlink\" title=\"(2)捕获静态变量和局部变量\"></a>(2)捕获静态变量和局部变量</h6><pre><code>#import &lt;Foundation/Foundation.h&gt;\n\nint main(int argc, const char * argv[]) { // 捕获静态变量\n@autoreleasepool {\n  static int static_a = 1;\n\n  void (^myBlock)(void) = ^{\n    static_a++;\n    NSLog(@&quot;static_a = %d&quot;, static_a);\n  };\n  myBlock();\n}\nreturn 0;\n}\n</code></pre><p>输出：</p>\n<pre><code>2018-04-24 21:11:11.337102+0800 Block简书代码[83204:38537226] static_a = 2\n\n\nstruct __main_block_impl_0 {\n  struct __block_impl impl;\n  struct __main_block_desc_0* Desc;\n  int *static_a;\n  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_static_a, int flags=0) : static_a(_static_a) {\n  impl.isa = &amp;_NSConcreteStackBlock;\n  impl.Flags = flags;\n  impl.FuncPtr = fp;\n  Desc = desc;\n  }\n};\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n  int *static_a = __cself-&gt;static_a; // bound by copy\n\n  (*static_a)++;\n\n  NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_s6_gg35g_r90q514w_6xv0vb4fr0000gp_T_main_74a550_mi_0, (*static_a));\n}\n\nstatic struct __main_block_desc_0 {\n  size_t reserved;\n  size_t Block_size;\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};\nint main(int argc, const char * argv[]) {\n  /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; \n  static int static_a = 1;\n\n  void (*myBlock)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;static_a)); // 传入的是静态变量static_a的内存地址\n\n  ((void (*)(__block_impl *))((__block_impl *)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock);\n\n  }\n  return 0;\n}\n</code></pre><p>可以看出，<code>Block</code>捕获了静态变量<code>static_a</code>的内存地址，故可以在<code>Block</code>中对静态变量进行修改。</p>\n<pre><code>#import &lt;Foundation/Foundation.h&gt;\n\nint main(int argc, const char * argv[]) { // 捕获局部变量\n@autoreleasepool {\n  int part_a = 1;\n\n  void (^myBlock)(void) = ^{\n  NSLog(@&quot;part_a = %d&quot;, part_a);\n  };\n\n  myBlock();\n}\n  return 0;\n}\n</code></pre><p>输出：</p>\n<pre><code>2018-04-24 21:17:22.128069+0800 Block简书代码[83415:38568895] part_a = 1\n\n\n\nstruct __main_block_impl_0 {\n  struct __block_impl impl;\n  struct __main_block_desc_0* Desc;\n  int part_a;\n  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _part_a, int flags=0) : part_a(_part_a) {\n    impl.isa = &amp;_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n  }\n};\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n  int part_a = __cself-&gt;part_a; // bound by copy\n\n  NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_s6_gg35g_r90q514w_6xv0vb4fr0000gp_T_main_961862_mi_0, part_a);\n}\n\nstatic struct __main_block_desc_0 {\n  size_t reserved;\n  size_t Block_size;\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};\nint main(int argc, const char * argv[]) {\n  /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; \n  int part_a = 1;\n\n  void (*myBlock)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, part_a)); // 传入的是局部变量part_a的值，故无法在Block中对part_a进行修改\n\n  ((void (*)(__block_impl *))((__block_impl *)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock);\n\n  }\n  return 0;\n}\n</code></pre><p>我们可以发现，系统自动给我们加上的注释，<code>bound by copy</code>，局部变量<code>part_a</code>虽然被捕获进来了，但是是用 <code>__cself-&gt; part_a</code>来访问的。<code>Block</code>仅仅捕获了<code>part_a</code>的值，并没有捕获<code>part_a</code>的内存地址。所以在<code>__main_block_func_0</code>这个函数中即使我们重写这个局部变量<code>part_a</code>的值，依旧没法去改变<code>Block</code>外面自动变量<code>part_a</code>的值。</p>\n<p><code>OC</code>可能是基于这一点，在编译的层面就防止开发者可能犯的错误，因为局部变量没法在<code>Block</code>中改变外部变量的值，所以编译过程中就报编译错误。<br><img src=\"https://upload-images.jianshu.io/upload_images/6365912-b00130fa7fe41173.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Block中不能修改局部变量的值.png\"></p>\n<h6 id=\"3-捕获静态变量和局部变量\"><a href=\"#3-捕获静态变量和局部变量\" class=\"headerlink\" title=\"(3)捕获静态变量和局部变量\"></a>(3)捕获静态变量和局部变量</h6><pre><code>#import &lt;Foundation/Foundation.h&gt;\n\nint main(int argc, const char * argv[]) { // 捕获局部变量\n  @autoreleasepool {\n      __block int part_a = 1;\n\n      void (^myBlock)(void) = ^{\n        part_a++;\n        NSLog(@&quot;part_a = %d&quot;, part_a);\n      };\n    myBlock();\n  }\n  return 0;\n}\n</code></pre><p>输出：</p>\n<pre><code>2018-04-24 21:35:20.456984+0800 Block简书代码[83648:38653724] part_a = 2\n\n\n\nstruct __Block_byref_part_a_0 {\n  void *__isa;\n  __Block_byref_part_a_0 *__forwarding;\n  int __flags;\n  int __size;\n  int part_a;\n};\n\nstruct __main_block_impl_0 {\n  struct __block_impl impl;\n  struct __main_block_desc_0* Desc;\n  __Block_byref_part_a_0 *part_a; // by ref\n  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_part_a_0 *_part_a, int flags=0) : part_a(_part_a-&gt;__forwarding) {\n    impl.isa = &amp;_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n  }\n};\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n  __Block_byref_part_a_0 *part_a = __cself-&gt;part_a; // bound by ref\n\n  (part_a-&gt;__forwarding-&gt;part_a)++;\n  NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_s6_gg35g_r90q514w_6xv0vb4fr0000gp_T_main_61637c_mi_0, (part_a-&gt;__forwarding-&gt;part_a));\n}\nstatic void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;part_a, (void*)src-&gt;part_a, 8/*BLOCK_FIELD_IS_BYREF*/);}\n\nstatic void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;part_a, 8/*BLOCK_FIELD_IS_BYREF*/);}\n\nstatic struct __main_block_desc_0 {\n  size_t reserved;\n  size_t Block_size;\n  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);\n  void (*dispose)(struct __main_block_impl_0*);\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};\nint main(int argc, const char * argv[]) {\n  /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; \n  __attribute__((__blocks__(byref))) __Block_byref_part_a_0 part_a = {(void*)0,(__Block_byref_part_a_0 *)&amp;part_a, 0, sizeof(__Block_byref_part_a_0), 1};\n\n  void (*myBlock)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_part_a_0 *)&amp;part_a, 570425344)); // 传入的是part_a的内存地址，故可以在Block中修改它的值\n\n  ((void (*)(__block_impl *))((__block_impl *)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock);\n\n  }\n  return 0;\n}\n</code></pre><h4 id=\"Block循环引用\"><a href=\"#Block循环引用\" class=\"headerlink\" title=\"Block循环引用\"></a>Block循环引用</h4><p>一般来说我们总会在设置<code>Block</code>之后，在合适的时间回调<code>Block</code>，而不希望回调<code>Block</code>的时候<code>Block</code>已经被释放了，所以我们需要对<code>Block</code>进行<code>copy</code>，<code>copy</code>到堆中，以便后用。<br><code>Block</code>可能会导致循环引用问题，因为<code>Block</code>在拷贝到堆上的时候，会<code>retain</code>其引用的外部变量，那么如果<code>Block</code>中如果引用了他的宿主对象，那很有可能引起循环引用，如：</p>\n<pre><code>TestCycleRetain\n\n- (void) dealloc {\n  NSLog(@&quot;no cycle retain&quot;);\n} \n\n- (id) init {\n  self = [super init];\nif (self) {\n  #if TestCycleRetainCase1\n  //会循环引用\n  self.myblock = ^{\n    [self doSomething];\n  };\n\n  #elif TestCycleRetainCase2\n  //会循环引用\n  __block TestCycleRetain * weakSelf = self;\n  self.myblock = ^{\n    [weakSelf doSomething];\n  };\n\n  #elif TestCycleRetainCase3\n  //不会循环引用\n  __weak TestCycleRetain * weakSelf = self;\n  self.myblock = ^{\n    [weakSelf doSomething];\n  };\n\n  #elif TestCycleRetainCase4\n  //不会循环引用\n  __unsafe_unretained TestCycleRetain * weakSelf = self;\n  self.myblock = ^{\n    [weakSelf doSomething];\n  };\n\n  #endif NSLog(@&quot;myblock is %@&quot;, self.myblock);\n}\nreturn self;\n\n} \n\n- (void) doSomething {\n  NSLog(@&quot;do Something&quot;);\n}\n\n\n\nmain\n\nint main(int argc, char * argv[]) {\n  @autoreleasepool {\n    TestCycleRetain * obj = [[TestCycleRetain alloc] init];\n    obj = nil;\n    return 0;\n  }\n}\n</code></pre><ul>\n<li><code>MRC</code>情况下，用<code>__block</code>可以消除循环引用。</li>\n<li><code>ARC</code>情况下，必须用弱引用才可以解决循环引用问题，<code>iOS 5</code>之后可以直接使用<code>__weak</code></li>\n</ul>\n<p>在上述使用<code>Block</code>中，虽说使用<code>__weak</code>，但是此处会有一个隐患，你不知道<code>self</code>什么时候会被释放，为了保证在<code>Block</code>内不会被释放，我们添加<code>__strong</code>。更多的时候需要配合<code>strongSelf</code>使用，如下：</p>\n<pre><code>__weak __typeof(self) weakSelf = self; \nself.testBlock =  ^{\n  __strong __typeof(weakSelf) strongSelf = weakSelf;\n  [strongSelf test]; \n});\n</code></pre><h4 id=\"Block实现链式编程\"><a href=\"#Block实现链式编程\" class=\"headerlink\" title=\"Block实现链式编程\"></a>Block实现链式编程</h4><p>我们下面就需要使用这些基础知识来实现链式编程和函数式编程。</p>\n<h6 id=\"场景：\"><a href=\"#场景：\" class=\"headerlink\" title=\"场景：\"></a>场景：</h6><p>实现加法计算，比如我需要计算<code>1+2+5+14</code>。通常做法如下：<br>定义加法函数：</p>\n<pre><code>-(NSInteger)addWithParam1:(NSInteger)param1 param2:(NSInteger)param2 {\n  return param1 + param2;\n}\n</code></pre><p>然后调用：</p>\n<pre><code>NSInteger result = [self addWithParam1:1 param2:2];\nresult = [self addWithParam1:result param2:5];\nresult = [self addWithParam1:result param2:14];\nNSLog(@&quot;%zd&quot;,result);\n</code></pre><p>有多少个数字需要相加，我们就需要调用多少次这个方法，相当麻烦。<br>我们想实现如下效果的调用，类似于<code>masonry</code>，也就是所谓的链式编程，看起来就十分优雅。</p>\n<pre><code>int reslut = [NSObject makeCalculate:^(CalculateManager *mgr) {\n  mgr.add(5).add(6).add(7).add(10);\n}];\n</code></pre><p>下面我们就来看看具体的实现过程吧。</p>\n<h6 id=\"1、先定义一个NSObject的分类如下：\"><a href=\"#1、先定义一个NSObject的分类如下：\" class=\"headerlink\" title=\"1、先定义一个NSObject的分类如下：\"></a>1、先定义一个NSObject的分类如下：</h6><pre><code>#import \n\n#import &quot;CalculateManager.h&quot;\n\n@interface NSObject (Calculate)\n\n+ (int)makeCalculate:(void(^)(CalculateManager *))block;\n@end\n\n==============================================================================\n\n#import &quot;NSObject+Calculate.h&quot;\n#import &quot;CalculateManager.h&quot;\n\n@implementation NSObject (Calculate)\n+ (int)makeCalculate:(void (^)(CalculateManager *))block\n{\n  // 创建计算管理者\n  CalculateManager *mgr = [[CalculateManager alloc] init];\n\n  // 执行计算\n  block(mgr);\n\n  return mgr.result;\n}\n@end\n</code></pre><h6 id=\"2、继续定义一个类实现计算过程，比如add：\"><a href=\"#2、继续定义一个类实现计算过程，比如add：\" class=\"headerlink\" title=\"2、继续定义一个类实现计算过程，比如add：\"></a>2、继续定义一个类实现计算过程，比如add：</h6><pre><code>#import \n\n@interface CalculateManager : NSObject\n\n@property (nonatomic, assign) int result;\n\n- (CalculateManager *(^)(int))add;\n@end\n\n\n=======================================================\n\n\n#import &quot;CalculateManager.h&quot;\n\n@implementation CalculateManager\n\n- (CalculateManager * (^)(int))add\n{\n  return ^(int value){\n    _result += value;\n    return self;\n  };\n}\n\n@end\n</code></pre><h5 id=\"3、然后调用\"><a href=\"#3、然后调用\" class=\"headerlink\" title=\"3、然后调用:\"></a>3、然后调用:</h5><pre><code>int reslut = [NSObject makeCalculate:^(CalculateManager *mgr) {\n  mgr.add(5).add(6).add(7).add(10);\n}];\nNSLog(@&quot;%zd&quot;,reslut);\n</code></pre><p>要实现链式调用的一个关键点：就是每次调用<code>add</code>方法必须返回自身，然后才可以继续调用，如此一致循环下去，实现这一切都是<code>Block</code>的功劳。</p>\n<h6 id=\"4、实现过程分析：\"><a href=\"#4、实现过程分析：\" class=\"headerlink\" title=\"4、实现过程分析：\"></a>4、实现过程分析：</h6><p>上面的步骤3，调用<code>nsobject</code>的分类方法<code>makeCalculate:^(CalculateManager *mgr)block</code>，该方法的参数是一个<code>Block</code>，我们在这里传递一个定义好的<code>Block</code>到该函数。<code>Block</code>的实现是<code>mgr.add(5).add(6).add(7).add(10)</code><br>回到步骤1，是分类方法<code>makeCalculate:^(CalculateManager *mgr)block</code>的具体实现，该方法内部初始化一个<code>CalculateManager</code>实例对象<code>mgr</code>，然后作为<code>Block</code>的参数传入<code>block</code>，也就是步骤3的<code>Block</code>内部的<code>mgr</code>参数，然后调用该<code>Block</code>，也就是上一步实现的这句代码<code>mgr.add(5).add(6).add(7).add(10)</code>，然后返回执行完毕后的结果，也就是<code>mgr.result</code>。<br>回到步骤2，是链式调用代码<code>mgr.add(5).add(6).add(7).add(10)</code>的关键，可以看到<code>add</code>方法返回的是一个<code>Block</code>，该<code>Block</code>的实现是累加传递进来的值然后赋值给属性<code>result</code>保存下来，然后返回值是<code>self</code>，也就是<code>CalculateManager</code>实例对象。这样又可以实现点语法继续调用<code>add</code>方法。</p>\n<p>####Block实现函数式编程<br>不了解什么是函数编程的童鞋可以看看这篇文章，作为一个入门了解：</p>\n<p><a href=\"https://link.juejin.im?target=http%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2012%2F04%2Ffunctional_programming.html\" target=\"_blank\" rel=\"noopener\">函数式编程初探</a></p>\n<p>函数编程有两个好处：</p>\n<blockquote>\n<ol>\n<li>去掉了中间变量</li>\n<li>把运算过程写成一系列的函数嵌套调用，逻辑更加清楚</li>\n</ol>\n</blockquote>\n<p>还是上面的例子，不过这次我们想如下写：</p>\n<pre><code>CalculateManager *mgr = [[CalculateManager alloc] init];\n[[[[mgr calculate:^(int result){\n  // 存放所有的计算代码\n  result += 5;\n  result *= 5;\n  return result;\n}]printResult:^(int result) {\n  NSLog(@&quot;第一次计算结果为：%d&quot;,result);\n}]calculate:^int(int result) {\n  result -= 2;\n  result /= 3;\n  return result;\n}]printResult:^(int result) {\n  NSLog(@&quot;第二次计算结果为：%d&quot;,result);\n}];\n</code></pre><p>可以看到计算函数<code>calculate</code>和输出函数<code>printResult</code>可以一直循环嵌套调用，所有的运算过程全部聚在一起，看起来逻辑更加清楚。</p>\n<h5 id=\"下面来看看如何实现：\"><a href=\"#下面来看看如何实现：\" class=\"headerlink\" title=\"下面来看看如何实现：\"></a>下面来看看如何实现：</h5><pre><code>#import \n@interface CalculateManager : NSObject\n@property (nonatomic, assign) int result;\n- (instancetype)calculate:(int(^)(int))calculateBlock;\n-(instancetype)printResult:(void(^)(int))printBlock;\n@end\n\n===========================================================\n\n#import &quot;CalculateManager.h&quot;\n\n@implementation CalculateManager\n- (instancetype)calculate:(int (^)(int))calculateBlock\n{\n  _result =  calculateBlock(_result);\n  return self;\n}\n\n-(instancetype)printResult:(void(^)(int))printBlock{\n  printBlock(_result);\n  return self;\n}\n@end\n</code></pre><p>上面两个函数的关键点在于每次都必须返回<code>self</code>，这样才可以继续嵌套调用其他函数。函数的内部实现是做一些内部处理，然后传入参数来调用<code>block</code>。</p>\n<hr>\n<p>参考链接：</p>\n<blockquote>\n<p><a href=\"https://www.jianshu.com/p/ee9756f3d5f6\" target=\"_blank\" rel=\"noopener\">深入研究Block捕获外部变量和__block实现原理</a><br><a href=\"https://www.jianshu.com/p/14efa33b3562\" target=\"_blank\" rel=\"noopener\">一篇文章看懂iOS代码块Block</a><br><a href=\"https://juejin.im/post/5add619f6fb9a07ac90cced6#heading-32\" target=\"_blank\" rel=\"noopener\">iOS中Block的用法，示例，应用场景，与底层原理解析（这可能是最详细的Block解析）</a><br><a href=\"https://juejin.im/post/57ca8d475bbb500074e8c076\" target=\"_blank\" rel=\"noopener\">Block使用场景</a><br><a href=\"https://juejin.im/post/5ab7739af265da237410f0d6\" target=\"_blank\" rel=\"noopener\">网络回调：Block和Delegate的对比</a><br><a href=\"https://www.jianshu.com/p/2c7a7c53c91a\" target=\"_blank\" rel=\"noopener\">使用FBRetainCycleDetector检测引用循环</a></p>\n</blockquote>\n","thumbnail":"https://upload-images.jianshu.io/upload_images/6365912-b00130fa7fe41173.png","categories":[],"tags":[{"name":"iOS","path":"api/tags/iOS.json"}]}