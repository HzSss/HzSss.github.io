{"title":"关于__block的一些思考","slug":"关于-block的一些思考","date":"2018-08-05T07:48:51.000Z","updated":"2018-08-05T07:52:01.206Z","comments":true,"excerpt":"","content":"<h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><p><a href=\"https://blog.csdn.net/abc649395594/article/details/47086751\" target=\"_blank\" rel=\"noopener\">你真的理解__block修饰符的原理么？</a></p>\n<p><a href=\"https://www.jianshu.com/p/ee9756f3d5f6\" target=\"_blank\" rel=\"noopener\">深入研究Block捕获外部变量和__block实现原理</a></p>\n<h3 id=\"Block-的实现\"><a href=\"#Block-的实现\" class=\"headerlink\" title=\"Block 的实现\"></a>Block 的实现</h3><pre><code>// Block 源码\nint main(int argc, const char * argv[]) {\n@autoreleasepool {\nvoid (^blk)(void) = ^{\nprintf(&quot;Block\\n&quot;);\n};\n\nblk();\n}\nreturn 0;\n}\n</code></pre><p>使用 clang 命令将源码改成编译后的 C/C++ 语言：</p>\n<pre><code>struct __main_block_impl_0 { // block 对象\n  struct __block_impl impl; // 包含 block 的实现\n  struct __main_block_desc_0* Desc; // 包含了 block 的内存管理\n  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) { // 构造函数\n    impl.isa = &amp;_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp; // block 中的代码，包含 __main_block_func_0 方法\n    Desc = desc;\n  }\n};\n// block 中的代码，传入 block 以便获取其中的捕获的值或变量\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n\n  printf(&quot;Block\\n&quot;);\n}\n\nstatic struct __main_block_desc_0 {\n  size_t reserved;\n  size_t Block_size;\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};\nint main(int argc, const char * argv[]) {\n    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool;\n    // 创建一个 block，调用构造方法\n    void (*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA));\n    // 调用 block，即调用 __main_block_func_0 方法\n    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);\n  }\n  return 0;\n}\n</code></pre><p>关系图：<br><img src=\"http://upload-images.jianshu.io/upload_images/6365912-7eae193448c02f95?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<blockquote>\n<p>流程：定义 block 的时候，调用 <strong>main_block_impl_0 的构造函数，创建 block，</strong>main_block_impl_0 结构体中包括 <strong>block_impl（block 的实现，而这个结构体又包含 block 中的代码，及静态方法 </strong>main_block_func_0），并且把捕获进来的变量成为 __main_block_impl_0 的成员变量。</p>\n</blockquote>\n<blockquote>\n<p>调用 block 的时候，即调用 <strong>block_impl 结构体中的 </strong>main_block_func_0 方法，并且把 __block_impl 自身传入方法，以供方法取得值或变量。</p>\n</blockquote>\n<h3 id=\"为什么-block-可以修改自动变量的值\"><a href=\"#为什么-block-可以修改自动变量的值\" class=\"headerlink\" title=\"为什么 __block 可以修改自动变量的值\"></a>为什么 __block 可以修改自动变量的值</h3><pre><code>struct __Block_byref_i_0 {\n  void *__isa;\n  __Block_byref_i_0 *__forwarding;\n  int __flags;\n  int __size;\n  int i;\n};\n\nstruct __main_block_impl_0 {\n  struct __block_impl impl;\n  struct __main_block_desc_0* Desc;\n  __Block_byref_i_0 *i; // by ref\n  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_i_0 *_i, int flags=0) : i(_i-&gt;__forwarding) {\n    impl.isa = &amp;_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n  }\n};\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n  __Block_byref_i_0 *i = __cself-&gt;i; // bound by ref\n\n  (i-&gt;__forwarding-&gt;i)++;\n  printf(&quot;%d\\n&quot;,(i-&gt;__forwarding-&gt;i));\n}\nstatic void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;i, (void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);}\n\nstatic void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);}\n\nstatic struct __main_block_desc_0 {\n  size_t reserved;\n  size_t Block_size;\n  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);\n  void (*dispose)(struct __main_block_impl_0*);\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};\nint main(int argc, const char * argv[]) {\n  /* @autoreleasepool */ { \n    __AtAutoreleasePool __autoreleasepool; \n    __attribute__((__blocks__(byref))) __Block_byref_i_0 i = {(void*)0,(__Block_byref_i_0 *)&amp;i, 0, sizeof(__Block_byref_i_0), 10};\n    void (*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_i_0 *)&amp;i, 570425344));\n\n    (i.__forwarding-&gt;i)++;\n\n    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);\n  }\n  return 0;\n}\n</code></pre><p>block 拷贝到堆上，捕获的自动变量值也拷贝到了堆上。<br><img src=\"https://upload-images.jianshu.io/upload_images/1194012-5f5f486bab68191f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/700\" alt=\"image\"></p>\n<pre><code>#import &lt;Foundation/Foundation.h&gt;\n\nint main(int argc, const char * argv[]) {\n  @autoreleasepool {\n  __block int i = 10;\n  void (^blk)(void) = ^{\n    i++;\n    printf(&quot;%d\\n&quot;,i);\n  };\n\n  i++;\n\n  blk();\n  }\n  return 0;\n}\n// 输出\n12\n</code></pre><p>由于<strong>Block_byref_i_0 中有一个可以指向本类型的 </strong>forwarding 指针。</p>\n<p>在调用 block 之前，即未拷贝之前，栈上的 __forwarding 指向自己，进行一次自增。</p>\n<p>经过拷贝之后，栈上的 <strong>forwarding 指针指向堆上的变量，而堆上的 </strong>forwarding 指针又指向自己。</p>\n<p>这样不论是堆中的变量还是栈中的变量调用 (i-&gt;<strong>forwarding-&gt;i)++; ，都是堆上变量的值发生了改变，而栈中变量的值则指向了堆中变量的值，即对 block 中的变量进行自增操作，栈中的值也发生了改变（</strong>forwarding 指针改变了指向，指向堆中的变量）即对外部的自动变量也可以进行自增操作。</p>\n","thumbnail":"https://upload-images.jianshu.io/upload_images/6365912-7eae193448c02f95","categories":[],"tags":[{"name":"iOS","path":"api/tags/iOS.json"}]}