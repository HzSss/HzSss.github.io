<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Object-C Runtime 及消息发送与转发 | Acan_Dev</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="什么是 RuntimeObjective-C语言是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理。之所以能具备这种特性，离不开运行时系统即objc Runtime，objc Runtime即 Runtime库。Runtime很好的解决了如何在运行时期找到调用方法这样的问题。 类与对象基础数据结构ClassObjective-C类是由Class类型来表示的，它实际上是一个指向">
<meta name="keywords" content="iOS">
<meta property="og:type" content="article">
<meta property="og:title" content="Object-C Runtime 及消息发送与转发">
<meta property="og:url" content="https://github.com/hzsss/Object-C-Runtime-及消息发送与转发/index.html">
<meta property="og:site_name" content="Acan_Dev">
<meta property="og:description" content="什么是 RuntimeObjective-C语言是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理。之所以能具备这种特性，离不开运行时系统即objc Runtime，objc Runtime即 Runtime库。Runtime很好的解决了如何在运行时期找到调用方法这样的问题。 类与对象基础数据结构ClassObjective-C类是由Class类型来表示的，它实际上是一个指向">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/6365912-dcdc6ad08b4b4dbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/6365912-83f14b531a14d3ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/6365912-1a12a79877ec160c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2018-08-05T08:15:26.292Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Object-C Runtime 及消息发送与转发">
<meta name="twitter:description" content="什么是 RuntimeObjective-C语言是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理。之所以能具备这种特性，离不开运行时系统即objc Runtime，objc Runtime即 Runtime库。Runtime很好的解决了如何在运行时期找到调用方法这样的问题。 类与对象基础数据结构ClassObjective-C类是由Class类型来表示的，它实际上是一个指向">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/6365912-dcdc6ad08b4b4dbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
  
    <link rel="alternate" href="/atom.xml" title="Acan_Dev" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/plugin/bganimation/bg.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <div class="widget-wrap mobile-header">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="https://avatars0.githubusercontent.com/u/20333903?v=3&amp;s=460">
    <h2 class="author">Acan_Dev</h2>
    <h3 class="description">You only live once</h3>
    <div class="count-box">
      <a href="/archives"><div><strong>20</strong><br>文章</div></a>
      <a href="/categories"><div><strong>0</strong><br>分类</div></a>
      <a href="/tags"><div><strong>5</strong><br>标签</div></a>
    </div>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
    </ul>
  </div>
</div>

        <section id="main"><article id="post-Object-C-Runtime-及消息发送与转发" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/Object-C-Runtime-及消息发送与转发/" class="article-date">
  <time class="post-time" datetime="2018-03-29T06:51:45.000Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">29</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Object-C Runtime 及消息发送与转发
    </h1>
  

        <div>
          
          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="什么是-Runtime"><a href="#什么是-Runtime" class="headerlink" title="什么是 Runtime"></a>什么是 Runtime</h3><p>Objective-C语言是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理。之所以能具备这种特性，离不开运行时系统即<code>objc Runtime</code>，<code>objc Runtime</code>即 <code>Runtime</code>库。<code>Runtime</code>很好的解决了如何在运行时期找到调用方法这样的问题。</p>
<h3 id="类与对象基础数据结构"><a href="#类与对象基础数据结构" class="headerlink" title="类与对象基础数据结构"></a>类与对象基础数据结构</h3><h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h4><p>Objective-C类是由Class类型来表示的，它实际上是一个指向objc_class结构体的指针。它的定义如下：<br><code>typedef struct objc_class *Class;</code><br>我们再来看<code>objc/runtime.h</code>中<code>objc_class</code>结构体的定义如下：</p>
<pre><code>struct objc_class {
  Class isa  OBJC_ISA_AVAILABILITY;
  #if !__OBJC2__
  Class super_class                     OBJC2_UNAVAILABLE;  // 父类
  const char *name                        OBJC2_UNAVAILABLE;  // 类名
  long version                            OBJC2_UNAVAILABLE;  // 类的版本信息，默认为0
  long info                              OBJC2_UNAVAILABLE;  // 类信息，供运行期使用的一些位标识
  long instance_size                     OBJC2_UNAVAILABLE;  // 该类的实例变量大小
  struct objc_ivar_list *ivars           OBJC2_UNAVAILABLE;  // 该类的成员变量链表
  struct objc_method_list **methodLists   OBJC2_UNAVAILABLE;  // 方法定义的链表
  struct objc_cache *cache                OBJC2_UNAVAILABLE;  // 方法缓存
  struct objc_protocol_list *protocols   OBJC2_UNAVAILABLE;  // 协议链表
  #endif
} OBJC2_UNAVAILABLE;
</code></pre><p>其中，有几个字段是我们需要掌握的。<br>1.<code>isa</code>：需要注意的是在<code>Objective-C</code>中，所有的类自身也是一个对象，这个对象的<code>Class</code>里面也有一个<code>isa</code>指针，它指向<code>metaClass</code>(元类)。<br>2.<code>super_class</code>：指向该类的父类，如果该类已经是最顶层的根类(如NSObject或NSProxy)，则<code>super_class</code>为NULL。<br>3.<code>methodLists</code>：看名字也容易理解，这个<code>methodLists</code>就是用来存放方法列表的。<br>4.<code>cache</code>：用于缓存最近使用的方法。<br>5.<code>version</code>：我们可以使用这个字段来提供类的版本信息。这对于对象的序列化非常有用，它可是让我们识别出不同类定义版本中实例变量布局的改变。</p>
<h3 id="元类（Meta-Class）"><a href="#元类（Meta-Class）" class="headerlink" title="元类（Meta Class）"></a>元类（Meta Class）</h3><p>所有的类自身也是一个对象，我们可以向这个对象发送消息(即调用类方法)。既然是对象，那么它也是一个<code>objc_object</code>指针，它包含一个指向其类的一个<code>isa</code>指针。那么这些就有一个问题了，这个<code>isa</code>指针指向什么呢？这个类的<code>isa</code>指针必须指向一个包含这些类方法的一个<code>objc_class</code>结构体。这就引出了<code>meta-class</code>的概念：<code>meta-class</code>是一个类对象的类。<br>当我们向一个对象发送消息时，<code>runtime</code>会在这个对象所属的这个类的方法列表中查找方法；而向一个类发送消息时，会在这个类的<code>meta-class</code>的方法列表中查找。<br><code>meta-class</code>之所以重要，是因为它存储着一个类的所有类方法。每个类都会有一个单独的<code>meta-class</code>，因为每个类的类方法基本不可能完全相同。<br>再深入一下，<code>meta-class</code>也是一个类，也可以向它发送一个消息，那么它的<code>isa</code>又是指向什么呢？为了不让这种结构无限延伸下去，<code>Objective-C</code>的设计者让所有的<code>meta-class</code>的<code>isa</code>指向基类的<code>meta-class</code>，以此作为它们的所属类。即，任何<code>NSObject</code>继承体系下的<code>meta-class</code>都使用<code>NSObject</code>的<code>meta-class</code>作为自己的所属类，而基类的<code>meta-class</code>的<code>isa</code>指针是指向它自己。这样就形成了一个完美的闭环。<br>通过上面的描述，再加上对<code>objc_class</code>结构体中<code>super_class</code>指针的分析，我们就可以描绘出类及相应<code>meta-class</code>类的一个继承体系了，如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/6365912-dcdc6ad08b4b4dbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.png"></p>
<pre><code>MyClass *myClass = [[MyClass alloc] init];

Class class = [myClass class];
Class metaClass = object_getClass(class);
Class metaOfMetaClass = object_getClass(metaClass);
Class rootMetaClass = object_getClass(metaOfMetaClass);
Class superclass = class_getSuperclass(class);
Class superOfSuperclass = class_getSuperclass(superclass);
Class superOfMetaOfSuperclass = class_getSuperclass(object_getClass(superclass));

NSLog(@&quot;MyClass 实例对象是：%p&quot;,myClass);
NSLog(@&quot;MyClass 类对象是：%p&quot;,class);
NSLog(@&quot;MyClass 元类对象是：%p&quot;,metaClass);
NSLog(@&quot;MyClass 元类对象的元类对象是：%p&quot;,metaOfMetaClass);
NSLog(@&quot;MyClass 根元类对象是：%p&quot;,rootMetaClass);
NSLog(@&quot;MyClass 父类是：%@&quot;,class_getSuperclass(class));
NSLog(@&quot;MyClass 父类的父类是：%@&quot;,superOfSuperclass);
NSLog(@&quot;MyClass 父类的元类的父类是：%@&quot;,superOfMetaOfSuperclass);

NSLog(@&quot;NSObject 元类对象是：%p&quot;,object_getClass([NSObject class]));
NSLog(@&quot;NSObject 父类是：%@&quot;,[[NSObject class] superclass]);
NSLog(@&quot;NSObject 元类对象的父类是：%@&quot;,[object_getClass([NSObject class]) superclass]);

//输出：
MyClass 实例对象是：0x60c00000b8d0
MyClass 类对象是：0x109ae3fd0
MyClass 元类对象是：****0x109ae3fa8
MyClass 元类对象的元类对象是：****0x10ab02e58**
MyClass 根元类对象是：0x10ab02e58
MyClass 父类是：NSObject
MyClass 父类的父类是：(null)
MyClass 父类的元类的父类是：NSObject
NSObject 元类对象是：0x10ab02e58
NSObject 父类是：(null)
NSObject 元类对象的父类是：NSObject
</code></pre><p>现在我们能知道各种对象之间的关系</p>
<blockquote>
<p>实例对象通过 isa 指针，找到类对象 Class；类对象同样通过 isa 指针，找到元类对象；元类对象也是通过 isa 指针，找到根元类对象；最后，根元类对象的 isa 指针，指向自己。可以发现 NSObject 是整个消息机制的核心，绝大数对象都继承自它。</p>
</blockquote>
<h3 id="methodLists"><a href="#methodLists" class="headerlink" title="methodLists"></a>methodLists</h3><p>我们再来看看<code>objc_method_list</code>这个结构体</p>
<pre><code>struct objc_method_list {
  struct objc_method_list * _Nullable obsolete OBJC2_UNAVAILABLE;

  int method_count OBJC2_UNAVAILABLE;
  #ifdef __LP64__
  int space  OBJC2_UNAVAILABLE;
  #endif
  /* variable length structure */
  struct objc_method method_list[1]  OBJC2_UNAVAILABLE;
}
</code></pre><p>里面的<code>objc_method</code>，也就是我们熟悉的<code>Method</code></p>
<pre><code>struct objc_method {
  SEL _Nonnull method_name OBJC2_UNAVAILABLE;         //方法的名称
  char * _Nullable method_types  OBJC2_UNAVAILABLE;   //方法的类型
  IMP _Nonnull method_imp  OBJC2_UNAVAILABLE;         // 方法的具体实现
}
</code></pre><p>由此我们可以得出实例对象调用方法的大致逻辑：</p>
<pre><code>MyClass *myClass = [[MyClass alloc] init];
[myClass printLog];
</code></pre><blockquote>
<p>先被编译成 <code>((void (*)(id, SEL))(void *) objc_msgSend)(myClass, @selector(printLog));</code><br>沿着入参<code>myClass</code>的<code>isa</code>指针，找到<code>myClass</code>的类对象（<code>Class</code>），也就是 <code>MyClass</code><br>接着在<code>MyClass</code>的方法列表<code>methodLists</code>中，找到对应的<code>Method</code><br>最后找到 <code>Method</code> 中的 <code>IMP</code> 指针，执行具体实现</p>
</blockquote>
<p>由上文，我们已经知道，实例对象是通过<code>isa</code>指针，找到其类对象（<code>Class</code>）中保存的方法列表中的具体实现的。<code>printLog</code>方法就是保存在<code>MyClass</code>中的。<br>那么如果是个类方法，又是保存在什么地方的呢？我们也知道了类对象的<code>isa</code>指针是指向元类对象的。那么不难得出：</p>
<blockquote>
<p>类对象的类方法，是保存在元类对象中的！</p>
</blockquote>
<h3 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h3><p>我们大概知道，方法是通过<code>isa</code>指针，查找<code>Class</code> 中的<code>methodLists</code>的。如果子类没实现对应的方法实现，还会沿着父类去查找。整个工程，可能有成万上亿个方法，是如何解决性能问题的呢？如果每调用一次都需要遍历<code>methodLists</code>，性能是非常差的。所以引入了 <code>Class Cache</code> 机制：<code>Class Cache</code> 认为，当一个方法被调用，那么它之后被调用的可能性就越大。<br>查找方法时，会先从缓存中查找，找到直接返回 ；找不到，再去<code>Class</code>的方法列表中找。<br>在上文中 Class 的定义中，我们可以发现 cache：<br><code>struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE;</code><br>说明了缓存是存在类中的，每个类都有一份方法缓存，而不是每个类的 object 都保存了一份。</p>
<h3 id="父类（superclass）"><a href="#父类（superclass）" class="headerlink" title="父类（superclass）"></a>父类（superclass）</h3><p>在<code>Objective-C</code>中，子类调用一个方法，如果没有子类没有实现，父类实现了，会去调用父类的实现。上文中，找到<code>methodLists</code>后，寻找 <code>Method</code> 的大致过程如下：<br><img src="https://upload-images.jianshu.io/upload_images/6365912-83f14b531a14d3ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.png"></p>
<blockquote>
<p>ps: 其实这里的寻找过程远没有这么简单，可能会遍历很多遍，因为我们可能会在运行时动态的添加方法（比如<code>category</code>）。遍历的过程中同样不时的去查询缓存表。</p>
</blockquote>
<h3 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h3><p>如果方法列表（methodLists）没找到对应的 selector 呢？<br><code>[self performSelector:@selector(myTestPrint:) withObject:@&quot;嘻嘻&quot;];</code><br>系统会提供三次补救的机会。</p>
<h4 id="第一次"><a href="#第一次" class="headerlink" title="第一次"></a>第一次</h4><p><code>+ (BOOL)resolveInstanceMethod:(SEL)sel {} (实例方法)</code><br><code>+ (BOOL)resolveClassMethod:(SEL)sel {}  (类方法)</code></p>
<p>这两个方法，一个针对实例方法；一个针对类方法。返回值都是<code>Bool</code>。</p>
<pre><code>// ViewController.m 中

void myMethod(id self, SEL _cmd,NSString *nub) {
  NSLog(@&quot;ifelseboyxx%@&quot;,nub);
}

+ (BOOL)resolveInstanceMethod:(SEL)sel {
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored &quot;-Wundeclared-selector&quot;
  if (sel == @selector(myTestPrint:)) {
    #pragma clang diagnostic pop
    class_addMethod([self class],sel,(IMP)myMethod,&quot;v@:@&quot;);
    return YES;
  }else {
    return [super resolveInstanceMethod:sel];
  }
}
</code></pre><p>我们只需要在 <code>resolveInstanceMethod:</code> 方法中，利用 <code>class_addMethod</code> 方法，将未实现的<code>myTestPrint:</code>绑定到 <code>myMethod</code>上就能完成转发，最后返回<code>YES</code>。</p>
<h4 id="第二次"><a href="#第二次" class="headerlink" title="第二次"></a>第二次</h4><p><code>- (id)forwardingTargetForSelector:(SEL)aSelector {}</code><br>这个方法要求返回一个<code>id</code>。使用场景一般是将 A 类的某个方法，转发到 B 类的实现中去。<br>使用示例：<br>想转发到 <code>Person</code> 类中的<code>-myTestPrint:</code>方法中：</p>
<pre><code>@interface Person : NSObject
@end

@implementation Person
- (void)myTestPrint:(NSString *)str {
  NSLog(@&quot;ifelseboyxx%@&quot;,str);
}
@end
// ViewController.m 中

- (id)forwardingTargetForSelector:(SEL)aSelector {
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored &quot;-Wundeclared-selector&quot;
  if (aSelector == @selector(myTestPrint:)) {
  #pragma clang diagnostic pop
    return [Person new];
  }else{
    return [super forwardingTargetForSelector:aSelector];
  }
}
</code></pre><h4 id="第三次"><a href="#第三次" class="headerlink" title="第三次"></a>第三次</h4><p><code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {}</code><br><code>- (void)forwardInvocation:(NSInvocation *)anInvocation {}</code><br>第一个要求返回一个方法签名，第二个方法转发具体的实现。二者相互依赖，只有返回了正确的方法签名，才会执行第二个方法。<br>这次的转发作用和第二次的比较类似，都是将 A 类的某个方法，转发到 B 类的实现中去。不同的是，第三次的转发相对于第二次更加灵活，<code>forwardingTargetForSelector:</code>只能固定的转发到一个对象；<code>forwardInvocation:</code>可以让我们转发到多个对象中去。<br>使用实例：<br>想转发到 <code>Person</code> 类以及<code>Animal</code>类中的<code>-myTestPrint:</code>方法中：</p>
<pre><code>@interface Person : NSObject
@end

@implementation Person
- (void)myTestPrint:(NSString *)str {
  NSLog(@&quot;ifelseboyxx%@&quot;,str);
}
@end
@interface Animal : NSObject
@end

@implementation Animal
- (void)myTestPrint:(NSString *)str {
  NSLog(@&quot;tiger%@&quot;,str);
}
@end

// ViewController.m 中

- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored &quot;-Wundeclared-selector&quot;
  if (aSelector == @selector(myTestPrint:)) {
    #pragma clang diagnostic pop
    return [NSMethodSignature  signatureWithObjCTypes:&quot;v@:@&quot;];
  }
  return [super methodSignatureForSelector:aSelector];
}

- (void)forwardInvocation:(NSInvocation *)anInvocation {
  Person *person = [Person new];
  Animal *animal = [Animal new];
  if ([person respondsToSelector:anInvocation.selector]) {
    [anInvocation invokeWithTarget:person];
  }
  if ([animal respondsToSelector:anInvocation.selector]) {
    [anInvocation invokeWithTarget:animal];
  }
}
</code></pre><blockquote>
<p>⚠️ 如果到了第三次机会，还没找到对应的实现，就会 crash：<br>unrecognized selector sent to instance 0x7f9f817072b0</p>
</blockquote>
<p>消息发送和消息转发的过程<br><img src="https://upload-images.jianshu.io/upload_images/6365912-1a12a79877ec160c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/hzsss/Object-C-Runtime-及消息发送与转发/" data-id="cjps68qfh001a63fyv08dbgnz" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/iOS开发之深复制和浅复制/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          iOS开发之深复制和浅复制
        
      </div>
    </a>
  
  
    <a href="/App-Store被拒的一次经历（附解决方案）/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">App Store被拒的一次经历（附解决方案）</div>
    </a>
  
</nav>

  
</article>



</section>
        
          <aside id="sidebar">
  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <h1 class="blog-title">Acan_Dev</h1>
    <h2 class="blog-subtitle"></h2>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
    </ul>
  </div>
</div>

  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="https://avatars0.githubusercontent.com/u/20333903?v=3&amp;s=460">
    <h2 class="author">Acan_Dev</h2>
    <h3 class="description">You only live once</h3>
    <div class="count-box">
      <a href="/archives"><div><strong>20</strong><br>文章</div></a>
      <a href="/categories"><div><strong>0</strong><br>分类</div></a>
      <a href="/tags"><div><strong>5</strong><br>标签</div></a>
    </div>



    <div class="social-link">
      
        <a class="hvr-bounce-in" href="http://github.com/ShanaMaid" target="_blank" title="Github">
          Github
        </a>
      
    </div>

    <div class="friend-link">
      <h2>友情链接</h2>
      
        <a class="hvr-bounce-in" href="http://blog.shanamaid.top/" target="_blank" title="ShanaMaid">
          ShanaMaid
        </a>
      
    </div>
  </div>
</div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy;2017 - 2018 Acan_Dev<br>
      由<a href="http://hexo.io/" target="_blank">Hexo</a>强力驱动 | 
      主题-<a href="https://github.com/ShanaMaid/hexo-theme-shana">Shana</a>
      
    </div>
    
  </div>
</footer>
    </div>
    

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="//apps.bdimg.com/libs/wow/0.1.6/wow.min.js"></script>
<script>
new WOW().init();
</script>   


  <link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css">
  <script src="/plugin/fancybox/jquery.fancybox.pack.js"></script>



  <link rel="stylesheet" href="/plugin/galmenu/GalMenu.css">
  <script src="/plugin/galmenu/GalMenu.js"></script>
  <div class="GalMenu GalDropDown">
      <div class="circle" id="gal">
        <div class="ring">
          
            <a href="/" title="" class="menuItem">首页</a>
          
            <a href="/tags" title="" class="menuItem">标签</a>
          
            <a href="/categories" title="" class="menuItem">分类</a>
          
            <a href="/archives" title="" class="menuItem">归档</a>
          
            <a href="/xxxxxxxxx" title="" class="menuItem">xxx</a>
          
            <a href="/xxxxxxx" title="" class="menuItem">xxxx</a>
          
        </div>
        
          <audio id="audio" src="#"></audio>
        
      </div> 
</div>
<div id="overlay" style="opacity: 1; cursor: pointer;"></div>
  <script type="text/javascript">var items = document.querySelectorAll('.menuItem');
    for (var i = 0,
    l = items.length; i < l; i++) {
      items[i].style.left = (50 - 35 * Math.cos( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%";
      items[i].style.top = (50 + 35 * Math.sin( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%"
    }</script>
<script type="text/javascript">
  $(document).ready(function() {
    $('body').GalMenu({
      'menu': 'GalDropDown'
    })
  });
</script>

  <section class="hidden-xs"> 
  <ul class="cb-slideshow"> 
    <li><span>苟利</span></li> 
    <li><span>国家</span></li> 
    <li><span>生死以</span></li> 
    <li><span>岂能</span></li> 
    <li><span>祸福</span></li> 
    <li><span>趋避之</span></li> 
  </ul>
</section>
<script src="/js/script.js"></script>



  </div>
</body>
</html>